Preface
The goal of this text is focus on a core subset of the natural language processing, uniﬁed
by the concepts of learning and search. A remarkable number of problems in natural
language processing can be solved by a compact set of methods:
Search. Viterbi, CKY, minimum spanning tree, shift-reduce, integer linear programming,
beam search.
Learning. Maximum-likelihood estimation, logistic regression, perceptron, expectation-
maximization, matrix factorization, backpropagation.
This text explains how these methods work, and how they can be applied to a wide range
of tasks: document classiﬁcation, word sense disambiguation, part-of-speech tagging,
named entity recognition, parsing, coreference resolution, relation extraction, discourse
analysis, language modeling, and machine translation.
Background
Because natural language processing draws on many different intellectual traditions, al-
most everyone who approaches it feels underprepared in one way or another. Here is a
summary of what is expected, and where you can learn more:
Mathematics and machine learning. The text assumes a background in multivariate cal-
culus and linear algebra: vectors, matrices, derivatives, and partial derivatives. You
should also be familiar with probability and statistics. A review of basic proba-
bility is found in Appendix A, and a minimal review of numerical optimization is
found in Appendix B. For linear algebra, the online course and textbook from Strang
() provide an excellent review. Deisenroth et al. () are currently preparing
a textbook on Mathematics for Machine Learning, a draft can be found online. For
an introduction to probabilistic modeling and estimation, see James et al. (); for
https://mml-book.github.io/

ii
PREFACE
a more advanced and comprehensive discussion of the same material, the classic
reference is Hastie et al. ().
Linguistics. This book assumes no formal training in linguistics, aside from elementary
concepts likes nouns and verbs, which you have probably encountered in the study
of English grammar. Ideas from linguistics are introduced throughout the text as
needed, including discussions of morphology and syntax (chapter ), semantics
(chapters  and ), and discourse (chapter ). Linguistic issues also arise in the
application-focused chapters , , and . A short guide to linguistics for students
of natural language processing is offered by Bender (); you are encouraged to
start there, and then pick up a more comprehensive introductory textbook (e.g., Ak-
majian et al., ; Fromkin et al., ).
Computer science. The book is targeted at computer scientists, who are assumed to have
taken introductory courses on the analysis of algorithms and complexity theory. In
particular, you should be familiar with asymptotic analysis of the time and memory
costs of algorithms, and with the basics of dynamic programming. The classic text
on algorithms is offered by Cormen et al. (); for an introduction to the theory of
computation, see Arora and Barak () and Sipser ().
How to use this book
After the introduction, the textbook is organized into four main units:
Learning. This section builds up a set of machine learning tools that will be used through-
out the other sections. Because the focus is on machine learning, the text represen-
tations and linguistic phenomena are mostly simple: “bag-of-words” text classiﬁca-
tion is treated as a model example. Chapter  describes some of the more linguisti-
cally interesting applications of word-based text analysis.
Sequences and trees. This section introduces the treatment of language as a structured
phenomena. It describes sequence and tree representations and the algorithms that
they facilitate, as well as the limitations that these representations impose. Chap-
ter  introduces ﬁnite state automata and brieﬂy overviews a context-free account of
English syntax.
Meaning. This section takes a broad view of efforts to represent and compute meaning
from text, ranging from formal logic to neural word embeddings. It also includes
two topics that are closely related to semantics: resolution of ambiguous references,
and analysis of multi-sentence discourse structure.
Applications. The ﬁnal section offers chapter-length treatments on three of the most promi-
nent applications of natural language processing: information extraction, machine
Jacob Eisenstein. Draft of November , .

iii
translation, and text generation. Each of these applications merits a textbook length
treatment of its own (Koehn, ; Grishman, ; Reiter and Dale, ); the chap-
ters here explain some of the most well known systems using the formalisms and
methods built up earlier in the book, while introducing methods such as neural at-
tention.
Each chapter contains some advanced material, which is marked with an asterisk.
This material can be safely omitted without causing misunderstandings later on. But
even without these advanced sections, the text is too long for a single semester course, so
instructors will have to pick and choose among the chapters.
Chapters - provide building blocks that will be used throughout the book, and chap-
ter  describes some critical aspects of the practice of language technology. Language
models (chapter ), sequence labeling (chapter ), and parsing (chapter  and ) are
canonical topics in natural language processing, and distributed word embeddings (chap-
ter ) have become ubiquitous. Of the applications, machine translation (chapter ) is
the best choice: it is more cohesive than information extraction, and more mature than text
generation. Many students will beneﬁt from the review of probability in Appendix A.
A course focusing on machine learning should add the chapter on unsupervised
learning (chapter ). The chapters on predicate-argument semantics (chapter ),
reference resolution (chapter ), and text generation (chapter ) are particularly
inﬂuenced by recent progress in machine learning, including deep neural networks
and learning to search.
A course with a more linguistic orientation should add the chapters on applica-
tions of sequence labeling (chapter ), formal language theory (chapter ), semantics
(chapter  and ), and discourse (chapter ).
For a course with a more applied focus, I recommend the chapters on applications
of sequence labeling (chapter ), predicate-argument semantics (chapter ), infor-
mation extraction (chapter ), and text generation (chapter ).
Acknowledgments
Several colleagues, students, and friends read early drafts of chapters in their areas of
expertise, including Yoav Artzi, Kevin Duh, Heng Ji, Jessy Li, Brendan O’Connor, Yuval
Pinter, Shawn Ling Ramirez, Nathan Schneider, Pamela Shapiro, Noah A. Smith, Sandeep
Soni, and Luke Zettlemoyer. I also thank the anonymous reviewers, particularly reviewer
, who provided detailed line-by-line edits and suggestions. The text beneﬁted from high-
level discussions with my editor Marie Lufkin Lee, as well as Kevin Murphy, Shawn Ling
Ramirez, and Bonnie Webber. In addition, there are many students, colleagues, friends,
and family who found mistakes in early drafts, or who recommended key references.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

iv
PREFACE
These include: Parminder Bhatia, Kimberly Caras, Jiahao Cai, Justin Chen, Rodolfo Del-
monte, Murtaza Dhuliawala, Yantao Du, Barbara Eisenstein, Luiz C. F. Ribeiro, Chris Gu,
Joshua Killingsworth, Jonathan May, Taha Merghani, Gus Monod, Raghavendra Murali,
Nidish Nair, Brendan O’Connor, Dan Oneata, Brandon Peck, Yuval Pinter, Nathan Schnei-
der, Jianhao Shen, Zhewei Sun, Rubin Tsui, Ashwin Cunnapakkam Vinjimur, Denny
Vrandeˇci´c, William Yang Wang, Clay Washington, Ishan Waykul, Aobo Yang, Xavier Yao,
Yuyu Zhang, and several anonymous commenters. Clay Washington tested some of the
programming exercises, and Varun Gupta tested some of the written exercises. Thanks to
Kelvin Xu for sharing a high-resolution version of Figure ..
Most of the book was written while I was at Georgia Tech’s School of Interactive Com-
puting. I thank the School for its support of this project, and I thank my colleagues there
for their help and support at the beginning of my faculty career. I also thank (and apol-
ogize to) the many students in Georgia Tech’s CS  and  who suffered through
early versions of the text. The book is dedicated to my parents.
Jacob Eisenstein. Draft of November , .

Notation
As a general rule, words, word counts, and other types of observations are indicated with
Roman letters (a, b, c); parameters are indicated with Greek letters (α, β, θ). Vectors are
indicated with bold script for both random variables x and parameters θ. Other useful
notations are indicated in the table below.
Basics
exp x
the base- exponent, x
log x
the base- logarithm, log x
{xn}N
n=
the set {x, x, . . . , xN}
xj
xi raised to the power j
x(j)
indexing by both i and j
Linear algebra
x(i)
a column vector of feature counts for instance i, often word counts
xj:k
elements j through k (inclusive) of a vector x
[x; y]
vertical concatenation of two column vectors
[x, y]
horizontal concatenation of two column vectors
en
a “one-hot” vector with a value of  at position n, and zero everywhere
else
θ⊤
the transpose of a column vector θ
θ  x(i)
the dot product PN
j= θj × x(i)
a matrix
xi,j
row i, column j of matrix X
Diag(x)
a matrix with x on the diagonal, e.g.,
X−
the inverse of matrix X

vi
PREFACE
Text datasets
wm
word token at position m
number of training instances
length of a sequence (of words or tags)
number of words in vocabulary
y(i)
the true label for instance i
ˆy
a predicted label
the set of all possible labels
number of possible labels K = |Y|
the start token
the stop token
y(i)
a structured label for instance i, such as a tag sequence
Y(w)
the set of possible labelings for the word sequence w
the start tag
the stop tag
Probabilities
Pr(A)
probability of event A
Pr(A | B)
probability of event A, conditioned on event B
pB(b)
the marginal probability of random variable B taking value b; written
p(b) when the choice of random variable is clear from context
pB|A(b | a)
the probability of random variable B taking value b, conditioned on A
taking value a; written p(b | a) when clear from context
A ∼ p
the random variable A is distributed according to distribution p. For
example, X ∼ N(, ) states that the random variable X is drawn from
a normal distribution with zero mean and unit variance.
A | B ∼ p
conditioned on the random variable B, A is distributed according to p.
Machine learning
Ψ(x(i), y)
the score for assigning label y to instance i
f(x(i), y)
the feature vector for instance i with label y
a (column) vector of weights
ℓ(i)
loss on an individual instance i
objective function for an entire dataset
log-likelihood of a dataset
the amount of regularization
Jacob Eisenstein. Draft of November , .

Chapter
Introduction
Natural language processing is the set of methods for making human language accessi-
ble to computers. In the past decade, natural language processing has become embedded
in our daily lives: automatic machine translation is ubiquitous on the web and in so-
cial media; text classiﬁcation keeps our email inboxes from collapsing under a deluge of
spam; search engines have moved beyond string matching and network analysis to a high
degree of linguistic sophistication; dialog systems provide an increasingly common and
effective way to get and share information.
These diverse applications are based on a common set of ideas, drawing on algo-
rithms, linguistics, logic, statistics, and more. The goal of this text is to provide a survey
of these foundations. The technical fun starts in the next chapter; the rest of this current
chapter situates natural language processing with respect to other intellectual disciplines,
identiﬁes some high-level themes in contemporary natural language processing, and ad-
vises the reader on how best to approach the subject.
Natural language processing and its neighbors
Natural language processing draws on many other intellectual traditions, from formal
linguistics to statistical physics. This section brieﬂy situates natural language processing
with respect to some of its closest neighbors.
Computational Linguistics
Most of the meetings and journals that host natural lan-
guage processing research bear the name “computational linguistics”, and the terms may
be thought of as essentially synonymous. But while there is substantial overlap, there is
an important difference in focus. In linguistics, language is the object of study. Computa-
tional methods may be brought to bear, just as in scientiﬁc disciplines like computational
biology and computational astronomy, but they play only a supporting role. In contrast,
CHAPTER . INTRODUCTION
natural language processing is focused on the design and analysis of computational al-
gorithms and representations for processing natural human language. The goal of natu-
ral language processing is to provide new computational capabilities around human lan-
guage: for example, extracting information from texts, translating between languages, an-
swering questions, holding a conversation, taking instructions, and so on. Fundamental
linguistic insights may be crucial for accomplishing these tasks, but success is ultimately
measured by whether and how well the job gets done.
Machine Learning
Contemporary approaches to natural language processing rely heav-
ily on machine learning, which makes it possible to build complex computer programs
from examples. Machine learning provides an array of general techniques for tasks like
converting a sequence of discrete tokens in one vocabulary to a sequence of discrete to-
kens in another vocabulary — a generalization of what one might informally call “transla-
tion.” Much of today’s natural language processing research can be thought of as applied
machine learning. However, natural language processing has characteristics that distin-
guish it from many of machine learning’s other application domains.
Unlike images or audio, text data is fundamentally discrete, with meaning created
by combinatorial arrangements of symbolic units. This is particularly consequential
for applications in which text is the output, such as translation and summarization,
because it is not possible to gradually approach an optimal solution.
Although the set of words is discrete, new words are always being created. Further-
more, the distribution over words (and other linguistic elements) resembles that of a
power law (Zipf, ): there will be a few words that are very frequent, and a long
tail of words that are rare. A consequence is that natural language processing algo-
rithms must be especially robust to observations that do not occur in the training
data.
Language is compositional: units such as words can combine to create phrases,
which can combine by the very same principles to create larger phrases. For ex-
ample, a noun phrase can be created by combining a smaller noun phrase with a
prepositional phrase, as in the whiteness of the whale. The prepositional phrase is
created by combining a preposition (in this case, of) with another noun phrase (the
whale). In this way, it is possible to create arbitrarily long phrases, such as,
. . . huge globular pieces of the whale of the bigness of a human head.
The meaning of such a phrase must be analyzed in accord with the underlying hier-
archical structure. In this case, huge globular pieces of the whale acts as a single noun
Throughout the text, boldface will be used to indicate keywords that appear in the index.
Throughout the text, this notation will be used to introduce linguistic examples.
Jacob Eisenstein. Draft of November , .

.. NATURAL LANGUAGE PROCESSING AND ITS NEIGHBORS
phrase, which is conjoined with the prepositional phrase of the bigness of a human
head. The interpretation would be different if instead, huge globular pieces were con-
joined with the prepositional phrase of the whale of the bigness of a human head —
implying a disappointingly small whale. Even though text appears as a sequence,
machine learning methods must account for its implicit recursive structure.
Artiﬁcial Intelligence
The goal of artiﬁcial intelligence is to build software and robots
with the same range of abilities as humans (Russell and Norvig, ). Natural language
processing is relevant to this goal in several ways. On the most basic level, the capacity for
language is one of the central features of human intelligence, and is therefore a prerequi-
site for artiﬁcial intelligence. Second, much of artiﬁcial intelligence research is dedicated
to the development of systems that can reason from premises to a conclusion, but such
algorithms are only as good as what they know (Dreyfus, ). Natural language pro-
cessing is a potential solution to the “knowledge bottleneck”, by acquiring knowledge
from texts, and perhaps also from conversations. This idea goes all the way back to Tur-
ing’s  paper Computing Machinery and Intelligence, which proposed the Turing test for
determining whether artiﬁcial intelligence had been achieved (Turing, ).
Conversely, reasoning is sometimes essential for basic tasks of language processing,
such as resolving a pronoun. Winograd schemas are examples in which a single word
changes the likely referent of a pronoun, in a way that seems to require knowledge and
reasoning to decode (Levesque et al., ). For example,
The trophy doesn’t ﬁt into the brown suitcase because it is too [small/large].
When the ﬁnal word is small, then the pronoun it refers to the suitcase; when the ﬁnal
word is large, then it refers to the trophy. Solving this example requires spatial reasoning;
other schemas require reasoning about actions and their effects, emotions and intentions,
and social conventions.
Such examples demonstrate that natural language understanding cannot be achieved
in isolation from knowledge and reasoning. Yet the history of artiﬁcial intelligence has
been one of increasing specialization: with the growing volume of research in subdisci-
plines such as natural language processing, machine learning, and computer vision, it is
This view is shared by some, but not all, prominent researchers in artiﬁcial intelligence.
Michael
Jordan, a specialist in machine learning, has said that if he had a billion dollars to spend on any large
research project, he would spend it on natural language processing (https://www.reddit.com/r/
MachineLearning/comments/fxiv/ama_michael_i_jordan/). On the other hand, in a public dis-
cussion about the future of artiﬁcial intelligence in February , computer vision researcher Yann Lecun
argued that despite its many practical applications, language is perhaps “number ” in the priority list
for artiﬁcial intelligence research, and that it would be a great achievement if AI could attain the capa-
bilities of an orangutan, which do not include language (http://www.abigailsee.com////
deep-learning-structure-and-innate-priors.html).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INTRODUCTION
difﬁcult for anyone to maintain expertise across the entire ﬁeld. Still, recent work has
demonstrated interesting connections between natural language processing and other ar-
eas of AI, including computer vision (e.g., Antol et al., ) and game playing (e.g.,
Branavan et al., ). The dominance of machine learning throughout artiﬁcial intel-
ligence has led to a broad consensus on representations such as graphical models and
computation graphs, and on algorithms such as backpropagation and combinatorial opti-
mization. Many of the algorithms and representations covered in this text are part of this
consensus.
Computer Science
The discrete and recursive nature of natural language invites the ap-
plication of theoretical ideas from computer science. Linguists such as Chomsky and
Montague have shown how formal language theory can help to explain the syntax and
semantics of natural language. Theoretical models such as ﬁnite-state and pushdown au-
tomata are the basis for many practical natural language processing systems. Algorithms
for searching the combinatorial space of analyses of natural language utterances can be
analyzed in terms of their computational complexity, and theoretically motivated approx-
imations can sometimes be applied.
The study of computer systems is also relevant to natural language processing. Large
datasets of unlabeled text can be processed more quickly by parallelization techniques
like MapReduce (Dean and Ghemawat, ; Lin and Dyer, ); high-volume data
sources such as social media can be summarized efﬁciently by approximate streaming
and sketching techniques (Goyal et al., ). When deep neural networks are imple-
mented in production systems, it is possible to eke out speed gains using techniques such
as reduced-precision arithmetic (Wu et al., ). Many classical natural language process-
ing algorithms are not naturally suited to graphics processing unit (GPU) parallelization,
suggesting directions for further research at the intersection of natural language process-
ing and computing hardware (Yi et al., ).
Speech Processing
Natural language is often communicated in spoken form, and speech
recognition is the task of converting an audio signal to text. From one perspective, this is
a signal processing problem, which might be viewed as a preprocessing step before nat-
ural language processing can be applied. However, context plays a critical role in speech
recognition by human listeners: knowledge of the surrounding words inﬂuences percep-
tion and helps to correct for noise (Miller et al., ). For this reason, speech recognition
is often integrated with text analysis, particularly with statistical language models, which
quantify the probability of a sequence of text (see chapter ). Beyond speech recognition,
the broader ﬁeld of speech processing includes the study of speech-based dialogue sys-
tems, which are brieﬂy discussed in chapter . Historically, speech processing has often
been pursued in electrical engineering departments, while natural language processing
Jacob Eisenstein. Draft of November , .

.. NATURAL LANGUAGE PROCESSING AND ITS NEIGHBORS
has been the purview of computer scientists. For this reason, the extent of interaction
between these two disciplines is less than it might otherwise be.
Ethics
As machine learning and artiﬁcial intelligence become increasingly ubiquitous, it
is crucial to understand how their beneﬁts, costs, and risks are distributed across differ-
ent kinds of people. Natural language processing raises some particularly salient issues
around ethics, fairness, and accountability:
Access. Who is natural language processing designed to serve? For example, whose lan-
guage is translated from, and whose language is translated to?
Bias. Does language technology learn to replicate social biases from text corpora, and
does it reinforce these biases as seemingly objective computational conclusions?
Labor. Whose text and speech comprise the datasets that power natural language pro-
cessing, and who performs the annotations? Are the beneﬁts of this technology
shared with all the people whose work makes it possible?
Privacy and internet freedom. What is the impact of large-scale text processing on the
right to free and private communication? What is the potential role of natural lan-
guage processing in regimes of censorship or surveillance?
This text lightly touches on issues related to fairness and bias in § .. and § ..,
but these issues are worthy of a book of their own. For more from within the ﬁeld of
computational linguistics, see the papers from the annual workshop on Ethics in Natural
Language Processing (Hovy et al., ; Alfano et al., ). For an outside perspective on
ethical issues relating to data science at large, see boyd and Crawford ().
Others
Natural language processing plays a signiﬁcant role in emerging interdisciplinary
ﬁelds like computational social science and the digital humanities. Text classiﬁcation
(chapter ), clustering (chapter ), and information extraction (chapter ) are particularly
useful tools; another is probabilistic topic models (Blei, ), which are not covered in
this text. Information retrieval (Manning et al., ) makes use of similar tools, and
conversely, techniques such as latent semantic analysis (§ .) have roots in information
retrieval. Text mining is sometimes used to refer to the application of data mining tech-
niques, especially classiﬁcation and clustering, to text. While there is no clear distinction
between text mining and natural language processing (nor between data mining and ma-
chine learning), text mining is typically less concerned with linguistic structure, and more
interested in fast, scalable algorithms.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INTRODUCTION
Three themes in natural language processing
Natural language processing covers a diverse range of tasks, methods, and linguistic phe-
nomena. But despite the apparent incommensurability between, say, the summarization
of scientiﬁc articles (§ ..) and the identiﬁcation of sufﬁx patterns in Spanish verbs
(§ ..), some general themes emerge. The remainder of the introduction focuses on these
themes, which will recur in various forms through the text. Each theme can be expressed
as an opposition between two extreme viewpoints on how to process natural language.
The methods discussed in the text can usually be placed somewhere on the continuum
between these two extremes.
Learning and knowledge
A recurring topic of debate is the relative importance of machine learning and linguistic
knowledge. On one extreme, advocates of “natural language processing from scratch” (Col-
lobert et al., ) propose to use machine learning to train end-to-end systems that trans-
mute raw text into any desired output structure: e.g., a summary, database, or transla-
tion. On the other extreme, the core work of natural language processing is sometimes
taken to be transforming text into a stack of general-purpose linguistic structures: from
subword units called morphemes, to word-level parts-of-speech, to tree-structured repre-
sentations of grammar, and beyond, to logic-based representations of meaning. In theory,
these general-purpose structures should then be able to support any desired application.
The end-to-end approach has been buoyed by recent results in computer vision and
speech recognition, in which advances in machine learning have swept away expert-
engineered representations based on the fundamentals of optics and phonology (Krizhevsky
et al., ; Graves and Jaitly, ). But while machine learning is an element of nearly
every contemporary approach to natural language processing, linguistic representations
such as syntax trees have not yet gone the way of the visual edge detector or the auditory
triphone. Linguists have argued for the existence of a “language faculty” in all human be-
ings, which encodes a set of abstractions specially designed to facilitate the understanding
and production of language. The argument for the existence of such a language faculty
is based on the observation that children learn language faster and from fewer examples
than would be possible if language was learned from experience alone. From a practi-
cal standpoint, linguistic structure seems to be particularly important in scenarios where
training data is limited.
There are a number of ways in which knowledge and learning can be combined in
natural language processing. Many supervised learning systems make use of carefully
engineered features, which transform the data into a representation that can facilitate
The Language Instinct (Pinker, ) articulates these arguments in an engaging and popular style. For
arguments against the innateness of language, see Elman et al. ().
Jacob Eisenstein. Draft of November , .

.. THREE THEMES IN NATURAL LANGUAGE PROCESSING
learning. For example, in a task like search, it may be useful to identify each word’s stem,
so that a system can more easily generalize across related terms such as whale, whales,
whalers, and whaling. (This issue is relatively benign in English, as compared to the many
other languages which include much more elaborate systems of preﬁxed and sufﬁxes.)
Such features could be obtained from a hand-crafted resource, like a dictionary that maps
each word to a single root form. Alternatively, features can be obtained from the output of
a general-purpose language processing system, such as a parser or part-of-speech tagger,
which may itself be built on supervised machine learning.
Another synthesis of learning and knowledge is in model structure: building machine
learning models whose architectures are inspired by linguistic theories. For example, the
organization of sentences is often described as compositional, with meaning of larger
units gradually constructed from the meaning of their smaller constituents. This idea
can be built into the architecture of a deep neural network, which is then trained using
contemporary deep learning techniques (Dyer et al., ).
The debate about the relative importance of machine learning and linguistic knowl-
edge sometimes becomes heated. No machine learning specialist likes to be told that their
engineering methodology is unscientiﬁc alchemy; nor does a linguist want to hear that
the search for general linguistic principles and structures has been made irrelevant by big
data. Yet there is clearly room for both types of research: we need to know how far we
can go with end-to-end learning alone, while at the same time, we continue the search for
linguistic representations that generalize across applications, scenarios, and languages.
For more on the history of this debate, see Church (); for an optimistic view of the
potential symbiosis between computational linguistics and deep learning, see Manning
Search and learning
Many natural language processing problems can be written mathematically in the form
of optimization,
ˆy = argmax
y∈Y(x)
Ψ(x, y; θ),
where,
x is the input, which is an element of a set X;
y is the output, which is an element of a set Y(x);
Ali Rahimi argued that much of deep learning research was similar to “alchemy” in a presentation at
the  conference on Neural Information Processing Systems. He was advocating for more learning theory,
not more linguistics.
Throughout this text, equations will be numbered by square brackets, and linguistic examples will be
numbered by parentheses.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INTRODUCTION
Ψ is a scoring function (also called the model), which maps from the set X × Y to
the real numbers;
θ is a vector of parameters for Ψ;
ˆy is the predicted output, which is chosen to maximize the scoring function.
This basic structure can be applied to a huge range of problems. For example, the input
x might be a social media post, and the output y might be a labeling of the emotional
sentiment expressed by the author (chapter ); or x could be a sentence in French, and the
output y could be a sentence in Tamil (chapter ); or x might be a sentence in English,
and y might be a representation of the syntactic structure of the sentence (chapter ); or
x might be a news article and y might be a structured record of the events that the article
describes (chapter ).
This formulation reﬂects an implicit decision that language processing algorithms will
have two distinct modules:
Search. The search module is responsible for computing the argmax of the function Ψ. In
other words, it ﬁnds the output ˆy that gets the best score with respect to the input x.
This is easy when the search space Y(x) is small enough to enumerate, or when the
scoring function Ψ has a convenient decomposition into parts. In many cases, we
will want to work with scoring functions that do not have these properties, moti-
vating the use of more sophisticated search algorithms, such as bottom-up dynamic
programming (§ .) and beam search (§ ..). Because the outputs are usually
discrete in language processing problems, search often relies on the machinery of
combinatorial optimization.
Learning. The learning module is responsible for ﬁnding the parameters θ. This is typ-
ically (but not always) done by processing a large dataset of labeled examples,
{(x(i), y(i))}N
i=. Like search, learning is also approached through the framework
of optimization, as we will see in chapter . Because the parameters are usually
continuous, learning algorithms generally rely on numerical optimization to iden-
tify vectors of real-valued parameters that optimize some function of the model and
the labeled data. Some basic principles of numerical optimization are reviewed in
Appendix B.
The division of natural language processing into separate modules for search and
learning makes it possible to reuse generic algorithms across many tasks and models.
Much of the work of natural language processing can be focused on the design of the
model Ψ — identifying and formalizing the linguistic phenomena that are relevant to the
task at hand — while reaping the beneﬁts of decades of progress in search, optimization,
and learning. This textbook will describe several classes of scoring functions, and the
corresponding algorithms for search and learning.
Jacob Eisenstein. Draft of November , .

.. THREE THEMES IN NATURAL LANGUAGE PROCESSING
When a model is capable of making subtle linguistic distinctions, it is said to be ex-
pressive. Expressiveness is often traded off against efﬁciency of search and learning. For
example, a word-to-word translation model makes search and learning easy, but it is not
expressive enough to distinguish good translations from bad ones. Many of the most im-
portant problems in natural language processing seem to require expressive models, in
which the complexity of search grows exponentially with the size of the input. In these
models, exact search is usually impossible. Intractability threatens the neat modular de-
composition between search and learning: if search requires a set of heuristic approxima-
tions, then it may be advantageous to learn a model that performs well under these spe-
ciﬁc heuristics. This has motivated some researchers to take a more integrated approach
to search and learning, as brieﬂy mentioned in chapters  and .
Relational, compositional, and distributional perspectives
Any element of language — a word, a phrase, a sentence, or even a sound — can be
described from at least three perspectives. Consider the word journalist. A journalist is
a subcategory of a profession, and an anchorwoman is a subcategory of journalist; further-
more, a journalist performs journalism, which is often, but not always, a subcategory of
writing. This relational perspective on meaning is the basis for semantic ontologies such
as WORDNET (Fellbaum, ), which enumerate the relations that hold between words
and other elementary semantic units. The power of the relational perspective is illustrated
by the following example:
Umashanthi interviewed Ana. She works for the college newspaper.
Who works for the college newspaper? The word journalist, while not stated in the ex-
ample, implicitly links the interview to the newspaper, making Umashanthi the most likely
referent for the pronoun. (A general discussion of how to resolve pronouns is found in
chapter .)
Yet despite the inferential power of the relational perspective, it is not easy to formalize
computationally. Exactly which elements are to be related? Are journalists and reporters
distinct, or should we group them into a single unit? Is the kind of interview performed by
a journalist the same as the kind that one undergoes when applying for a job? Ontology
designers face many such thorny questions, and the project of ontology design hearkens
back to Borges’ () Celestial Emporium of Benevolent Knowledge, which divides animals
into:
(a) belonging to the emperor; (b) embalmed; (c) tame; (d) suckling pigs; (e)
sirens; (f) fabulous; (g) stray dogs; (h) included in the present classiﬁcation;
(i) frenzied; (j) innumerable; (k) drawn with a very ﬁne camelhair brush; (l) et
cetera; (m) having just broken the water pitcher; (n) that from a long way off
resemble ﬂies.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INTRODUCTION
Difﬁculties in ontology construction have led some linguists to argue that there is no task-
independent way to partition up word meanings (Kilgarriff, ).
Some problems are easier. Each member in a group of journalists is a journalist: the -s
sufﬁx distinguishes the plural meaning from the singular in most of the nouns in English.
Similarly, a journalist can be thought of, perhaps colloquially, as someone who produces or
works on a journal. (Taking this approach even further, the word journal derives from the
French jour+nal, or day+ly = daily.) In this way, the meaning of a word is constructed from
the constituent parts — the principle of compositionality. This principle can be applied
to larger units: phrases, sentences, and beyond. Indeed, one of the great strengths of the
compositional view of meaning is that it provides a roadmap for understanding entire
texts and dialogues through a single analytic lens, grounding out in the smallest parts of
individual words.
But alongside journalists and anti-parliamentarians, there are many words that seem
to be linguistic atoms: think, for example, of whale, blubber, and Nantucket. Idiomatic
phrases like kick the bucket and shoot the breeze have meanings that are quite different from
the sum of their parts (Sag et al., ). Composition is of little help for such words and
expressions, but their meanings can be ascertained — or at least approximated — from the
contexts in which they appear. Take, for example, blubber, which appears in such contexts
as:
a. The blubber served them as fuel.
b. . . . extracting it from the blubber of the large ﬁsh ...
c. Amongst oily substances, blubber has been employed as a manure.
These contexts form the distributional properties of the word blubber, and they link it to
words which can appear in similar constructions: fat, pelts, and barnacles. This distribu-
tional perspective makes it possible to learn about meaning from unlabeled data alone;
unlike relational and compositional semantics, no manual annotation or expert knowl-
edge is required. Distributional semantics is thus capable of covering a huge range of
linguistic phenomena. However, it lacks precision: blubber is similar to fat in one sense, to
pelts in another sense, and to barnacles in still another. The question of why all these words
tend to appear in the same contexts is left unanswered.
The relational, compositional, and distributional perspectives all contribute to our un-
derstanding of linguistic meaning, and all three appear to be critical to natural language
processing. Yet they are uneasy collaborators, requiring seemingly incompatible represen-
tations and algorithmic approaches. This text presents some of the best known and most
successful methods for working with each of these representations, but future research
may reveal new ways to combine them.
Jacob Eisenstein. Draft of November , .

Part I
Learning
Chapter
Linear text classiﬁcation
We begin with the problem of text classiﬁcation: given a text document, assign it a dis-
crete label y ∈ Y, where Y is the set of possible labels. Text classiﬁcation has many ap-
plications, from spam ﬁltering to the analysis of electronic health records. This chapter
describes some of the most well known and effective algorithms for text classiﬁcation,
from a mathematical perspective that should help you understand what they do and why
they work. Text classiﬁcation is also a building block in more elaborate natural language
processing tasks. For readers without a background in machine learning or statistics, the
material in this chapter will take more time to digest than most of the subsequent chap-
ters. But this investment will pay off as the mathematical principles behind these basic
classiﬁcation algorithms reappear in other contexts throughout the book.
The bag of words
To perform text classiﬁcation, the ﬁrst question is how to represent each document, or
instance.
A common approach is to use a column vector of word counts, e.g., x =
[, , , , , , , , ,  . . .]⊤, where xj is the count of word j. The length of x is V ≜ |V|,
where V is the set of possible words in the vocabulary. In linear classiﬁcation, the classi-
ﬁcation decision is based on a weighted sum of individual feature counts, such as word
counts.
The object x is a vector, but it is often called a bag of words, because it includes only
information about the count of each word, and not the order in which the words appear.
With the bag of words representation, we are ignoring grammar, sentence boundaries,
paragraphs — everything but the words. Yet the bag of words model is surprisingly
effective for text classiﬁcation. If you see the word whale in a document, is it ﬁction or non-
ﬁction? What if you see the word molybdenum? For many labeling problems, individual
words can be strong predictors.
CHAPTER . LINEAR TEXT CLASSIFICATION
To predict a label from a bag-of-words, we can assign a score to each word in the vo-
cabulary, measuring the compatibility with the label. For example, for the label FICTION,
we might assign a positive score to the word whale, and a negative score to the word
molybdenum. These scores are called weights, and they are arranged in a column vector θ.
Suppose that you want a multiclass classiﬁer, where K ≜ |Y| > . For example, you
might want to classify news stories about sports, celebrities, music, and business. The goal
is to predict a label ˆy, given the bag of words x, using the weights θ. For each label y ∈ Y,
we compute a score Ψ(x, y), which is a scalar measure of the compatibility between the
bag-of-words x and the label y. In a linear bag-of-words classiﬁer, this score is the vector
inner product between the weights θ and the output of a feature function f(x, y),
θjfj(x, y).
Ψ(x, y) = θ  f(x, y) =
As the notation suggests, f is a function of two arguments, the word counts x and the
label y, and it returns a vector output. For example, given arguments x and y, element j
of this feature vector might be,
fj(x, y) =
xwhale,
if y = FICTION
otherwise
This function returns the count of the word whale if the label is FICTION, and it returns zero
otherwise. The index j depends on the position of whale in the vocabulary, and of FICTION
in the set of possible labels. The corresponding weight θj then scores the compatibility of
the word whale with the label FICTION. A positive score means that this word makes the
label more likely.
The output of the feature function can be formalized as a vector:
f(x, y = ) = [x; ; ; . . . ;
{z
(K−)×V
; x],
f(x, y = ) = [; ; . . . ;
{z
; x; ; ; . . . ;
{z
(K−)×V
f(x, y = K) = [; ; . . . ;
{z
(K−)×V
] is a column vector of (K − ) × V zeros, and the semicolon indicates
vertical concatenation. For each of the K possible labels, the feature function returns a
where [; ; . . . ;
{z
(K−)×V
In practice, both f and θ may be implemented as a dictionary rather than vectors, so that it is not
necessary to explicitly identify j. In such an implementation, the tuple (whale, FICTION) acts as a key in both
dictionaries; the values in f are feature counts, and the values in θ are weights.
Jacob Eisenstein. Draft of November , .

.. THE BAG OF WORDS
vector that is mostly zeros, with a column vector of word counts x inserted in a location
that depends on the speciﬁc label y. This arrangement is shown in Figure .. The notation
may seem awkward at ﬁrst, but it generalizes to an impressive range of learning settings,
particularly structure prediction, which is the focus of Chapters -.
Given a vector of weights, θ ∈ RV K, we can now compute the score Ψ(x, y) by Equa-
tion .. This inner product gives a scalar measure of the compatibility of the observation
x with label y. For any document x, we predict the label ˆy,
ˆy = argmax
y∈Y
Ψ(x, y)
Ψ(x, y) =θ  f(x, y).
This inner product notation gives a clean separation between the data (x and y) and the
parameters (θ).
While vector notation is used for presentation and analysis, in code the weights and
feature vector can be implemented as dictionaries. The inner product can then be com-
puted as a loop. In python:
def compute_score(x,y,weights):
total =
for feature,count in feature_function(x,y).items():
total += weights[feature] * count
return total
This representation is advantageous because it avoids storing and iterating over the many
features whose counts are zero.
It is common to add an offset feature at the end of the vector of word counts x, which
is always . We then have to also add an extra zero to each of the zero vectors, to make the
vector lengths match. This gives the entire feature vector f(x, y) a length of (V + ) × K.
The weight associated with this offset feature can be thought of as a bias for or against
each label. For example, if we expect most emails to be spam, then the weight for the
offset feature for y = SPAM should be larger than the weight for the offset feature for
y = NOT-SPAM.
Returning to the weights θ, where do they come from? One possibility is to set them
by hand. If we wanted to distinguish, say, English from Spanish, we can use English
and Spanish dictionaries, and set the weight to one for each word that appears in the
Only V × (K − ) features and weights are necessary. By stipulating that Ψ(x, y = K) =  regardless of
x, it is possible to implement any classiﬁcation rule that can be achieved with V × K features and weights.
This is the approach taken in binary classiﬁcation rules like y = Sign(βx+a), where β is a vector of weights,
a is an offset, and the label set is Y = {−, }. However, for multiclass classiﬁcation, it is more concise to
write θ  f(x, y) for all y ∈ Y.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Bag of words
Feature vector
Original text
aardvark
best
y=Fiction
it
y=News
of
the
It was the
best of times,
y=Gossip
times
was
it was the
worst of
times...
y=Sports
worst
zyxt
<OFFSET>
f(x ,y=News)
Figure .: The bag-of-words and feature vector representations, for a hypothetical text
classiﬁcation task.
associated dictionary. For example,
θ(E,bicycle) =
θ(S,bicycle) =
θ(E,bicicleta) =
θ(S,bicicleta) =
θ(E,con) =
θ(S,con) =
θ(E,ordinateur) =
θ(S,ordinateur) =.
Similarly, if we want to distinguish positive and negative sentiment, we could use posi-
tive and negative sentiment lexicons (see § ..), which are deﬁned by social psycholo-
gists (Tausczik and Pennebaker, ).
But it is usually not easy to set classiﬁcation weights by hand, due to the large number
of words and the difﬁculty of selecting exact numerical weights. Instead, we will learn the
weights from data. Email users manually label messages as SPAM; newspapers label their
own articles as BUSINESS or STYLE. Using such instance labels, we can automatically
acquire weights using supervised machine learning. This chapter will discuss several
machine learning approaches for classiﬁcation. The ﬁrst is based on probability. For a
review of probability, consult Appendix A.
In this notation, each tuple (language, word) indexes an element in θ, which remains a vector.
Jacob Eisenstein. Draft of November , .

.. NA¨IVE BAYES
Na¨ıve Bayes
The joint probability of a bag of words x and its true label y is written p(x, y). Suppose
we have a dataset of N labeled instances, {(x(i), y(i))}N
i=, which we assume are indepen-
dent and identically distributed (IID) (see § A.). Then the joint probability of the entire
dataset, written p(x(:N), y(:N)), is equal to QN
i= pX,Y (x(i), y(i)).
What does this have to do with classiﬁcation? One approach to classiﬁcation is to set
the weights θ so as to maximize the joint probability of a training set of labeled docu-
ments. This is known as maximum likelihood estimation:
ˆθ = argmax
p(x(:N), y(:N); θ)
= argmax
i=
p(x(i), y(i); θ)
= argmax
i=
log p(x(i), y(i); θ).
The notation p(x(i), y(i); θ) indicates that θ is a parameter of the probability function. The
product of probabilities can be replaced by a sum of log-probabilities because the log func-
tion is monotonically increasing over positive arguments, and so the same θ will maxi-
mize both the probability and its logarithm. Working with logarithms is desirable because
of numerical stability: on a large dataset, multiplying many probabilities can underﬂow
to zero.
The probability p(x(i), y(i); θ) is deﬁned through a generative model — an idealized
random process that has generated the observed data. Algorithm  describes the gener-
ative model underlying the Na¨ıve Bayes classiﬁer, with parameters θ = {µ, φ}.
The ﬁrst line of this generative model encodes the assumption that the instances are
mutually independent: neither the label nor the text of document i affects the label
or text of document j. Furthermore, the instances are identically distributed: the
The notation pX,Y (x(i), y(i)) indicates the joint probability that random variables X and Y take the
speciﬁc values x(i) and y(i) respectively. The subscript will often be omitted when it is clear from context.
For a review of random variables, see Appendix A.
Throughout this text, you may assume all logarithms and exponents are base , unless otherwise indi-
cated. Any reasonable base will yield an identical classiﬁer, and base  is most convenient for working out
examples by hand.
Generative models will be used throughout this text. They explicitly deﬁne the assumptions underlying
the form of a probability distribution over observed and latent variables. For a readable introduction to
generative models in statistics, see Blei ().
Can you think of any cases in which this assumption is too strong?
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Algorithm  Generative process for the Na¨ıve Bayes classiﬁcation model
for Instance i ∈ {, , . . . , N} do:
Draw the label y(i) ∼ Categorical(µ);
Draw the word counts x(i) | y(i) ∼ Multinomial(φy(i)).
distributions over the label y(i) and the text x(i) (conditioned on y(i)) are the same
for all instances i. In other words, we make the assumption that every document
has the same distribution over labels, and that each document’s distribution over
words depends only on the label, and not on anything else about the document. We
also assume that the documents don’t affect each other: if the word whale appears
in document i = , that does not make it any more or less likely that it will appear
again in document i = .
The second line of the generative model states that the random variable y(i) is drawn
from a categorical distribution with parameter µ. Categorical distributions are like
weighted dice: the column vector µ = [µ; µ; . . . ; µK] gives the probabilities of
each label, so that the probability of drawing label y is equal to µy. For example, if
Y = {POSITIVE, NEGATIVE, NEUTRAL}, we might have µ = [.; .; .]. We require
y∈Y µy =  and µy ≥ , ∀y ∈ Y: each label’s probability is non-negative, and the
sum of these probabilities is equal to one.
The third line describes how the bag-of-words counts x(i) are generated. By writing
x(i) | y(i), this line indicates that the word counts are conditioned on the label, so
that the joint probability is factored using the chain rule,
pX,Y (x(i), y(i)) = pX|Y (x(i) | y(i)) × pY (y(i)).
The speciﬁc distribution pX|Y is the multinomial, which is a probability distribu-
tion over vectors of non-negative counts. The probability mass function for this
distribution is:
pmult(x; φ) =B(x)
j=
φxj
VY
B(x) =
PV
j= xj

QV
j=(xj!)
Formally, we require µ ∈ ∆K−, where ∆K− is the K −  probability simplex, the set of all vectors of
K nonnegative numbers that sum to one. Because of the sum-to-one constraint, there are K −  degrees of
freedom for a vector of size K.
Jacob Eisenstein. Draft of November , .

.. NA¨IVE BAYES
As in the categorical distribution, the parameter φj can be interpreted as a probabil-
ity: speciﬁcally, the probability that any given token in the document is the word j.
The multinomial distribution involves a product over words, with each term in the
product equal to the probability φj, exponentiated by the count xj. Words that have
zero count play no role in this product, because φ
j = . The term B(x) is called the
multinomial coefﬁcient. It doesn’t depend on φ, and can usually be ignored. Can
you see why we need this term at all?
The notation p(x | y; φ) indicates the conditional probability of word counts x
given label y, with parameter φ, which is equal to pmult(x; φy). By specifying the
multinomial distribution, we describe the multinomial Na¨ıve Bayes classiﬁer. Why
“na¨ıve”? Because the multinomial distribution treats each word token indepen-
dently, conditioned on the class: the probability mass function factorizes across the
counts.
Types and tokens
A slight modiﬁcation to the generative model of Na¨ıve Bayes is shown in Algorithm .
Instead of generating a vector of counts of types, x, this model generates a sequence of
tokens, w = (w, w, . . . , wM). The distinction between types and tokens is critical: xj ∈
{, , , . . . , M} is the count of word type j in the vocabulary, e.g., the number of times
the word cannibal appears; wm ∈ V is the identity of token m in the document, e.g. wm =
cannibal.
The probability of the sequence w is a product of categorical probabilities. Algorithm
makes a conditional independence assumption: each token w(i)
m is independent of all other
tokens w(i)
n̸=m, conditioned on the label y(i). This is identical to the “na¨ıve” independence
assumption implied by the multinomial distribution, and as a result, the optimal parame-
ters for this model are identical to those in multinomial Na¨ıve Bayes. For any instance, the
probability assigned by this model is proportional to the probability under multinomial
Na¨ıve Bayes. The constant of proportionality is the multinomial coefﬁcient B(x). Because
B(x) ≥ , the probability for a vector of counts x is at least as large as the probability
for a list of words w that induces the same counts: there can be many word sequences
that correspond to a single vector of counts. For example, man bites dog and dog bites man
correspond to an identical count vector, {bites : , dog : , man : }, and B(x) is equal to
the total number of possible word orderings for count vector x.
Technically, a multinomial distribution requires a second parameter, the total number of word counts
in x. In the bag-of-words representation is equal to the number of words in the document. However, this
parameter is irrelevant for classiﬁcation.
You can plug in any probability distribution to the generative story and it will still be Na¨ıve Bayes, as
long as you are making the “na¨ıve” assumption that the features are conditionally independent, given the
label. For example, a multivariate Gaussian with diagonal covariance is na¨ıve in exactly the same sense.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Algorithm  Alternative generative process for the Na¨ıve Bayes classiﬁcation model
for Instance i ∈ {, , . . . , N} do:
Draw the label y(i) ∼ Categorical(µ);
for Token m ∈ {, , . . . , Mi} do:
Draw the token w(i)
m | y(i) ∼ Categorical(φy(i)).
Sometimes it is useful to think of instances as counts of types, x; other times, it is
better to think of them as sequences of tokens, w. If the tokens are generated from a
model that assumes conditional independence, then these two views lead to probability
models that are identical, except for a scaling factor that does not depend on the label or
the parameters.
Prediction
The Na¨ıve Bayes prediction rule is to choose the label y which maximizes log p(x, y; µ, φ):
ˆy = argmax
log p(x, y; µ, φ)
= argmax
log p(x | y; φ) + log p(y; µ)
Now we can plug in the probability distributions from the generative story.
log p(x | y; φ) + log p(y; µ) = log
j=
φxj
y,j
VY
 + log µy
B(x)
= log B(x) +
j=
xj log φy,j + log µy
= log B(x) + θ  f(x, y),
where
θ = [θ(); θ(); . . . ; θ(K)]
θ(y) = [log φy,; log φy,; . . . ; log φy,V ; log µy]
The feature function f(x, y) is a vector of V word counts and an offset, padded by
zeros for the labels not equal to y (see Equations .-., and Figure .). This construction
ensures that the inner product θ  f(x, y) only activates the features whose weights are
in θ(y). These features and weights are all we need to compute the joint log-probability
log p(x, y) for each y. This is a key point: through this notation, we have converted the
problem of computing the log-likelihood for a document-label pair (x, y) into the compu-
tation of a vector inner product.
Jacob Eisenstein. Draft of November , .

.. NA¨IVE BAYES
Estimation
The parameters of the categorical and multinomial distributions have a simple interpre-
tation: they are vectors of expected frequencies for each possible event. Based on this
interpretation, it is tempting to set the parameters empirically,
φy,j =
count(y, j)
PV
j′= count(y, j′)
i:y(i)=y x(i)
PV
j′=
i:y(i)=y x(i)
j′
where count(y, j) refers to the count of word j in documents with label y.
Equation . deﬁnes the relative frequency estimate for φ. It can be justiﬁed as a
maximum likelihood estimate: the estimate that maximizes the probability p(x(:N), y(:N); θ).
Based on the generative model in Algorithm , the log-likelihood is,
L(φ, µ) =
i=
log pmult(x(i); φy(i)) + log pcat(y(i); µ),
which is now written as a function L of the parameters φ and µ. Let’s continue to focus
on the parameters φ. Since p(y) is constant with respect to φ, we can drop it:
L(φ) =
i=
log pmult(x(i); φy(i)) =
i=
log B(x(i)) +
j=
x(i)
j log φy(i),j,
where B(x(i)) is constant with respect to φ.
Maximum-likelihood estimation chooses φ to maximize the log-likelihood L. How-
ever, the solution must obey the following constraints:
j=
φy,j =
∀y
These constraints can be incorporated by adding a set of Lagrange multipliers to the objec-
tive (see Appendix B for more details). To solve for each θy, we maximize the Lagrangian,
j=
x(i)
j log φy,j − λ(
j=
φy,j − ).
i:y(i)=y
ℓ(φy) =
Differentiating with respect to the parameter φy,j yields,
i:y(i)=y
x(i)
j /φy,j − λ.
∂ℓ(φy)
∂φy,j
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
The solution is obtained by setting each element in this vector of derivatives equal to zero,
i:y(i)=y
x(i)
λφy,j =
i:y(i)=y
x(i)
i=

y(i) = y

x(i)
= count(y, j),
φy,j ∝
where δ
y(i) = y
is a delta function, also sometimes called an indicator function, which
returns one if y(i) = y. The symbol ∝ indicates that φy,j is proportional to the right-hand
side of the equation.
Equation . shows three different notations for the same thing: a sum over the word
counts for all documents i such that the label y(i) = y. This gives a solution for each
φy up to a constant of proportionality. Now recall the constraint PV
j= φy,j = , which
arises because φy represents a vector of probabilities for each word in the vocabulary.
This constraint leads to an exact solution, which does not depend on λ:
φy,j =
count(y, j)
PV
j′= count(y, j′)
This is equal to the relative frequency estimator from Equation .. A similar derivation
gives µy ∝ PN
i= δ
y(i) = y
Smoothing
With text data, there are likely to be pairs of labels and words that never appear in the
training set, leaving φy,j = . For example, the word molybdenum may have never yet
appeared in a work of ﬁction. But choosing a value of φFICTION,molybdenum =  would allow
this single feature to completely veto a label, since p(FICTION | x) =  if xmolybdenum > .
This is undesirable, because it imposes high variance: depending on what data hap-
pens to be in the training set, we could get vastly different classiﬁcation rules. One so-
lution is to smooth the probabilities, by adding a “pseudocount” of α to each count, and
then normalizing.
φy,j =
α + count(y, j)
V α + PV
j′= count(y, j′)
This is called Laplace smoothing. The pseudocount α is a hyperparameter, because it
controls the form of the log-likelihood function, which in turn drives the estimation of φ.
Laplace smoothing has a Bayesian justiﬁcation, in which the generative model is extended to include φ
as a random variable. The resulting distribution over φ depends on both the data (x and y) and the prior
probability p(φ; α). The corresponding estimate of φ is called maximum a posteriori, or MAP. This is in
contrast with maximum likelihood, which depends only on the data.
Jacob Eisenstein. Draft of November , .

.. NA¨IVE BAYES
Smoothing reduces variance, but moves us away from the maximum likelihood esti-
mate: it imposes a bias. In this case, the bias points towards uniform probabilities. Ma-
chine learning theory shows that errors on heldout data can be attributed to the sum of
bias and variance (Mohri et al., ). In general, techniques for reducing variance often
increase the bias, leading to a bias-variance tradeoff.
Unbiased classiﬁers may overﬁt the training data, yielding poor performance on
unseen data.
But if the smoothing is too large, the resulting classiﬁer can underﬁt instead. In the
limit of α → ∞, there is zero variance: you get the same classiﬁer, regardless of the
data. However, the bias is likely to be large.
Similar issues arise throughout machine learning. Later in this chapter we will encounter
regularization, which controls the bias-variance tradeoff for logistic regression and large-
margin classiﬁers (§ ..); § .. describes techniques for controlling variance in deep
learning; chapter  describes more elaborate methods for smoothing empirical probabili-
ties.
Setting hyperparameters
Returning to Na¨ıve Bayes, how should we choose the best value of hyperparameters like
α? Maximum likelihood will not work: the maximum likelihood estimate of α on the
training set will always be α = . In many cases, what we really want is accuracy: the
number of correct predictions, divided by the total number of predictions. (Other mea-
sures of classiﬁcation performance are discussed in § ..) As we will see, it is hard to opti-
mize for accuracy directly. But for scalar hyperparameters like α, tuning can be performed
by a simple heuristic called grid search: try a set of values (e.g., α ∈ {., ., ., , }),
compute the accuracy for each value, and choose the setting that maximizes the accuracy.
The goal is to tune α so that the classiﬁer performs well on unseen data. For this reason,
the data used for hyperparameter tuning should not overlap the training set, where very
small values of α will be preferred. Instead, we hold out a development set (also called
a tuning set) for hyperparameter selection. This development set may consist of a small
fraction of the labeled data, such as %.
We also want to predict the performance of our classiﬁer on unseen data. To do this,
we must hold out a separate subset of data, called the test set. It is critical that the test set
not overlap with either the training or development sets, or else we will overestimate the
performance that the classiﬁer will achieve on unlabeled data in the future. The test set
should also not be used when making modeling decisions, such as the form of the feature
function, the size of the vocabulary, and so on (these decisions are reviewed in chapter .)
The ideal practice is to use the test set only once — otherwise, the test set is used to guide
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
the classiﬁer design, and test set accuracy will diverge from accuracy on truly unseen
data. Because annotated data is expensive, this ideal can be hard to follow in practice,
and many test sets have been used for decades. But in some high-impact applications like
machine translation and information extraction, new test sets are released every year.
When only a small amount of labeled data is available, the test set accuracy can be
unreliable. K-fold cross-validation is one way to cope with this scenario: the labeled
data is divided into K folds, and each fold acts as the test set, while training on the other
folds. The test set accuracies are then aggregated. In the extreme, each fold is a single data
point; this is called leave-one-out cross-validation. To perform hyperparameter tuning
in the context of cross-validation, another fold can be used for grid search. It is important
not to repeatedly evaluate the cross-validated accuracy while making design decisions
about the classiﬁer, or you will overstate the accuracy on truly unseen data.
Discriminative learning
Na¨ıve Bayes is easy to work with: the weights can be estimated in closed form, and the
probabilistic interpretation makes it relatively easy to extend. However, the assumption
that features are independent can seriously limit its accuracy. Thus far, we have deﬁned
the feature function f(x, y) so that it corresponds to bag-of-words features: one feature
per word in the vocabulary. In natural language, bag-of-words features violate the as-
sumption of conditional independence — for example, the probability that a document
will contain the word na¨ıve is surely higher given that it also contains the word Bayes —
but this violation is relatively mild.
However, good performance on text classiﬁcation often requires features that are richer
than the bag-of-words:
To better handle out-of-vocabulary terms, we want features that apply to multiple
words, such as preﬁxes and sufﬁxes (e.g., anti-, un-, -ing) and capitalization.
We also want n-gram features that apply to multi-word units: bigrams (e.g., not
good, not bad), trigrams (e.g., not so bad, lacking any decency, never before imagined), and
beyond.
These features ﬂagrantly violate the Na¨ıve Bayes independence assumption. Consider
what happens if we add a preﬁx feature. Under the Na¨ıve Bayes assumption, the joint
probability of a word and its preﬁx are computed with the following approximation:
Pr(word = unﬁt, preﬁx = un- | y) ≈ Pr(preﬁx = un- | y) × Pr(word = unﬁt | y).
The notation Pr() refers to the probability of an event, and p() refers to the probability density or mass
for a random variable (see Appendix A).
Jacob Eisenstein. Draft of November , .

.. DISCRIMINATIVE LEARNING
To test the quality of the approximation, we can manipulate the left-hand side by applying
the chain rule,
Pr(word = unﬁt, preﬁx = un- | y) = Pr(preﬁx = un- | word = unﬁt, y)
× Pr(word = unﬁt | y)
But Pr(preﬁx = un- | word = unﬁt, y) = , since un- is guaranteed to be the preﬁx for the
word unﬁt. Therefore,
Pr(word = unﬁt, preﬁx = un- | y) =
× Pr(word = unﬁt | y) [.]
≫ Pr(preﬁx = un- | y)
× Pr(word = unﬁt | y), [.]
because the probability of any given word starting with the preﬁx un- is much less than
one. Na¨ıve Bayes will systematically underestimate the true probabilities of conjunctions
of positively correlated features. To use such features, we need learning algorithms that
do not rely on an independence assumption.
The origin of the Na¨ıve Bayes independence assumption is the learning objective,
p(x(:N), y(:N)), which requires modeling the probability of the observed text. In clas-
siﬁcation problems, we are always given x, and are only interested in predicting the label
y. In this setting, modeling the probability of the text x seems like a difﬁcult and unnec-
essary task. Discriminative learning algorithms avoid this task, and focus directly on the
problem of predicting y.
Perceptron
In Na¨ıve Bayes, the weights can be interpreted as parameters of a probabilistic model. But
this model requires an independence assumption that usually does not hold, and limits
our choice of features. Why not forget about probability and learn the weights in an error-
driven way? The perceptron algorithm, shown in Algorithm , is one way to do this.
The algorithm is simple: if you make a mistake, increase the weights for features that
are active with the correct label y(i), and decrease the weights for features that are active
with the guessed label ˆy. Perceptron is an online learning algorithm, since the classiﬁer
weights change after every example. This is different from Na¨ıve Bayes, which is a batch
learning algorithm: it computes statistics over the entire dataset, and then sets the weights
in a single operation. Algorithm  is vague about when this online learning procedure
terminates. We will return to this issue shortly.
The perceptron algorithm may seem like an unprincipled heuristic: Na¨ıve Bayes has a
solid foundation in probability, but the perceptron is just adding and subtracting constants
from the weights every time there is a mistake. Will this really work? In fact, there is some
nice theory for the perceptron, based on the concept of linear separability. Informally,
a dataset with binary labels (y ∈ {, }) is linearly separable if it is possible to draw a
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Algorithm  Perceptron learning algorithm
: procedure PERCEPTRON(x(:N), y(:N))
t ←
θ() ←
repeat
t ← t +
Select an instance i
ˆy ← argmaxy θ(t−)  f(x(i), y)
if ˆy ̸= y(i) then
θ(t) ← θ(t−) + f(x(i), y(i)) − f(x(i), ˆy)
else
θ(t) ← θ(t−)
until tired
return θ(t)
hyperplane (a line in many dimensions), such that on each side of the hyperplane, all
instances have the same label. This deﬁnition can be formalized and extended to multiple
labels:
Deﬁnition  (Linear separability). The dataset D = {(x(i), y(i))}N
i= is linearly separable iff
(if and only if) there exists some weight vector θ and some margin ρ such that for every instance
(x(i), y(i)), the inner product of θ and the feature function for the true label, θ  f(x(i), y(i)), is
at least ρ greater than inner product of θ and the feature function for every other possible label,
θ  f(x(i), y′).
∃θ, ρ >  : ∀(x(i), y(i)) ∈ D,
θ  f(x(i), y(i)) ≥ ρ + max
y′̸=y(i) θ  f(x(i), y′).
Linear separability is important because of the following guarantee: if your data is
linearly separable, then the perceptron algorithm will ﬁnd a separator (Novikoff, ).
So while the perceptron may seem heuristic, it is guaranteed to succeed, if the learning
problem is easy enough.
How useful is this proof? Minsky and Papert () famously proved that the simple
logical function of exclusive-or is not separable, and that a perceptron is therefore inca-
pable of learning this function. But this is not just an issue for the perceptron: any linear
classiﬁcation algorithm, including Na¨ıve Bayes, will fail on this task. Text classiﬁcation
problems usually involve high dimensional feature spaces, with thousands or millions of
It is also possible to prove an upper bound on the number of training iterations required to ﬁnd the
separator. Proofs like this are part of the ﬁeld of machine learning theory (Mohri et al., ).
Jacob Eisenstein. Draft of November , .

.. LOSS FUNCTIONS AND LARGE-MARGIN CLASSIFICATION
features. For these problems, it is very likely that the training data is indeed separable.
And even if the dataset is not separable, it is still possible to place an upper bound on the
number of errors that the perceptron algorithm will make (Freund and Schapire, ).
Averaged perceptron
The perceptron iterates over the data repeatedly — until “tired”, as described in Algo-
rithm . If the data is linearly separable, the perceptron will eventually ﬁnd a separator,
and we can stop once all training instances are classiﬁed correctly. But if the data is not
linearly separable, the perceptron can thrash between two or more weight settings, never
converging. In this case, how do we know that we can stop training, and how should
we choose the ﬁnal weights? An effective practical solution is to average the perceptron
weights across all iterations.
This procedure is shown in Algorithm . The learning algorithm is nearly identical,
but we also maintain a vector of the sum of the weights, m. At the end of the learning
procedure, we divide this sum by the total number of updates t, to compute the average
weights, θ. These average weights are then used for prediction. In the algorithm sketch,
the average is computed from a running sum, m ← m + θ. However, this is inefﬁcient,
because it requires |θ| operations to update the running sum. When f(x, y) is sparse,
|θ| ≫ |f(x, y)| for any individual (x, y). This means that computing the running sum will
be much more expensive than computing of the update to θ itself, which requires only
× |f(x, y)| operations. One of the exercises is to sketch a more efﬁcient algorithm for
computing the averaged weights.
Even if the dataset is not separable, the averaged weights will eventually converge.
One possible stopping criterion is to check the difference between the average weight
vectors after each pass through the data: if the norm of the difference falls below some
predeﬁned threshold, we can stop training. Another stopping criterion is to hold out some
data, and to measure the predictive accuracy on this heldout data. When the accuracy
on the heldout data starts to decrease, the learning algorithm has begun to overﬁt the
training set. At this point, it is probably best to stop; this stopping criterion is known as
early stopping.
Generalization is the ability to make good predictions on instances that are not in
the training data. Averaging can be proven to improve generalization, by computing an
upper bound on the generalization error (Freund and Schapire, ; Collins, ).
Loss functions and large-margin classiﬁcation
Na¨ıve Bayes chooses the weights θ by maximizing the joint log-likelihood log p(x(:N), y(:N)).
By convention, optimization problems are generally formulated as minimization of a loss
function. The input to a loss function is the vector of weights θ, and the output is a
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Algorithm  Averaged perceptron learning algorithm
: procedure AVG-PERCEPTRON(x(:N), y(:N))
t ←
θ() ←
repeat
t ← t +
Select an instance i
ˆy ← argmaxy θ(t−)  f(x(i), y)
if ˆy ̸= y(i) then
θ(t) ← θ(t−) + f(x(i), y(i)) − f(x(i), ˆy)
else
θ(t) ← θ(t−)
m ← m + θ(t)
until tired
t m
θ ←
return θ
non-negative number, measuring the performance of the classiﬁer on a training instance.
Formally, the loss ℓ(θ; x(i), y(i)) is then a measure of the performance of the weights θ on
the instance (x(i), y(i)). The goal of learning is to minimize the sum of the losses across all
instances in the training set.
We can trivially reformulate maximum likelihood as a loss function, by deﬁning the
loss function to be the negative log-likelihood:
log p(x(:N), y(:N); θ) =
i=
log p(x(i), y(i); θ)
ℓNB(θ; x(i), y(i)) = − log p(x(i), y(i); θ)
ˆθ = argmin
i=
ℓNB(θ; x(i), y(i))
= argmax
i=
log p(x(i), y(i); θ).
The problem of minimizing ℓNB is thus identical to maximum-likelihood estimation.
Loss functions provide a general framework for comparing learning objectives. For
example, an alternative loss function is the zero-one loss,
ℓ-(θ; x(i), y(i)) =
y(i) = argmaxy θ  f(x(i), y)
otherwise
Jacob Eisenstein. Draft of November , .

.. LOSS FUNCTIONS AND LARGE-MARGIN CLASSIFICATION
The zero-one loss is zero if the instance is correctly classiﬁed, and one otherwise. The
sum of zero-one losses is proportional to the error rate of the classiﬁer on the training
data. Since a low error rate is often the ultimate goal of classiﬁcation, this may seem
ideal. But the zero-one loss has several problems. One is that it is non-convex, which
means that there is no guarantee that gradient-based optimization will be effective. A
more serious problem is that the derivatives are useless: the partial derivative with respect
to any parameter is zero everywhere, except at the points where θf(x(i), y) = θf(x(i), ˆy)
for some ˆy. At those points, the loss is discontinuous, and the derivative is undeﬁned.
The perceptron optimizes a loss function that has better properties for learning:
ℓPERCEPTRON(θ; x(i), y(i)) = max
y∈Y θ  f(x(i), y) − θ  f(x(i), y(i)),
When ˆy = y(i), the loss is zero; otherwise, it increases linearly with the gap between the
score for the predicted label ˆy and the score for the true label y(i). Plotting this loss against
the input maxy∈Y θ  f(x(i), y) − θ  f(x(i), y(i)) gives a hinge shape, motivating the name
hinge loss.
To see why this is the loss function optimized by the perceptron, take the derivative
with respect to θ,
∂θℓPERCEPTRON(θ; x(i), y(i)) = f(x(i), ˆy) − f(x(i), y(i)).
At each instance, the perceptron algorithm takes a step of magnitude one in the opposite
direction of this gradient, ∇θℓPERCEPTRON =
∂θℓPERCEPTRON(θ; x(i), y(i)). As we will see in
§ ., this is an example of the optimization algorithm stochastic gradient descent, applied
to the objective in Equation ..
*Breaking ties with subgradient descent
Careful readers will notice the tacit assump-
tion that there is a unique ˆy that maximizes θ  f(x(i), y). What if there are two or more
labels that maximize this function? Consider binary classiﬁcation: if the maximizer is y(i),
then the gradient is zero, and so is the perceptron update; if the maximizer is ˆy ̸= y(i),
then the update is the difference f(x(i), y(i)) − f(x(i), ˆy). The underlying issue is that the
perceptron loss is not smooth, because the ﬁrst derivative has a discontinuity at the hinge
point, where the score for the true label y(i) is equal to the score for some other label ˆy. At
this point, there is no unique gradient; rather, there is a set of subgradients. A vector v is
A function f is convex iff αf(xi)+(−α)f(xj) ≥ f(αxi+(−α)xj), for all α ∈ [, ] and for all xi and xj
on the domain of the function. In words, any weighted average of the output of f applied to any two points is
larger than the output of f when applied to the weighted average of the same two points. Convexity implies
that any local minimum is also a global minimum, and there are many effective techniques for optimizing
convex functions (Boyd and Vandenberghe, ). See Appendix B for a brief review.
Throughout this text, advanced topics will be marked with an asterisk.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
a subgradient of the function g at u iff g(u) − g(u) ≥ v  (u − u) for all u. Graphically,
this deﬁnes the set of hyperplanes that include g(u) and do not intersect g at any other
point. As we approach the hinge point from the left, the gradient is f(x, ˆy)−f(x, y); as we
approach from the right, the gradient is . At the hinge point, the subgradients include all
vectors that are bounded by these two extremes. In subgradient descent, any subgradient
can be used (Bertsekas, ). Since both  and f(x, ˆy) − f(x, y) are subgradients at the
hinge point, either one can be used in the perceptron update. This means that if multiple
labels maximize θ  f(x(i), y), any of them can be used in the perceptron update.
Perceptron versus Na¨ıve Bayes
The perceptron loss function has some pros and cons
with respect to the negative log-likelihood loss implied by Na¨ıve Bayes.
Both ℓNB and ℓPERCEPTRON are convex, making them relatively easy to optimize. How-
ever, ℓNB can be optimized in closed form, while ℓPERCEPTRON requires iterating over
the dataset multiple times.
ℓNB can suffer inﬁnite loss on a single example, since the logarithm of zero probability
is negative inﬁnity. Na¨ıve Bayes will therefore overemphasize some examples, and
underemphasize others.
The Na¨ıve Bayes classiﬁer assumes that the observed features are conditionally in-
dependent, given the label, and the performance of the classiﬁer depends on the
extent to which this assumption holds. The perceptron requires no such assump-
tion.
ℓPERCEPTRON treats all correct answers equally. Even if θ only gives the correct answer
by a tiny margin, the loss is still zero.
Online large margin classiﬁcation
This last comment suggests a potential problem with the perceptron. Suppose a test ex-
ample is very close to a training example, but not identical. If the classiﬁer only gets the
correct answer on the training example by a small amount, then it may give a different
answer on the nearby test instance. To formalize this intuition, deﬁne the margin as,
γ(θ; x(i), y(i)) = θ  f(x(i), y(i)) − max
y̸=y(i) θ  f(x(i), y).
The margin represents the difference between the score for the correct label y(i), and
the score for the highest-scoring incorrect label. The intuition behind large margin clas-
siﬁcation is that it is not enough to label the training data correctly — the correct label
should be separated from other labels by a comfortable margin. This idea can be encoded
Jacob Eisenstein. Draft of November , .

.. LOSS FUNCTIONS AND LARGE-MARGIN CLASSIFICATION
/ loss
margin loss
logistic loss
loss
θ  f(x(i), y(i)) − θ  f(x(i), ˆy)
Figure .: Margin, zero-one, and logistic loss functions.
into a loss function,
ℓMARGIN(θ; x(i), y(i)) =
γ(θ; x(i), y(i)) ≥ ,
− γ(θ; x(i), y(i)),
otherwise
+ ,

− γ(θ; x(i), y(i))

where (x)+ = max(, x). The loss is zero if there is a margin of at least  between the
score for the true label and the best-scoring alternative ˆy. This is almost identical to the
perceptron loss, but the hinge point is shifted to the right, as shown in Figure .. The
margin loss is a convex upper bound on the zero-one loss.
The margin loss can be minimized using an online learning rule that is similar to per-
ceptron. We will call this learning rule the online support vector machine, for reasons
that will be discussed in the derivation. Let us ﬁrst generalize the notion of a classiﬁca-
tion error with a cost function c(y(i), y). We will focus on the simple cost function,
c(y(i), y) =
y(i) ̸= ˆy
otherwise,
but it is possible to design specialized cost functions that assign heavier penalties to espe-
cially undesirable errors (Tsochantaridis et al., ). This idea is revisited in chapter .
Using the cost function, we can now deﬁne the online support vector machine as the
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
following classiﬁcation rule:
ˆy = argmax
y∈Y
θ  f(x(i), y) + c(y(i), y)
θ(t) ←( − λ)θ(t−) + f(x(i), y(i)) − f(x(i), ˆy)
This update is similar in form to the perceptron, with two key differences.
Rather than selecting the label ˆy that maximizes the score of the current classiﬁ-
cation model, the argmax searches for labels that are both strong, as measured by
θ  f(x(i), y), and wrong, as measured by c(y(i), y). This maximization is known as
cost-augmented decoding, because it augments the maximization objective to favor
high-cost labels. If the highest-scoring label is y = y(i), then the margin loss for
this instance is zero, and no update is needed. If not, then an update is required to
reduce the margin loss — even if the current model classiﬁes the instance correctly.
Cost augmentation is only done while learning; it is not applied when making pre-
dictions on unseen data.
The previous weights θ(t−) are scaled by ( − λ), with λ ∈ (, ). The effect of this
term is to cause the weights to “decay” back towards zero. In the support vector
machine, this term arises from the minimization of a speciﬁc form of the margin, as
described below. However, it can also be viewed as a form of regularization, which
can help to prevent overﬁtting (see § ..). In this sense, it plays a role that is similar
to smoothing in Na¨ıve Bayes (see § ..).
*Derivation of the online support vector machine
The derivation of the online support vector machine is somewhat involved, but gives
further intuition about why the method works. Begin by returning the idea of linear sep-
arability (Deﬁnition ): if a dataset is linearly separable, then there is some hyperplane θ
that correctly classiﬁes all training instances with margin ρ. This margin can be increased
to any desired value by multiplying the weights by a constant.
Now, for any datapoint (x(i), y(i)), the geometric distance to the separating hyper-
plane is given by γ(θ;x(i),y(i))
||θ||
, where the denominator is the norm of the weights, ||θ|| =
qP
j θ
j. The geometric distance is sometimes called the geometric margin, in contrast to
the functional margin γ(θ; x(i), y(i)). Both are shown in Figure .. The geometric margin
is a good measure of the robustness of the separator: if the functional margin is large, but
the norm ||θ|| is also large, then a small change in x(i) could cause it to be misclassiﬁed.
We therefore seek to maximize the minimum geometric margin across the dataset, subject
Jacob Eisenstein. Draft of November , .

.. LOSS FUNCTIONS AND LARGE-MARGIN CLASSIFICATION
geometric
margin
functional
margin
Figure .: Functional and geometric margins for a binary classiﬁcation problem. All
separators that satisfy the margin constraint are shown. The separator with the largest
geometric margin is shown in bold.
to the constraint that the margin loss is always zero:
max
min
i=,,...N
γ(θ; x(i), y(i))
||θ||
s.t.
γ(θ; x(i), y(i)) ≥ ,
∀i.
This is a constrained optimization problem, where the second line describes constraints
on the space of possible solutions θ. In this case, the constraint is that the functional
margin always be at least one, and the objective is that the minimum geometric margin
be as large as possible.
Constrained optimization is reviewed in Appendix B. In this case, further manipula-
tion yields an unconstrained optimization problem. First, note that the norm ||θ|| scales
linearly: ||aθ|| = a||θ||. Furthermore, the functional margin γ is a linear function of θ,
so that γ(aθ, x(i), y(i)) = aγ(θ, x(i), y(i)). As a result, any scaling factor on θ will cancel in
the numerator and denominator of the geometric margin. If the data is linearly separable
at any ρ > , it is always possible to rescale the functional margin to  by multiplying θ
by a scalar constant. We therefore need only minimize the denominator ||θ||, subject to
the constraint on the functional margin. The minimizer of ||θ|| is also the minimizer of
||θ||
P θ
j, which is easier to work with. This yields a simpler optimization prob-
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
lem:
min
θ .
||θ||
s.t.
γ(θ; x(i), y(i)) ≥ ,
∀i.
This problem is a quadratic program: the objective is a quadratic function of the pa-
rameters, and the constraints are all linear inequalities. One solution to this problem is
to incorporate the constraints through Lagrange multipliers αi ≥ , i = , , . . . , N. The
instances for which αi >  are called support vectors; other instances are irrelevant to the
classiﬁcation boundary. This motivates the name support vector machine.
Thus far we have assumed linear separability, but many datasets of interest are not
linearly separable. In this case, there is no θ that satisﬁes the margin constraint. To add
more ﬂexibility, we can introduce a set of slack variables ξi ≥ . Instead of requiring that
the functional margin be greater than or equal to one, we require that it be greater than or
equal to  − ξi. Ideally there would not be any slack, so the slack variables are penalized
in the objective function:
min
θ,ξ
||θ||
+ C
i=
ξi
s.t.
γ(θ; x(i), y(i)) + ξi ≥ ,
∀i
ξi ≥ ,
∀i.
The hyperparameter C controls the tradeoff between violations of the margin con-
straint and the preference for a low norm of θ. As C → ∞, slack is inﬁnitely expensive,
and there is only a solution if the data is separable. As C → , slack becomes free, and
there is a trivial solution at θ = . Thus, C plays a similar role to the smoothing parame-
ter in Na¨ıve Bayes (§ ..), trading off between a close ﬁt to the training data and better
generalization. Like the smoothing parameter of Na¨ıve Bayes, C must be set by the user,
typically by maximizing performance on a heldout development set.
To solve the constrained optimization problem deﬁned in Equation ., we can ﬁrst
solve for the slack variables,
ξi ≥ ( − γ(θ; x(i), y(i)))+.
The inequality is tight: the optimal solution is to make the slack variables as small as
possible, while still satisfying the constraints (Ratliff et al., ; Smith, ). By plugging
in the minimum slack variables back into Equation ., the problem can be transformed
into the unconstrained optimization,
i=
( − γ(θ; x(i), y(i)))+,
min
||θ||
Jacob Eisenstein. Draft of November , .

.. LOGISTIC REGRESSION
where each ξi has been substituted by the right-hand side of Equation ., and the factor
of C on the slack variables has been replaced by an equivalent factor of λ =
C on the
norm of the weights.
Equation . can be rewritten by expanding the margin,
i=
max
y∈Y
min
||θ||

θ  f(x(i), y) + c(y(i), y)

− θ  f(x(i), y(i))

where c(y, y(i)) is the cost function deﬁned in Equation .. We can now differentiate
with respect to the weights,
∇θLSVM =λθ +
i=
f(x(i), ˆy) − f(x(i), y(i)),
where LSVM refers to minimization objective in Equation . and ˆy = argmaxy∈Y θ
f(x(i), y) + c(y(i), y). The online support vector machine update arises from the appli-
cation of stochastic gradient descent (described in § ..) to this gradient.
Logistic regression
Thus far, we have seen two broad classes of learning algorithms. Na¨ıve Bayes is a prob-
abilistic method, where learning is equivalent to estimating a joint probability distribu-
tion. The perceptron and support vector machine are discriminative, error-driven algo-
rithms: the learning objective is closely related to the number of errors on the training
data. Probabilistic and error-driven approaches each have advantages: probability makes
it possible to quantify uncertainty about the predicted labels, but the probability model of
Na¨ıve Bayes makes unrealistic independence assumptions that limit the features that can
be used.
Logistic regression combines advantages of discriminative and probabilistic classi-
ﬁers. Unlike Na¨ıve Bayes, which starts from the joint probability pX,Y , logistic regression
deﬁnes the desired conditional probability pY |X directly. Think of θ  f(x, y) as a scoring
function for the compatibility of the base features x and the label y. To convert this score
into a probability, we ﬁrst exponentiate, obtaining exp (θ  f(x, y)), which is guaranteed
to be non-negative. Next, we normalize, dividing over all possible labels y′ ∈ Y. The
resulting conditional probability is deﬁned as,
p(y | x; θ) =
exp (θ  f(x, y))
y′∈Y exp (θ  f(x, y′)).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Given a dataset D = {(x(i), y(i))}N
i=, the weights θ are estimated by maximum condi-
tional likelihood,
log p(y(:N) | x(:N); θ) =
i=
log p(y(i) | x(i); θ)
y′∈Y
exp

θ  f(x(i), y′)

i=
θ  f(x(i), y(i)) − log
The ﬁnal line is obtained by plugging in Equation . and taking the logarithm. Inside
the sum, we have the (additive inverse of the) logistic loss,
y′∈Y
exp(θ  f(x(i), y′))
ℓLOGREG(θ; x(i), y(i)) = −θ  f(x(i), y(i)) + log
The logistic loss is shown in Figure . on page . A key difference from the zero-one
and hinge losses is that logistic loss is never zero. This means that the objective function
can always be improved by assigning higher conﬁdence to the correct label.
Regularization
As with the support vector machine, better generalization can be obtained by penalizing
the norm of θ. This is done by adding a multiple of the squared norm λ
||θ||
to the
minimization objective. This is called L regularization, because ||θ||
is the squared L
norm of the vector θ. Regularization forces the estimator to trade off performance on the
training data against the norm of the weights, and this can help to prevent overﬁtting.
Consider what would happen to the unregularized weight for a base feature j that is
active in only one instance x(i): the conditional log-likelihood could always be improved
by increasing the weight for this feature, so that θ(j,y(i)) → ∞ and θ(j,˜y̸=y(i)) → −∞, where
(j, y) is the index of feature associated with x(i)
and label y in f(x(i), y).
In § .. (footnote ), we saw that smoothing the probabilities of a Na¨ıve Bayes clas-
siﬁer can be justiﬁed as a form of maximum a posteriori estimation, in which the param-
eters of the classiﬁer are themselves random variables, drawn from a prior distribution.
The same justiﬁcation applies to L regularization. In this case, the prior is a zero-mean
Gaussian on each term of θ. The log-likelihood under a zero-mean Gaussian is,
σ θ
j,
log N(θj; , σ) ∝ −
so that the regularization weight λ is equal to the inverse variance of the prior, λ =
σ .
The log-sum-exp term is a common pattern in machine learning. It is numerically unstable, because it
will underﬂow if the inner product is small, and overﬂow if the inner product is large. Scientiﬁc computing
libraries usually contain special functions for computing logsumexp, but with some thought, you should be
able to see how to create an implementation that is numerically stable.
Jacob Eisenstein. Draft of November , .

.. OPTIMIZATION
Gradients
Logistic loss is minimized by optimization along the gradient. Speciﬁc algorithms are de-
scribed in the next section, but ﬁrst let’s compute the gradient with respect to the logistic
loss of a single example:
y′∈Y
exp

θ  f(x(i), y′)

ℓLOGREG = − θ  f(x(i), y(i)) + log
y′∈Y
exp

θ  f(x(i), y′)

× f(x(i), y′)
y′′∈Y exp
θ  f(x(i), y′′)
 ×
∂ℓ
∂θ = − f(x(i), y(i)) +
exp
θ  f(x(i), y′)
y′∈Y
= − f(x(i), y(i)) +
y′′∈Y exp
θ  f(x(i), y′′)
 × f(x(i), y′)
y′∈Y
p(y′ | x(i); θ) × f(x(i), y′)
= − f(x(i), y(i)) +
= − f(x(i), y(i)) + EY |X[f(x(i), y)].
The ﬁnal step employs the deﬁnition of a conditional expectation (§ A.). The gradient of
the logistic loss is equal to the difference between the expected counts under the current
model, EY |X[f(x(i), y)], and the observed feature counts f(x(i), y(i)). When these two
vectors are equal for a single instance, there is nothing more to learn from it; when they
are equal in sum over the entire dataset, there is nothing more to learn from the dataset as
a whole. The gradient of the hinge loss is nearly identical, but it involves the features of
the predicted label under the current model, f(x(i), ˆy), rather than the expected features
EY |X[f(x(i), y)] under the conditional distribution p(y | x; θ).
The regularizer contributes λθ to the overall gradient:
LLOGREG =λ
i=
||θ||
y′∈Y
exp θ  f(x(i), y′)
θ  f(x(i), y(i)) − log
∇θLLOGREG =λθ −
i=
f(x(i), y(i)) − Ey|x[f(x(i), y)]

Optimization
Each of the classiﬁcation algorithms in this chapter can be viewed as an optimization
problem:
In Na¨ıve Bayes, the objective is the joint likelihood log p(x(:N), y(:N)). Maximum
likelihood estimation yields a closed-form solution for θ.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
In the support vector machine, the objective is the regularized margin loss,
LSVM = λ
i=
(max
y∈Y (θ  f(x(i), y) + c(y(i), y)) − θ  f(x(i), y(i)))+,
||θ||
There is no closed-form solution, but the objective is convex. The perceptron algo-
rithm minimizes a similar objective.
In logistic regression, the objective is the regularized negative log-likelihood,
LLOGREG = λ
i=
||θ||
y∈Y
exp

θ  f(x(i), y)

θ  f(x(i), y(i)) − log
Again, there is no closed-form solution, but the objective is convex.
These learning algorithms are distinguished by what is being optimized, rather than
how the optimal weights are found. This decomposition is an essential feature of con-
temporary machine learning. The domain expert’s job is to design an objective function
— or more generally, a model of the problem. If the model has certain characteristics,
then generic optimization algorithms can be used to ﬁnd the solution. In particular, if an
objective function is differentiable, then gradient-based optimization can be employed;
if it is also convex, then gradient-based optimization is guaranteed to ﬁnd the globally
optimal solution. The support vector machine and logistic regression have both of these
properties, and so are amenable to generic convex optimization techniques (Boyd and
Vandenberghe, ).
Batch optimization
In batch optimization, each update to the weights is based on a computation involving
the entire dataset. One such algorithm is gradient descent, which iteratively updates the
weights,
θ(t+) ← θ(t) − η(t)∇θL,
where ∇θL is the gradient computed over the entire training set, and η(t) is the learning
rate at iteration t. If the objective L is a convex function of θ, then this procedure is
guaranteed to terminate at the global optimum, for appropriate schedule of learning rates,
η(t).
Convergence
proofs
typically
require
the
learning
rate
to
satisfy
the
following
conditions:
P∞
t= η(t) = ∞ and P∞
t=(η(t)) < ∞ (Bottou et al., ). These properties are satisﬁed by any learning
rate schedule η(t) = η()t−α for α ∈ [, ].
Jacob Eisenstein. Draft of November , .

.. OPTIMIZATION
In practice, gradient descent can be slow to converge, as the gradient can become
inﬁnitesimally small. Faster convergence can be obtained by second-order Newton opti-
mization, which incorporates the inverse of the Hessian matrix,
Hi,j =
∂L
∂θi∂θj
The size of the Hessian matrix is quadratic in the number of features. In the bag-of-words
representation, this is usually too big to store, let alone invert. Quasi-Network optimiza-
tion techniques maintain a low-rank approximation to the inverse of the Hessian matrix.
Such techniques usually converge more quickly than gradient descent, while remaining
computationally tractable even for large feature sets. A popular quasi-Newton algorithm
is L-BFGS (Liu and Nocedal, ), which is implemented in many scientiﬁc computing
environments, such as SCIPY and MATLAB.
For any gradient-based technique, the user must set the learning rates η(t). While con-
vergence proofs usually employ a decreasing learning rate, in practice, it is common to ﬁx
η(t) to a small constant, like −. The speciﬁc constant can be chosen by experimentation,
although there is research on determining the learning rate automatically (Schaul et al.,
; Wu et al., ).
Online optimization
Batch optimization computes the objective on the entire training set before making an up-
date. This may be inefﬁcient, because at early stages of training, a small number of train-
ing examples could point the learner in the correct direction. Online learning algorithms
make updates to the weights while iterating through the training data. The theoretical
basis for this approach is a stochastic approximation to the true objective function,
i=
ℓ(θ; x(i), y(i)) ≈ N × ℓ(θ; x(j), y(j)),
(x(j), y(j)) ∼ {(x(i), y(i))}N
i=,
where the instance (x(j), y(j)) is sampled at random from the full dataset.
In stochastic gradient descent, the approximate gradient is computed by randomly
sampling a single instance, and an update is made immediately. This is similar to the
perceptron algorithm, which also updates the weights one instance at a time. In mini-
batch stochastic gradient descent, the gradient is computed over a small set of instances.
A typical approach is to set the minibatch size so that the entire batch ﬁts in memory on a
graphics processing unit (GPU; Neubig et al., ). It is then possible to speed up learn-
ing by parallelizing the computation of the gradient over each instance in the minibatch.
Algorithm  offers a generalized view of gradient descent. In standard gradient de-
scent, the batcher returns a single batch with all the instances. In stochastic gradient de-
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Algorithm  Generalized gradient descent. The function BATCHER partitions the train-
ing set into B batches such that each instance appears in exactly one batch. In gradient
descent, B = ; in stochastic gradient descent, B = N; in minibatch stochastic gradient
descent,  < B < N.
: procedure GRADIENT-DESCENT(x(:N), y(:N), L, η(...∞), BATCHER, Tmax)
θ ←
t ←
repeat
(b(), b(), . . . , b(B)) ← BATCHER(N)
for n ∈ {, , . . . , B} do
t ← t +
θ(t) ← θ(t−) − η(t)∇θL(θ(t−); x(b(n)
,b(n)
,...), y(b(n)
,b(n)
if Converged(θ(,,...,t)) then
return θ(t)
until t ≥ Tmax
return θ(t)
scent, it returns N batches with one instance each. In mini-batch settings, the batcher
returns B minibatches,  < B < N.
There are many other techniques for online learning, and research in this area is on-
going (Bottou et al., ). Some algorithms use an adaptive learning rate, which can be
different for every feature (Duchi et al., ). Features that occur frequently are likely
to be updated frequently, so it is best to use a small learning rate; rare features will be
updated infrequently, so it is better to take larger steps. The AdaGrad (adaptive gradient)
algorithm achieves this behavior by storing the sum of the squares of the gradients for
each feature, and rescaling the learning rate by its inverse:
gt =∇θL(θ(t); x(i), y(i))
θ(t+)
←θ(t)
η(t)
qPt
t′= g
t,j
gt,j,
where j iterates over features in f(x, y).
In most cases, the number of active features for any instance is much smaller than the
number of weights. If so, the computation cost of online optimization will be dominated
by the update from the regularization term, λθ. The solution is to be “lazy”, updating
each θj only as it is used. To implement lazy updating, store an additional parameter τj,
which is the iteration at which θj was last updated. If θj is needed at time t, the t − τ
regularization updates can be performed all at once. This strategy is described in detail
by Kummerfeld et al. ().
Jacob Eisenstein. Draft of November , .

.. *ADDITIONAL TOPICS IN CLASSIFICATION
*Additional topics in classiﬁcation
This section presents some additional topics in classiﬁcation that are particularly relevant
for natural language processing, especially for understanding the research literature.
Feature selection by regularization
In logistic regression and large-margin classiﬁcation, generalization can be improved by
regularizing the weights towards , using the L norm. But rather than encouraging
weights to be small, it might be better for the model to be sparse: it should assign weights
of exactly zero to most features, and only assign non-zero weights to features that are
clearly necessary. This idea can be formalized by the L norm, L = ||θ|| = P
j δ (θj ̸= ),
which applies a constant penalty for each non-zero weight. This norm can be thought
of as a form of feature selection: optimizing the L-regularized conditional likelihood is
equivalent to trading off the log-likelihood against the number of active features. Reduc-
ing the number of active features is desirable because the resulting model will be fast,
low-memory, and should generalize well, since irrelevant features will be pruned away.
Unfortunately, the L norm is non-convex and non-differentiable. Optimization under L
regularization is NP-hard, meaning that it can be solved efﬁciently only if P=NP (Ge et al.,
A useful alternative is the L norm, which is equal to the sum of the absolute values
of the weights, ||θ|| = P
j |θj|. The L norm is convex, and can be used as an approxima-
tion to L (Tibshirani, ). Conveniently, the L norm also performs feature selection,
by driving many of the coefﬁcients to zero; it is therefore known as a sparsity inducing
regularizer. The L norm does not have a gradient at θj = , so we must instead optimize
the L-regularized objective using subgradient methods. The associated stochastic sub-
gradient descent algorithms are only somewhat more complex than conventional SGD;
Sra et al. () survey approaches for estimation under L and other regularizers.
Gao et al. () compare L and L regularization on a suite of NLP problems, ﬁnding
that L regularization generally gives similar accuracy to L regularization, but that L
regularization produces models that are between ten and ﬁfty times smaller, because more
than % of the feature weights are set to zero.
Other views of logistic regression
In binary classiﬁcation, we can dispense with the feature function, and choose y based on
the inner product of θ  x. The conditional probability pY |X is obtained by passing this
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
inner product through a logistic function,
σ(a) ≜
exp(a)
+ exp(a) = ( + exp(−a))−
p(y | x; θ) =σ(θ  x).
This is the origin of the name “logistic regression.” Logistic regression can be viewed as
part of a larger family of generalized linear models (GLMs), in which various other link
functions convert between the inner product θ  x and the parameter of a conditional
probability distribution.
Logistic regression and related models are sometimes referred to as log-linear, be-
cause the log-probability is a linear function of the features. But in the early NLP liter-
ature, logistic regression was often called maximum entropy classiﬁcation (Berger et al.,
). This name refers to an alternative formulation, in which the goal is to ﬁnd the max-
imum entropy probability function that satisﬁes moment-matching constraints. These
constraints specify that the empirical counts of each feature should match the expected
counts under the induced probability distribution pY |X;θ,
i=
fj(x(i), y(i)) =
i=
y∈Y
p(y | x(i); θ)fj(x(i), y),
∀j
The moment-matching constraint is satisﬁed exactly when the derivative of the condi-
tional log-likelihood function (Equation .) is equal to zero. However, the constraint
can be met by many values of θ, so which should we choose?
The entropy of the conditional probability distribution pY |X is,
y∈Y
pY |X(y | x) log pY |X(y | x),
x∈X
pX(x)
H(pY |X) = −
where X is the set of all possible feature vectors, and pX(x) is the probability of observing
the base features x. The distribution pX is unknown, but it can be estimated by summing
over all the instances in the training set,
˜H(pY |X) = −
i=
y∈Y
pY |X(y | x(i)) log pY |X(y | x(i)).
If the entropy is large, the likelihood function is smooth across possible values of y;
if it is small, the likelihood function is sharply peaked at some preferred value; in the
limiting case, the entropy is zero if p(y | x) =  for some y. The maximum-entropy cri-
terion chooses to make the weakest commitments possible, while satisfying the moment-
matching constraints from Equation .. The solution to this constrained optimization
problem is identical to the maximum conditional likelihood (logistic-loss) formulation
that was presented in § ..
Jacob Eisenstein. Draft of November , .

.. SUMMARY OF LEARNING ALGORITHMS
Summary of learning algorithms
It is natural to ask which learning algorithm is best, but the answer depends on what
characteristics are important to the problem you are trying to solve.
Na¨ıve Bayes Pros: easy to implement; estimation is fast, requiring only a single pass over
the data; assigns probabilities to predicted labels; controls overﬁtting with smooth-
ing parameter. Cons: often has poor accuracy, especially with correlated features.
Perceptron Pros: easy to implement; online; error-driven learning means that accuracy
is typically high, especially after averaging. Cons: not probabilistic; hard to know
when to stop learning; lack of margin can lead to overﬁtting.
Support vector machine Pros: optimizes an error-based metric, usually resulting in high
accuracy; overﬁtting is controlled by a regularization parameter. Cons: not proba-
bilistic.
Logistic regression Pros: error-driven and probabilistic; overﬁtting is controlled by a reg-
ularization parameter. Cons: batch learning requires black-box optimization; logistic
loss can “overtrain” on correctly labeled examples.
One of the main distinctions is whether the learning algorithm offers a probability
over labels. This is useful in modular architectures, where the output of one classiﬁer
is the input for some other system. In cases where probability is not necessary, the sup-
port vector machine is usually the right choice, since it is no more difﬁcult to implement
than the perceptron, and is often more accurate. When probability is necessary, logistic
regression is usually more accurate than Na¨ıve Bayes.
Additional resources
A machine learning textbook will offer more classiﬁers and more details (e.g., Murphy,
), although the notation will differ slightly from what is typical in natural language
processing. Probabilistic methods are surveyed by Hastie et al. (), and Mohri et al.
() emphasize theoretical considerations. Bottou et al. () surveys the rapidly mov-
ing ﬁeld of online learning, and Kummerfeld et al. () empirically review several opti-
mization algorithms for large-margin learning. The python toolkit SCIKIT-LEARN includes
implementations of all of the algorithms described in this chapter (Pedregosa et al., ).
Appendix B describes an alternative large-margin classiﬁer, called passive-aggressive.
Passive-aggressive is an online learner that seeks to make the smallest update that satisﬁes
the margin constraint at the current instance. It is closely related to MIRA, which was used
widely in NLP in the s (Crammer and Singer, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
Exercises
There will be exercises at the end of each chapter. In this chapter, the exercises are mostly
mathematical, matching the subject material. In other chapters, the exercises will empha-
size linguistics or programming.
. Let x be a bag-of-words vector such that PV
j= xj = . Verify that the multinomial
probability pmult(x; φ), as deﬁned in Equation ., is identical to the probability of
the same document under a categorical distribution, pcat(w; φ).
. Suppose you have a single feature x, with the following conditional distribution:
p(x | y) =

α,
X = , Y =
− α,
X = , Y =
− β,
X = , Y =
β,
X = , Y = .

Further suppose that the prior is uniform, Pr(Y = ) = Pr(Y = ) =
, and that
both α >
and β >
. Given a Na¨ıve Bayes classiﬁer with accurate parameters,
what is the probability of making an error?
. Derive the maximum-likelihood estimate for the parameter µ in Na¨ıve Bayes.
. The classiﬁcation models in the text have a vector of weights for each possible label.
While this is notationally convenient, it is overdetermined: for any linear classiﬁer
that can be obtained with K ×V weights, an equivalent classiﬁer can be constructed
using (K − ) × V weights.
a) Describe how to construct this classiﬁer. Speciﬁcally, if given a set of weights
θ and a feature function f(x, y), explain how to construct alternative weights
and feature function θ′ and f ′(x, y), such that,
∀y, y′ ∈ Y, θ  f(x, y) − θ  f(x, y′) = θ′  f ′(x, y) − θ′  f ′(x, y′).
b) Explain how your construction justiﬁes the well-known alternative form for
binary logistic regression, Pr(Y =  | x; θ) =
+exp(−θ′x) = σ(θ′  x), where σ
is the sigmoid function.
. Suppose you have two labeled datasets D and D, with the same features and la-
bels.
Let θ() be the unregularized logistic regression (LR) coefﬁcients from training
on dataset D.
Jacob Eisenstein. Draft of November , .

.. SUMMARY OF LEARNING ALGORITHMS
Let θ() be the unregularized LR coefﬁcients (same model) from training on
dataset D.
Let θ∗ be the unregularized LR coefﬁcients from training on the combined
dataset D ∪ D.
Under these conditions, prove that for any feature j,
θ∗
j ≥ min(θ()
j , θ()
j )
θ∗
j ≤ max(θ()
j , θ()
j ).
. Let ˆθ be the solution to an unregularized logistic regression problem, and let θ∗ be
the solution to the same problem, with L regularization. Prove that ||θ∗||
≤ ||ˆθ||
. As noted in the discussion of averaged perceptron in § .., the computation of the
running sum m ← m + θ is unnecessarily expensive, requiring K × V operations.
Give an alternative way to compute the averaged weights θ, with complexity that is
independent of V and linear in the sum of feature sizes PN
i= |f(x(i), y(i))|.
. Consider a dataset that is comprised of two identical instances x() = x() with
distinct labels y() ̸= y(). Assume all features are binary, xj ∈ {, } for all j.
Now suppose that the averaged perceptron always trains on the instance (xi(t), yi(t)),
where i(t) =  − (t mod ), which is  when the training iteration t is odd, and
when t is even. Further suppose that learning terminates under the following con-
dition:
ϵ ≥ max
θ(t)
θ(t−)
t −

In words, the algorithm stops when the largest change in the averaged weights is
less than or equal to ϵ. Compute the number of iterations before the averaged per-
ceptron terminates.
. Prove that the margin loss is convex in θ. Use this deﬁnition of the margin loss:
L(θ) = −θ  f(x, y∗) + max
θ  f(x, y) + c(y∗, y),
where y∗ is the gold label. As a reminder, a function f is convex iff,
f(αx + ( − α)x) ≤ αf(x) + ( − α)f(x),
for any x, x and α ∈ [, ].
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINEAR TEXT CLASSIFICATION
. If a function f is m-strongly convex, then for some m > , the following inequality
holds for all x and x′ on the domain of the function:
f(x′) ≤ f(x) + (∇xf)  (x′ − x) + m
||x′ − x||
Let f(x) = L(θ(t)), representing the loss of the classiﬁer at iteration t of gradient
descent; let f(x′) = L(θ(t+)). Assuming the loss function is m-convex, prove that
L(θ(t+)) ≤ L(θ(t)) for an appropriate constant learning rate η, which will depend
on m. Explain why this implies that gradient descent converges when applied to an
m-strongly convex loss function with a unique minimum.
Jacob Eisenstein. Draft of November , .

Chapter
Nonlinear classiﬁcation
Linear classiﬁcation may seem like all we need for natural language processing. The bag-
of-words representation is inherently high dimensional, and the number of features is
often larger than the number of labeled training instances. This means that it is usually
possible to ﬁnd a linear classiﬁer that perfectly ﬁts the training data, or even to ﬁt any ar-
bitrary labeling of the training instances! Moving to nonlinear classiﬁcation may therefore
only increase the risk of overﬁtting. Furthermore, for many tasks, lexical features (words)
are meaningful in isolation, and can offer independent evidence about the instance label
— unlike computer vision, where individual pixels are rarely informative, and must be
evaluated holistically to make sense of an image. For these reasons, natural language
processing has historically focused on linear classiﬁcation.
But in recent years, nonlinear classiﬁers have swept through natural language pro-
cessing, and are now the default approach for many tasks (Manning, ). There are at
least three reasons for this change.
There have been rapid advances in deep learning, a family of nonlinear meth-
ods that learn complex functions of the input through multiple layers of compu-
tation (Goodfellow et al., ).
Deep learning facilitates the incorporation of word embeddings, which are dense
vector representations of words. Word embeddings can be learned from large amounts
of unlabeled data, and enable generalization to words that do not appear in the an-
notated training data (word embeddings are discussed in detail in chapter ).
While CPU speeds have plateaued, there have been rapid advances in specialized
hardware called graphics processing units (GPUs), which have become faster, cheaper,
and easier to program. Many deep learning models can be implemented efﬁciently
on GPUs, offering substantial performance improvements over CPU-based comput-
ing.
CHAPTER . NONLINEAR CLASSIFICATION
This chapter focuses on neural networks, which are the dominant approach for non-
linear classiﬁcation in natural language processing today. Historically, a few other non-
linear learning methods have been applied to language data.
Kernel methods are generalizations of the nearest-neighbor classiﬁcation rule, which
classiﬁes each instance by the label of the most similar example in the training set.
The application of the kernel support vector machine to information extraction is
described in chapter .
Decision trees classify instances by checking a set of conditions. Scaling decision
trees to bag-of-words inputs is difﬁcult, but decision trees have been successful in
problems such as coreference resolution (chapter ), where more compact feature
sets can be constructed (Soon et al., ).
Boosting and related ensemble methods work by combining the predictions of sev-
eral “weak” classiﬁers, each of which may consider only a small subset of features.
Boosting has been successfully applied to text classiﬁcation (Schapire and Singer,
) and syntactic analysis (Abney et al., ), and remains one of the most suc-
cessful methods on machine learning competition sites such as Kaggle (Chen and
Guestrin, ).
Hastie et al. () provide an excellent overview of these techniques.
Feedforward neural networks
Consider the problem of building a classiﬁer for movie reviews. The goal is to predict a
label y ∈ {GOOD, BAD, OKAY} from a representation of the text of each document, x. But
what makes a good movie? The story, acting, cinematography, editing, soundtrack, and
so on. Now suppose the training set contains labels for each of these additional features,
z = [z, z, . . . , zKz]⊤. With a training set of such information, we could build a two-step
classiﬁer:
. Use the text x to predict the features z. Speciﬁcally, train a logistic regression clas-
siﬁer to compute p(zk | x), for each k ∈ {, , . . . , Kz}.
. Use the features z to predict the label y. Again, train a logistic regression classiﬁer
to compute p(y | z). On test data, z is unknown, so we will use the probabilities
p(z | x) from the ﬁrst layer as the features.
This setup is shown in Figure ., which describes the proposed classiﬁer in a computa-
tion graph: the text features x are connected to the middle layer z, which is connected to
the label y.
I will use “deep learning” and “neural networks” interchangeably.
Jacob Eisenstein. Draft of November , .

.. FEEDFORWARD NEURAL NETWORKS
. . .
. . .
Figure .: A feedforward neural network. Shaded circles indicate observed features,
usually words; squares indicate nodes in the computation graph, which are computed
from the information carried over the incoming arrows.
If we assume that each zk is binary, zk ∈ {, }, then the probability p(zk | x) can be
modeled using binary logistic regression:
Pr(zk =  | x; Θ(x→z)) = σ(θ(x→z)
x) = ( + exp(−θ(x→z)
x))−,
where σ is the sigmoid function (shown in Figure .), and the matrix Θ(x→z) ∈ RKz×V is
constructed by stacking the weight vectors for each zk,
Θ(x→z) = [θ(x→z)
, θ(x→z)
, . . . , θ(x→z)
Kz
We will assume that x contains a term with a constant value of , so that a corresponding
offset parameter is included in each θ(x→z)
The output layer is computed by the multi-class logistic regression probability,
Pr(y = j | z; Θ(z→y), b) =
exp(θ(z→y)
z + bj)
j′∈Y exp(θ(z→y)
j′
z + bj′)
where bj is an offset for label j, and the output weight matrix Θ(z→y) ∈ RKy×Kz is again
constructed by concatenation,
Θ(z→y) = [θ(z→y)
, θ(z→y)
, . . . , θ(z→y)
Ky
The vector of probabilities over each possible value of y is denoted,
p(y | z; Θ(z→y), b) = SoftMax(Θ(z→y)z + b),
where element j in the output of the SoftMax function is computed as in Equation ..
This set of equations deﬁnes a multilayer classiﬁer, which can be summarized as,
p(z | x; Θ(x→z)) =σ(Θ(x→z)x)
p(y | z; Θ(z→y), b) = SoftMax(Θ(z→y)z + b),
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
values
derivatives
sigmoid
tanh
ReLU
Figure .: The sigmoid, tanh, and ReLU activation functions
where the function σ is now applied elementwise to the vector of inner products,
σ(Θ(x→z)x) = [σ(θ(x→z)
x), σ(θ(x→z)
x), . . . , σ(θ(x→z)
Kz
x)]⊤.
Now suppose that the hidden features z are never observed, even in the training data.
We can still construct the architecture in Figure .. Instead of predicting y from a discrete
vector of predicted values z, we use the probabilities σ(θk  x). The resulting classiﬁer is
barely changed:
z =σ(Θ(x→z)x)
p(y | x; Θ(z→y), b) = SoftMax(Θ(z→y)z + b).
This deﬁnes a classiﬁcation model that predicts the label y ∈ Y from the base features x,
through a“hidden layer” z. This is a feedforward neural network.
Designing neural networks
There several ways to generalize the feedforward neural network.
Activation functions
If the hidden layer is viewed as a set of latent features, then the sigmoid function in Equa-
tion . represents the extent to which each of these features is “activated” by a given
input. However, the hidden layer can be regarded more generally as a nonlinear trans-
formation of the input. This opens the door to many other activation functions, some of
which are shown in Figure .. At the moment, the choice of activation functions is more
art than science, but a few points can be made about the most popular varieties:
The architecture is sometimes called a multilayer perceptron, but this is misleading, because each layer
is not a perceptron as deﬁned in the previous chapter.
Jacob Eisenstein. Draft of November , .

.. DESIGNING NEURAL NETWORKS
The range of the sigmoid function is (, ). The bounded range ensures that a cas-
cade of sigmoid functions will not “blow up” to a huge output, and this is impor-
tant for deep networks with several hidden layers. The derivative of the sigmoid is
∂aσ(a) = σ(a)( − σ(a)). This derivative becomes small at the extremes, which can
make learning slow; this is called the vanishing gradient problem.
The range of the tanh activation function is (−, ): like the sigmoid, the range
is bounded, but unlike the sigmoid, it includes negative values. The derivative is
∂a tanh(a) =  − tanh(a), which is steeper than the logistic function near the ori-
gin (LeCun et al., ). The tanh function can also suffer from vanishing gradients
at extreme values.
The rectiﬁed linear unit (ReLU) is zero for negative inputs, and linear for positive
inputs (Glorot et al., ),
ReLU(a) =
a,
a ≥
otherwise.
The derivative is a step function, which is  if the input is positive, and zero other-
wise. Once the activation is zero, the gradient is also zero. This can lead to the prob-
lem of “dead neurons”, where some ReLU nodes are zero for all inputs, throughout
learning. A solution is the leaky ReLU, which has a small positive slope for negative
inputs (Maas et al., ),
Leaky-ReLU(a) =
a,
a ≥
.a,
otherwise.
Sigmoid and tanh are sometimes described as squashing functions, because they squash
an unbounded input into a bounded range. Glorot and Bengio () recommend against
the use of the sigmoid activation in deep networks, because its mean value of
can cause
the next layer of the network to be saturated, leading to small gradients on its own pa-
rameters. Several other activation functions are reviewed in the textbook by Goodfellow
et al. (), who recommend ReLU as the “default option.”
Network structure
Deep networks stack up several hidden layers, with each z(d) acting as the input to the
next layer, z(d+). As the total number of nodes in the network increases, so does its
capacity to learn complex functions of the input. Given a ﬁxed number of nodes, one
must decide whether to emphasize width (large Kz at each layer) or depth (many layers).
At present, this tradeoff is not well understood.
With even a single hidden layer, a neural network can approximate any continuous function on a closed
and bounded subset of RN to an arbitrarily small non-zero error; see section .. of Goodfellow et al. ()
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
It is also possible to “short circuit” a hidden layer, by propagating information directly
from the input to the next higher level of the network. This is the idea behind residual net-
works, which propagate information directly from the input to the subsequent layer (He
et al., ),
z = f(Θ(x→z)x) + x,
where f is any nonlinearity, such as sigmoid or ReLU. A more complex architecture is
the highway network (Srivastava et al., ; Kim et al., ), in which an addition gate
controls an interpolation between f(Θ(x→z)x) and x,
t =σ(Θ(t)x + b(t))
z =t ⊙ f(Θ(x→z)x) + ( − t) ⊙ x,
where ⊙ refers to an elementwise vector product, and  is a column vector of ones. As
before, the sigmoid function is applied elementwise to its input; recall that the output of
this function is restricted to the range (, ). Gating is also used in the long short-term
memory (LSTM), which is discussed in chapter . Residual and highway connections
address a problem with deep architectures: repeated application of a nonlinear activation
function can make it difﬁcult to learn the parameters of the lower levels of the network,
which are too distant from the supervision signal.
Outputs and loss functions
In the multi-class classiﬁcation example, a softmax output produces probabilities over
each possible label. This aligns with a negative conditional log-likelihood,
−L = −
i=
log p(y(i) | x(i); Θ).
where Θ = {Θ(x→z), Θ(z→y), b} is the entire set of parameters.
This loss can be written alternatively as follows:
˜yj ≜ Pr(y = j | x(i); Θ)
−L = −
i=
ey(i)  log ˜y
for a survey of these theoretical results. However, depending on the function to be approximated, the width
of the hidden layer may need to be arbitrarily large. Furthermore, the fact that a network has the capacity to
approximate any given function does not imply that it is possible to learn the function using gradient-based
optimization.
Jacob Eisenstein. Draft of November , .

.. LEARNING NEURAL NETWORKS
where ey(i) is a one-hot vector of zeros with a value of  at position y(i). The inner product
between ey(i) and log ˜y is also called the multinomial cross-entropy, and this terminology
is preferred in many neural networks papers and software packages.
It is also possible to train neural networks from other objectives, such as a margin loss.
In this case, it is not necessary to use softmax at the output layer: an afﬁne transformation
of the hidden layer is enough:
Ψ(y; x(i), Θ) =θ(z→y)
z + by
+ .
ℓMARGIN(Θ; x(i), y(i)) = max
y̸=y(i)

+ Ψ(y; x(i), Θ) − Ψ(y(i); x(i), Θ)

In regression problems, the output is a scalar or vector (see § ..). For these problems, a
typical loss function is the squared error (y − ˆy) or squared norm ||y − ˆy||
Inputs and lookup layers
In text classiﬁcation, the input layer x can refer to a bag-of-words vector, where xj is
the count of word j. The input to the hidden unit zk is then PV
j= θ(x→z)
j,k
xj, and word j is
represented by the vector θ(x→z)
. This vector is sometimes described as the embedding of
word j, and can be learned from unlabeled data, using techniques discussed in chapter .
The columns of Θ(x→z) are each Kz-dimensional word embeddings.
Chapter  presented an alternative view of text documents, as a sequence of word
tokens, w, w, . . . , wM. In a neural network, each word token wm is represented with a
one-hot vector, ewm, with dimension V . The matrix-vector product Θ(x→z)ewm returns
the embedding of word wm. The complete document can represented by horizontally
concatenating these one-hot vectors, W = [ew, ew, . . . , ewM ], and the bag-of-words rep-
resentation can be recovered from the matrix-vector product W[, , . . . , ]⊤, which sums
each row over the tokens m = {, , . . . , M}. The matrix product Θ(x→z)W contains the
horizontally concatenated embeddings of each word in the document, which will be use-
ful as the starting point for convolutional neural networks (see § .). This is sometimes
called a lookup layer, because the ﬁrst step is to lookup the embeddings for each word in
the input text.
Learning neural networks
The feedforward network in Figure . can now be written as,
z ←f(Θ(x→z)x(i))
˜y ← SoftMax

Θ(z→y)z + b

ℓ(i) ← − ey(i)  log ˜y,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
where f is an elementwise activation function, such as σ or ReLU, and ℓ(i) is the loss at
instance i. The parameters Θ(x→z), Θ(z→y), and b can be estimated using online gradient-
based optimization. The simplest such algorithm is stochastic gradient descent, which
was discussed in § .. Each parameter is updated by the gradient of the loss,
b ←b − η(t)∇bℓ(i)
θ(z→y)
←θ(z→y)
− η(t)∇θ(z→y)
ℓ(i)
θ(x→z)
←θ(x→z)
− η(t)∇θ(x→z)
ℓ(i),
where η(t) is the learning rate on iteration t, ℓ(i) is the loss on instance (or minibatch) i,
and θ(x→z)
is column n of the matrix Θ(x→z), and θ(z→y)
is column k of Θ(z→y).
The gradients of the negative log-likelihood on b and θ(z→y)
are similar to the gradi-
ents in logistic regression. For θ(z→y), the gradient is,
∇θ(z→y)
ℓ(i) =
∂θ(z→y)
k,
∂ℓ(i)
∂θ(z→y)
k,
, . . . ,
∂ℓ(i)
∂θ(z→y)
k,Ky
∂ℓ(i)
∂ℓ(i)
∂θ(z→y)
k,j
= −
∂θ(z→y)
k,j
y∈Y
exp θ(z→y)
θ(z→y)
y(i)
z − log

Pr(y = j | z; Θ(z→y), b) − δ

j = y(i)
zk,
where δ
j = y(i)
is a function that returns one when j = y(i), and zero otherwise. The
gradient ∇bℓ(i) is similar to Equation ..
The gradients on the input layer weights Θ(x→z) are obtained by the chain rule of
differentiation:
∂ℓ(i)
∂zk
∂zk
∂θ(x→z)
n,k
=∂ℓ(i)
∂θ(x→z)
n,k
∂f(θ(x→z)
x)
=∂ℓ(i)
∂zk
∂θ(x→z)
n,k
=∂ℓ(i)
∂zk
× f′(θ(x→z)
x) × xn,
where f′(θ(x→z)
x) is the derivative of the activation function f, applied at the input
Jacob Eisenstein. Draft of November , .

.. LEARNING NEURAL NETWORKS
θ(x→z)
x. For example, if f is the sigmoid function, then the derivative is,
∂ℓ(i)
∂zk
× σ(θ(x→z)
x) × ( − σ(θ(x→z)
x)) × xn
∂θ(x→z)
n,k
=∂ℓ(i)
=∂ℓ(i)
∂zk
× zk × ( − zk) × xn.
For intuition, consider each of the terms in the product.
If the negative log-likelihood ℓ(i) does not depend much on zk, then ∂ℓ(i)
∂zk ≈ . In this
case it doesn’t matter how zk is computed, and so
∂ℓ(i)
∂θ(x→z)
n,k
≈ .
If zk is near  or , then the curve of the sigmoid function is nearly ﬂat (Figure .),
and changing the inputs will make little local difference. The term zk × ( − zk) is
maximized at zk =
, where the slope of the sigmoid function is steepest.
If xn = , then it does not matter how we set the weights θ(x→z)
n,k
, so
∂ℓ(i)
∂θ(x→z)
n,k
= .
Backpropagation
The equations above rely on the chain rule to compute derivatives of the loss with respect
to each parameter of the model. Furthermore, local derivatives are frequently reused: for
example, ∂ℓ(i)
∂zk is reused in computing the derivatives with respect to each θ(x→z)
n,k
. These
terms should therefore be computed once, and then cached. Furthermore, we should only
compute any derivative once we have already computed all of the necessary “inputs”
demanded by the chain rule of differentiation. This combination of sequencing, caching,
and differentiation is known as backpropagation. It can be generalized to any directed
acyclic computation graph.
A computation graph is a declarative representation of a computational process. At
each node t, compute a value vt by applying a function ft to a (possibly empty) list of
parent nodes, πt. Figure . shows the computation graph for a feedforward network
with one hidden layer. There are nodes for the input x(i), the hidden layer z, the predicted
output ˆy, and the parameters Θ. During training, there is also a node for the ground truth
label y(i) and the loss ℓ(i). The predicted output ˆy is one of the parents of the loss (the
other is the label y(i)); its parents include Θ and z, and so on.
Computation graphs include three types of nodes:
Variables. In the feedforward network of Figure ., the variables include the inputs x,
the hidden nodes z, the outputs y, and the loss function. Inputs are variables that
do not have parents. Backpropagation computes the gradients with respect to all
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
Algorithm  General backpropagation algorithm. In the computation graph G, every
node contains a function ft and a set of parent nodes πt; the inputs to the graph are x(i).
: procedure BACKPROP(G = {ft, πt}T
t=}, x(i))
vt(n) ← x(i)
n for all n and associated computation nodes t(n).
for t ∈ TOPOLOGICALSORT(G) do
▷ Forward pass: compute value at each node
if |πt| >  then
vt ← ft(vπt,, vπt,, . . . , vπt,Nt)
gobjective =
▷ Backward pass: compute gradients at each node
for t ∈ REVERSE(TOPOLOGICALSORT(G)) do
gt ← P
t′:t∈πt′ gt′ × ∇vtvt′
▷ Sum over all t′ that are children of t, propagating
the gradient gt′, scaled by the local gradient ∇vtvt′
return {g, g, . . . , gT }
variables except the inputs, and propagates these gradients backwards to the pa-
rameters.
Parameters. In a feedforward network, the parameters include the weights and offsets.
In Figure ., the parameters are summarized in the node Θ, but we could have
separate nodes for Θ(x→z), Θ(z→y), and any offset parameters. Parameter nodes do
not have parents; they are not computed from other nodes, but rather, are learned
by gradient descent.
Loss. The loss ℓ(i) is the quantity that is to be minimized during training. The node rep-
resenting the loss in the computation graph is not the parent of any other node; its
parents are typically the predicted label ˆy and the true label y(i). Backpropagation
begins by computing the gradient of the loss, and then propagating this gradient
backwards to its immediate parents.
If the computation graph is a directed acyclic graph, then it is possible to order the
nodes with a topological sort, so that if node t is a parent of node t′, then t < t′. This
means that the values {vt}T
t= can be computed in a single forward pass. The topolog-
ical sort is reversed when computing gradients: each gradient gt is computed from the
gradients of the children of t, implementing the chain rule of differentiation. The general
backpropagation algorithm for computation graphs is shown in Algorithm .
While the gradients with respect to each parameter may be complex, they are com-
posed of products of simple parts. For many networks, all gradients can be computed
through automatic differentiation. This means that you need only specify the feedfor-
ward computation, and the gradients necessary for learning can be obtained automati-
cally. There are many software libraries that perform automatic differentiation on compu-
Jacob Eisenstein. Draft of November , .

.. LEARNING NEURAL NETWORKS
vy
vx
vz
vˆy
x(i)
ˆy
ℓ(i)
y(i)
gℓ
gˆy
gℓ
gz
gˆy
gz
vΘ
vΘ
Figure .: A computation graph for the feedforward neural network shown in Figure ..
tation graphs, such as TORCH (Collobert et al., ), TENSORFLOW (Abadi et al., ),
and DYNET (Neubig et al., ). One important distinction between these libraries is
whether they support dynamic computation graphs, in which the structure of the compu-
tation graph varies across instances. Static computation graphs are compiled in advance,
and can be applied to ﬁxed-dimensional data, such as bag-of-words vectors. In many nat-
ural language processing problems, each input has a distinct structure, requiring a unique
computation graph. A simple case occurs in recurrent neural network language models
(see chapter ), in which there is one node for each word in a sentence. More complex
cases include recursive neural networks (see chapter ), in which the network is a tree
structure matching the syntactic organization of the input.
Regularization and dropout
In linear classiﬁcation, overﬁtting was addressed by augmenting the objective with a reg-
ularization term, λ||θ||
. This same approach can be applied to feedforward neural net-
works, penalizing each matrix of weights:
L =
i=
ℓ(i) + λz→y||Θ(z→y)||
F + λx→z||Θ(x→z)||
F ,
where ||Θ||
F = P
i,j θ
i,j is the squared Frobenius norm, which generalizes the L norm
to matrices. The bias parameters b are not regularized, as they do not contribute to the
sensitivity of the classiﬁer to the inputs. In gradient-based optimization, the practical
effect of Frobenius norm regularization is that the weights “decay” towards zero at each
update, motivating the alternative name weight decay.
Another approach to controlling model complexity is dropout, which involves ran-
domly setting some computation nodes to zero during training (Srivastava et al., ).
For example, in the feedforward network, on each training instance, with probability ρ we
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
set each input xn and each hidden layer node zk to zero. Srivastava et al. () recom-
mend ρ = . for hidden units, and ρ = . for input units. Dropout is also incorporated
in the gradient computation, so if node zk is dropped, then none of the weights θ(x→z)
will
be updated for this instance. Dropout prevents the network from learning to depend too
much on any one feature or hidden node, and prevents feature co-adaptation, in which a
hidden unit is only useful in combination with one or more other hidden units. Dropout is
a special case of feature noising, which can also involve adding Gaussian noise to inputs
or hidden units (Holmstrom and Koistinen, ). Wager et al. () show that dropout is
approximately equivalent to “adaptive” L regularization, with a separate regularization
penalty for each feature.
*Learning theory
Chapter  emphasized the importance of convexity for learning: for convex objectives,
the global optimum can be found efﬁciently. The negative log-likelihood and hinge loss
are convex functions of the parameters of the output layer. However, the output of a feed-
forward network is generally not a convex function of the parameters of the input layer,
Θ(x→z). Feedforward networks can be viewed as function composition, where each layer
is a function that is applied to the output of the previous layer. Convexity is generally not
preserved in the composition of two convex functions — and furthermore, “squashing”
activation functions like tanh and sigmoid are not convex.
The non-convexity of hidden layer neural networks can also be seen by permuting the
elements of the hidden layer, from z = [z, z, . . . , zKz] to ˜z = [zπ(), zπ(), . . . , zπ(Kz)]. This
corresponds to applying π to the rows of Θ(x→z) and the columns of Θ(z→y), resulting in
permuted parameter matrices Θ(x→z)
and Θ(z→y)
. As long as this permutation is applied
consistently, the loss will be identical, L(Θ) = L(Θπ): it is invariant to this permutation.
However, the loss of the linear combination L(αΘ + ( − α)Θπ) will generally not be
identical to the loss under Θ or its permutations. If L(Θ) is better than the loss at any
points in the immediate vicinity, and if L(Θ) = L(Θπ), then the loss function does not
satisfy the deﬁnition of convexity (see § .). One of the exercises asks you to prove this
more rigorously.
In practice, the existence of multiple optima is not necessary problematic, if all such
optima are permutations of the sort described in the previous paragraph. In contrast,
“bad” local optima are better than their neighbors, but much worse than the global op-
timum. Fortunately, in large feedforward neural networks, most local optima are nearly
as good as the global optimum (Choromanska et al., ). More generally, a critical
point is one at which the gradient is zero. Critical points may be local optima, but they
may also be saddle points, which are local minima in some directions, but local maxima
in other directions. For example, the equation x
− x
has a saddle point at x = (, ).
In large networks, the overwhelming majority of critical points are saddle points, rather
Jacob Eisenstein. Draft of November , .

.. LEARNING NEURAL NETWORKS
than local minima or maxima (Dauphin et al., ). Saddle points can pose problems
for gradient-based optimization, since learning will slow to a crawl as the gradient goes
to zero. However, the noise introduced by stochastic gradient descent, and by feature
noising techniques such as dropout, can help online optimization to escape saddle points
and ﬁnd high-quality optima (Ge et al., ). Other techniques address saddle points
directly, using local reconstructions of the Hessian matrix (Dauphin et al., ) or higher-
order derivatives (Anandkumar and Ge, ).
Another theoretical puzzle about neural networks is how they are able to generalize
to unseen data. Given enough parameters, a two-layer feedforward network can “mem-
orize” its training data, attaining perfect accuracy on any training set. A particularly
salient demonstration was provided by Zhang et al. (), who showed that neural net-
works can learn to perfectly classify a training set of images, even when the labels are
replaced with random values! Of course, this network attains only chance accuracy when
applied to heldout data. The concern is that when such a powerful learner is applied to
real training data, it may learn a pathological classiﬁcation function, which exploits irrel-
evant details of the training data and fails to generalize. Yet this extreme overﬁtting is
rarely encountered in practice, and can usually be prevented by regularization, dropout,
and early stopping (see § ..). Recent papers have derived generalization guarantees for
speciﬁc classes of neural networks (e.g., Kawaguchi et al., ; Brutzkus et al., ), but
theoretical work in this area is ongoing.
Tricks
Getting neural networks to work sometimes requires heuristic “tricks” (Bottou, ;
Goodfellow et al., ; Goldberg, b). This section presents some tricks that are espe-
cially important.
Initialization
Initialization is not especially important for linear classiﬁers, since con-
vexity ensures that the global optimum can usually be found quickly. But for multilayer
neural networks, it is helpful to have a good starting point. One reason is that if the mag-
nitude of the initial weights is too large, a sigmoid or tanh nonlinearity will be saturated,
leading to a small gradient, and slow learning. Large gradients can cause training to di-
verge, with the parameters taking increasingly extreme values until reaching the limits of
the ﬂoating point representation.
Initialization can help avoid these problems by ensuring that the variance over the
initial gradients is constant and bounded throughout the network. For networks with
tanh activation functions, this can be achieved by sampling the initial weights from the
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
following uniform distribution (Glorot and Bengio, ),
θi,j ∼U
din(n) + dout(n)
din(n) + dout(n)
For the weights leading to a ReLU activation function, He et al. () use similar argu-
mentation to justify sampling from a zero-mean Gaussian distribution,
/din(n))
θi,j ∼ N(,
Rather than initializing the weights independently, it can be beneﬁcial to initialize each
layer jointly as an orthonormal matrix, ensuring that Θ⊤Θ = I (Saxe et al., ). Or-
thonormal matrices preserve the norm of the input, so that ||Θx|| = ||x||, which prevents
the gradients from exploding or vanishing. Orthogonality ensures that the hidden units
are uncorrelated, so that they correspond to different features of the input. Orthonormal
initialization can be performed by applying singular value decomposition to a matrix of
values sampled from a standard normal distribution:
ai,j ∼N(, )
A ={ai,j}din(j),dout(j)
i=,j=
U, S, V⊤ =SVD(A)
Θ(j) ←U.
The matrix U contains the singular vectors of A, and is guaranteed to be orthonormal.
For more on singular value decomposition, see chapter .
Even with careful initialization, there can still be signiﬁcant variance in the ﬁnal re-
sults. It can be useful to make multiple training runs, and select the one with the best
performance on a heldout development set.
Clipping and normalization
Learning can be sensitive to the magnitude of the gradient:
too large, and learning can diverge, with successive updates thrashing between increas-
ingly extreme values; too small, and learning can grind to a halt. Several heuristics have
been proposed to address this issue.
In gradient clipping (Pascanu et al., ), an upper limit is placed on the norm of
the gradient, and the gradient is rescaled when this limit is exceeded,
CLIP(˜g) =
||ˆg|| < τ
||g||g
otherwise.
Jacob Eisenstein. Draft of November , .

.. LEARNING NEURAL NETWORKS
In batch normalization (Ioffe and Szegedy, ), the inputs to each computation
node are recentered by their mean and variance across all of the instances in the
minibatch B (see § ..). For example, in a feedforward network with one hidden
layer, batch normalization would tranform the inputs to the hidden layer as follows:
µ(B) =
|B|
i∈B
x(i)
s(B) =
|B|
i∈B
(x(i) − µ(B))
s(B).
x(i) =(x(i) − µ(B))/
Empirically, this speeds convergence of deep architectures. One explanation is that
it helps to correct for changes in the distribution of activations during training.
In layer normalization (Ba et al., ), the inputs to each nonlinear activation func-
tion are recentered across the layer:
a =Θ(x→z)x
µ =
Kz
k=
ak
Kz
s =
Kz
k=
(ak − µ)
Kz
z =(a − µ)/√s.
Layer normalization has similar motivations to batch normalization, but it can be
applied across a wider range of architectures and training conditions.
Online optimization
There is a cottage industry of online optimization algorithms that
attempt to improve on stochastic gradient descent. AdaGrad was reviewed in § ..; its
main innovation is to set adaptive learning rates for each parameter by storing the sum
of squared gradients. Rather than using the sum over the entire training history, we can
keep a running estimate,
v(t)
=βv(t−)
+ ( − β)g
t,j,
where gt,j is the gradient with respect to parameter j at time t, and β ∈ [, ]. This term
places more emphasis on recent gradients, and is employed in the AdaDelta (Zeiler, )
and Adam (Kingma and Ba, ) optimizers. Online optimization and its theoretical
background are reviewed by Bottou et al. (). Early stopping, mentioned in § ..,
can help to avoid overﬁtting by terminating training after reaching a plateau in the per-
formance on a heldout validation set.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
Practical advice
The bag of tricks for training neural networks continues to grow, and
it is likely that there will be several new ones by the time you read this. Today, it is
standard practice to use gradient clipping, early stopping, and a sensible initialization of
parameters to small random values. More bells and whistles can be added as solutions to
speciﬁc problems — for example, if it is difﬁcult to ﬁnd a good learning rate for stochastic
gradient descent, then it may help to try a fancier optimizer with an adaptive learning
rate. Alternatively, if a method such as layer normalization is used by related models
in the research literature, you should probably consider it, especially if you are having
trouble matching published results. As with linear classiﬁers, it is important to evaluate
these decisions on a held-out development set, and not on the test set that will be used to
provide the ﬁnal measure of the model’s performance (see § ..).
Convolutional neural networks
A basic weakness of the bag-of-words model is its inability to account for the ways in
which words combine to create meaning, including even simple reversals such as not
pleasant, hardly a generous offer, and I wouldn’t mind missing the ﬂight. Computer vision
faces the related challenge of identifying the semantics of images from pixel features
that are uninformative in isolation. An earlier generation of computer vision research
focused on designing ﬁlters to aggregate local pixel-level features into more meaningful
representations, such as edges and corners (e.g., Canny, ). Similarly, earlier NLP re-
search attempted to capture multiword linguistic phenomena by hand-designed lexical
patterns (Hobbs et al., ). In both cases, the output of the ﬁlters and patterns could
then act as base features in a linear classiﬁer. But rather than designing these feature ex-
tractors by hand, a better approach is to learn them, using the magic of backpropagation.
This is the idea behind convolutional neural networks.
Following § .., deﬁne the base layer of a neural network as,
X() = Θ(x→z)[ew, ew, . . . , ewM ],
where ewm is a column vector of zeros, with a  at position wm. The base layer has dimen-
sion X() ∈ RKe×M, where Ke is the size of the word embeddings. To merge information
across adjacent words, we convolve X() with a set of ﬁlter matrices C(k) ∈ RKe×h. Convo-
lution is indicated by the symbol ∗, and is deﬁned,
bk +
X() =f(b + C ∗ X())
x()
k,m = f

n=
c(k)
k′,n × x()
k′,m+n−
k′=
Ke
where f is an activation function such as tanh or ReLU, and b is a vector of offsets. The
convolution operation slides the matrix C(k) across the columns of X(). At each position
m, we compute the elementwise product C(k) ⊙ X()
m:m+h−, and take the sum.
Jacob Eisenstein. Draft of November , .

.. CONVOLUTIONAL NEURAL NETWORKS
Kf
Kf
X()
pooling
prediction
convolution
Ke
X()

Figure .: A convolutional neural network for text classiﬁcation
A simple ﬁlter might compute a weighted average over nearby words,
C(k) =
. . .
. . .
. . .
 ,
thereby representing trigram units like not so unpleasant. In one-dimensional convolu-
tion, each ﬁlter matrix C(k) is constrained to have non-zero values only at row k (Kalch-
brenner et al., ). This means that each dimension of the word embedding is processed
by a separate ﬁlter, and it implies that Kf = Ke.
To deal with the beginning and end of the input, the base matrix X() may be padded
with h column vectors of zeros at the beginning and end; this is known as wide convolu-
tion. If padding is not applied, then the output from each layer will be h −  units smaller
than the input; this is known as narrow convolution. The ﬁlter matrices need not have
identical ﬁlter widths, so more generally we could write hk to indicate to width of ﬁlter
C(k). As suggested by the notation X(), multiple layers of convolution may be applied,
so that X(d) is the input to X(d+).
After D convolutional layers, we obtain a matrix representation of the document X(D) ∈
RKz×M. If the instances have variable lengths, it is necessary to aggregate over all M word
positions to obtain a ﬁxed-length representation. This can be done by a pooling operation,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
Figure .: A dilated convolutional neural network captures progressively larger context
through recursive application of the convolutional operator
such as max-pooling (Collobert et al., ) or average-pooling,
z = MaxPool(X(D))
zk = max

x(D)
k, , x(D)
k, , . . . x(D)
k,M

z = AvgPool(X(D))
zk =
m=
x(D)
k,m.
The vector z can now act as a layer in a feedforward network, culminating in a prediction
ˆy and a loss ℓ(i). The setup is shown in Figure ..
Just as in feedforward networks, the parameters (C(k), b, Θ) can be learned by back-
propagating from the classiﬁcation loss. This requires backpropagating through the max-
pooling operation, which is a discontinuous function of the input. But because we need
only a local gradient, backpropagation ﬂows only through the argmax m:
∂zk
otherwise.
x(D)
k,m = max

x(D)
k, , x(D)
k, , . . . x(D)
k,M

∂x(D)
k,m
The computer vision literature has produced a huge variety of convolutional archi-
tectures, and many of these innovations can be applied to text data. One avenue for
improvement is more complex pooling operations, such as k-max pooling (Kalchbrenner
et al., ), which returns a matrix of the k largest values for each ﬁlter. Another innova-
tion is the use of dilated convolution to build multiscale representations (Yu and Koltun,
). At each layer, the convolutional operator applied in strides, skipping ahead by s
steps after each feature. As we move up the hierarchy, each layer is s times smaller than
the layer below it, effectively summarizing the input (Kalchbrenner et al., ; Strubell
et al., ). This idea is shown in Figure .. Multi-layer convolutional networks can also
be augmented with “shortcut” connections, as in the residual network from § .. (John-
son and Zhang, ).
Jacob Eisenstein. Draft of November , .

.. CONVOLUTIONAL NEURAL NETWORKS
Additional resources
The deep learning textbook by Goodfellow et al. () covers many of the topics in this
chapter in more detail. For a comprehensive review of neural networks in natural lan-
guage processing, see Goldberg (b). A seminal work on deep learning in natural
language processing is the aggressively titled “Natural Language Processing (Almost)
from Scratch”, which uses convolutional neural networks to perform a range of language
processing tasks (Collobert et al., ), although there is earlier work (e.g., Henderson,
). This chapter focuses on feedforward and convolutional neural networks, but recur-
rent neural networks are one of the most important deep learning architectures for natural
language processing. They are covered extensively in chapters  and .
The role of deep learning in natural language processing research has caused angst
in some parts of the natural language processing research community (e.g., Goldberg,
a), especially as some of the more zealous deep learning advocates have argued that
end-to-end learning from “raw” text can eliminate the need for linguistic constructs such
as sentences, phrases, and even words (Zhang et al., , originally titled “Text under-
standing from scratch”). These developments were surveyed by Manning (). While
reports of the demise of linguistics in natural language processing remain controversial
at best, deep learning and backpropagation have become ubiquitous in both research and
applications.
Exercises
. Figure . shows the computation graph for a feedforward neural network with one
layer.
a) Update the computation graph to include a residual connection between x and
z.
b) Update the computation graph to include a highway connection between x
and z.
. Prove that the softmax and sigmoid functions are equivalent when the number of
possible labels is two. Speciﬁcally, for any Θ(z→y) (omitting the offset b for simplic-
ity), show how to construct a vector of weights θ such that,
SoftMax(Θ(z→y)z)[] = σ(θ  z).
. Convolutional neural networks often aggregate across words by using max-pooling
(Equation . in § .). A potential concern is that there is zero gradient with re-
spect to the parts of the input that are not included in the maximum. The following
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . NONLINEAR CLASSIFICATION
questions consider the gradient with respect to an element of the input, x()
m,k, and
they assume that all parameters are independently distributed.
a) First consider a minimal network, with z = MaxPool(X()). What is the prob-
ability that the gradient
∂ℓ
∂x()
m,k
is non-zero?
b) Now consider a two-level network, with X() = f(b + C ∗ X()). Express the
probability that the gradient
∂ℓ
∂x()
m,k
is non-zero, in terms of the input length M,
the ﬁlter size n, and the number of ﬁlters Kf.
c) Using a calculator, work out the probability for the case M = , n = , Kf =
d) Now consider a three-level network, X() = f(b + C ∗ X()). Give the general
equation for the probability that
∂ℓ
∂x()
m,k
is non-zero, and compute the numerical
probability for the scenario in the previous part, assuming Kf =  and n =
at both levels.
. Design a feedforward network to compute the XOR function:
f(x, x) =

x = , x =
x = , x =
x = , x =
x = , x =
Your network should have a single output node which uses the Sign activation func-

tion, f(x) =
x >
x ≤ . . Use a single hidden layer, with ReLU activation func-
tions. Describe all weights and offsets.
. Consider the same network as above (with ReLU activations for the hidden layer),
with an arbitrary differentiable loss function ℓ(y(i), ˜y), where ˜y is the activation of
the output node. Suppose all weights and offsets are initialized to zero. Show that
gradient descent will not learn the desired function from this initialization.
. The simplest solution to the previous problem relies on the use of the ReLU activa-
tion function at the hidden layer. Now consider a network with arbitrary activations
on the hidden layer. Show that if the initial weights are any uniform constant, then
gradient descent will not learn the desired function from this initialization.
. Consider a network in which: the base features are all binary, x ∈ {, }M; the
hidden layer activation function is sigmoid, zk = σ(θk  x); and the initial weights
are sampled independently from a standard normal distribution, θj,k ∼ N(, ).
Jacob Eisenstein. Draft of November , .

.. CONVOLUTIONAL NEURAL NETWORKS
Show how the probability of a small initial gradient on any weight,
∂zk
∂θj,k < α,
depends on the size of the input M. Hint: use the lower bound,
Pr(σ(θk  x) × ( − σ(θk  x)) < α)
Pr(σ(θk  x) < α),
and relate this probability to the variance V [θk  x].
Design an alternative initialization that removes this dependence.
. The ReLU activation function can lead to “dead neurons”, which can never be acti-
vated on any input. Consider the following two-layer feedforward network with a
scalar output y:
zi =ReLU(θ(x→z)
x + bi)
y =θ(z→y)  z.
Suppose that the input is a binary vector of observations, x ∈ {, }D.
a) Under what condition is node zi “dead”? Your answer should be expressed in
terms of the parameters θ(x→z)
and bi.
b) Suppose that the gradient of the loss on a given instance is ∂ℓ
∂y = . Derive the
gradients ∂ℓ
∂bi and
∂ℓ
∂θ(x→z)
j,i
for such an instance.
c) Using your answers to the previous two parts, explain why a dead neuron can
never be brought back to life during gradient-based learning.
. Suppose that the parameters Θ = {Θ(x→z), Θ(z → y), b} are a local optimum of a
feedforward network in the following sense: there exists some ϵ >  such that,

||˜Θ(x→z) − Θ(x→z)||
F + ||˜Θ(z→y) − Θ(z→y)||
F + ||˜b − b||
< ϵ

L(˜Θ) > L(Θ)

Deﬁne the function π as a permutation on the hidden units, as described in § ..,
so that for any Θ, L(Θ) = L(Θπ). Prove that if a feedforward network has a local
optimum in the sense of Equation ., then its loss is not a convex function of the
parameters Θ, using the deﬁnition of convexity from § .
. Consider a network with a single hidden layer, and a single output,
y = θ(z→y)  g(Θ(x→z)x).
Assume that g is the ReLU function. Show that for any matrix of weights Θ(x→z), it
is permissible to rescale each row to have a norm of one, because an identical output
can be obtained by ﬁnding a corresponding rescaling of θ(z→y).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Chapter
Linguistic applications of
classiﬁcation
Having covered several techniques for classiﬁcation, this chapter shifts the focus from
mathematics to linguistic applications. Later in the chapter, we will consider the design
decisions involved in text classiﬁcation, as well as best practices for evaluation.
Sentiment and opinion analysis
A popular application of text classiﬁcation is to automatically determine the sentiment
or opinion polarity of documents such as product reviews and social media posts. For
example, marketers are interested to know how people respond to advertisements, ser-
vices, and products (Hu and Liu, ); social scientists are interested in how emotions
are affected by phenomena such as the weather (Hannak et al., ), and how both opin-
ions and emotions spread over social networks (Coviello et al., ; Miller et al., ).
In the ﬁeld of digital humanities, literary scholars track plot structures through the ﬂow
of sentiment across a novel (Jockers, ).
Sentiment analysis can be framed as a direct application of document classiﬁcation,
assuming reliable labels can be obtained. In the simplest case, sentiment analysis is a
two or three-class problem, with sentiments of POSITIVE, NEGATIVE, and possibly NEU-
TRAL. Such annotations could be annotated by hand, or obtained automatically through
a variety of means:
Tweets containing happy emoticons can be marked as positive, sad emoticons as
negative (Read, ; Pak and Paroubek, ).
Comprehensive surveys on sentiment analysis and related problems are offered by Pang and Lee ()
and Liu ().
CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
Reviews with four or more stars can be marked as positive, three or fewer stars as
negative (Pang et al., ).
Statements from politicians who are voting for a given bill are marked as positive
(towards that bill); statements from politicians voting against the bill are marked as
negative (Thomas et al., ).
The bag-of-words model is a good ﬁt for sentiment analysis at the document level: if
the document is long enough, we would expect the words associated with its true senti-
ment to overwhelm the others. Indeed, lexicon-based sentiment analysis avoids machine
learning altogether, and classiﬁes documents by counting words against positive and neg-
ative sentiment word lists (Taboada et al., ).
Lexicon-based classiﬁcation is less effective for short documents, such as single-sentence
reviews or social media posts. In these documents, linguistic issues like negation and ir-
realis (Polanyi and Zaenen, ) — events that are hypothetical or otherwise non-factual
— can make bag-of-words classiﬁcation ineffective. Consider the following examples:
a. That’s not bad for the ﬁrst day.
b. This is not the worst thing that can happen.
c. It would be nice if you acted like you understood.
d. There is no reason at all to believe that the polluters are suddenly going to
become reasonable. (Wilson et al., )
e. This ﬁlm should be brilliant. The actors are ﬁrst grade. Stallone plays a
happy, wonderful man. His sweet wife is beautiful and adores him. He has
a fascinating gift for living life fully. It sounds like a great plot, however, the
ﬁlm is a failure. (Pang et al., )
A minimal solution is to move from a bag-of-words model to a bag-of-bigrams model,
where each base feature is a pair of adjacent words, e.g.,
(that’s, not), (not, bad), (bad, for), . . .
Bigrams can handle relatively straightforward cases, such as when an adjective is immedi-
ately negated; trigrams would be required to extend to larger contexts (e.g., not the worst).
But this approach will not scale to more complex examples like (.d) and (.e). More
sophisticated solutions try to account for the syntactic structure of the sentence (Wilson
et al., ; Socher et al., ), or apply more complex classiﬁers such as convolutional
neural networks (Kim, ), which are described in chapter .
Related problems
Subjectivity
Closely related to sentiment analysis is subjectivity detection, which re-
quires identifying the parts of a text that express subjective opinions, as well as other non-
Jacob Eisenstein. Draft of November , .

.. SENTIMENT AND OPINION ANALYSIS
factual content such as speculation and hypotheticals (Riloff and Wiebe, ). This can be
done by treating each sentence as a separate document, and then applying a bag-of-words
classiﬁer: indeed, Pang and Lee () do exactly this, using a training set consisting of
(mostly) subjective sentences gathered from movie reviews, and (mostly) objective sen-
tences gathered from plot descriptions. They augment this bag-of-words model with a
graph-based algorithm that encourages nearby sentences to have the same subjectivity
label.
Stance classiﬁcation
In debates, each participant takes a side: for example, advocating
for or against proposals like adopting a vegetarian lifestyle or mandating free college ed-
ucation. The problem of stance classiﬁcation is to identify the author’s position from the
text of the argument. In some cases, there is training data available for each position,
so that standard document classiﬁcation techniques can be employed. In other cases, it
sufﬁces to classify each document as whether it is in support or opposition of the argu-
ment advanced by a previous document (Anand et al., ). In the most challenging
case, there is no labeled data for any of the stances, so the only possibility is group docu-
ments that advocate the same position (Somasundaran and Wiebe, ). This is a form
of unsupervised learning, discussed in chapter .
Targeted sentiment analysis
The expression of sentiment is often more nuanced than a
simple binary label. Consider the following examples:
a. The vodka was good, but the meat was rotten.
b. Go to Heaven for the climate, Hell for the company. –Mark Twain
These statements display a mixed overall sentiment: positive towards some entities (e.g.,
the vodka), negative towards others (e.g., the meat). Targeted sentiment analysis seeks to
identify the writer’s sentiment towards speciﬁc entities (Jiang et al., ). This requires
identifying the entities in the text and linking them to speciﬁc sentiment words — much
more than we can do with the classiﬁcation-based approaches discussed thus far. For
example, Kim and Hovy () analyze sentence-internal structure to determine the topic
of each sentiment expression.
Aspect-based opinion mining seeks to identify the sentiment of the author of a review
towards predeﬁned aspects such as PRICE and SERVICE, or, in the case of (.b), CLIMATE
and COMPANY (Hu and Liu, ). If the aspects are not deﬁned in advance, it may again
be necessary to employ unsupervised learning methods to identify them (e.g., Branavan
et al., ).
Emotion classiﬁcation
While sentiment analysis is framed in terms of positive and neg-
ative categories, psychologists generally regard emotion as more multifaceted. For ex-
ample, Ekman () argues that there are six basic emotions — happiness, surprise, fear,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
sadness, anger, and contempt — and that they are universal across human cultures. Alm
et al. () build a linear classiﬁer for recognizing the emotions expressed in children’s
stories. The ultimate goal of this work was to improve text-to-speech synthesis, so that
stories could be read with intonation that reﬂected the emotional content. They used bag-
of-words features, as well as features capturing the story type (e.g., jokes, folktales), and
structural features that reﬂect the position of each sentence in the story. The task is difﬁ-
cult: even human annotators frequently disagreed with each other, and the best classiﬁers
achieved accuracy between -%.
Alternative approaches to sentiment analysis
Regression
A more challenging version of sentiment analysis is to determine not just
the class of a document, but its rating on a numerical scale (Pang and Lee, ). If the
scale is continuous, it is most natural to apply regression, identifying a set of weights θ
that minimize the squared error of a predictor ˆy = θ  x + b, where b is an offset. This
approach is called linear regression, and sometimes least squares, because the regression
coefﬁcients θ are determined by minimizing the squared error, (y − ˆy). If the weights are
regularized using a penalty λ||θ||
, then it is ridge regression. Unlike logistic regression,
both linear regression and ridge regression can be solved in closed form as a system of
linear equations.
Ordinal ranking
In many problems, the labels are ordered but discrete: for example,
product reviews are often integers on a scale of  − , and grades are on a scale of A − F.
Such problems can be solved by discretizing the score θ  x into “ranks”,
ˆy = argmax
r: θx≥br
r,
where b = [b = −∞, b, b, . . . , bK] is a vector of boundaries. It is possible to learn the
weights and boundaries simultaneously, using a perceptron-like algorithm (Crammer and
Singer, ).
Lexicon-based classiﬁcation
Sentiment analysis is one of the only NLP tasks where
hand-crafted feature weights are still widely employed. In lexicon-based classiﬁcation (Taboada
et al., ), the user creates a list of words for each label, and then classiﬁes each docu-
ment based on how many of the words from each list are present. In our linear classiﬁca-
tion framework, this is equivalent to choosing the following weights:
θy,j =
j ∈ Ly
otherwise,
Jacob Eisenstein. Draft of November , .

.. WORD SENSE DISAMBIGUATION
where Ly is the lexicon for label y. Compared to the machine learning classiﬁers discussed
in the previous chapters, lexicon-based classiﬁcation may seem primitive. However, su-
pervised machine learning relies on large annotated datasets, which are time-consuming
and expensive to produce. If the goal is to distinguish two or more categories in a new
domain, it may be simpler to start by writing down a list of words for each category.
An early lexicon was the General Inquirer (Stone, ). Today, popular sentiment lexi-
cons include SENTIWORDNET (Esuli and Sebastiani, ) and an evolving set of lexicons
from Liu (). For emotions and more ﬁne-grained analysis, Linguistic Inquiry and Word
Count (LIWC) provides a set of lexicons (Tausczik and Pennebaker, ). The MPQA lex-
icon indicates the polarity (positive or negative) of  terms, as well as whether they are
strongly or weakly subjective (Wiebe et al., ). A comprehensive comparison of senti-
ment lexicons is offered by Ribeiro et al. (). Given an initial seed lexicon, it is possible
to automatically expand the lexicon by looking for words that frequently co-occur with
words in the seed set (Hatzivassiloglou and McKeown, ; Qiu et al., ).
Word sense disambiguation
Consider the the following headlines:
a. Iraqi head seeks arms
b. Prostitutes appeal to Pope
c. Drunk gets nine years in violin case
These headlines are ambiguous because they contain words that have multiple mean-
ings, or senses. Word sense disambiguation is the problem of identifying the intended
sense of each word token in a document. Word sense disambiguation is part of a larger
ﬁeld of research called lexical semantics, which is concerned with meanings of the words.
At a basic level, the problem of word sense disambiguation is to identify the correct
sense for each word token in a document. Part-of-speech ambiguity (e.g., noun versus
verb) is usually considered to be a different problem, to be solved at an earlier stage.
From a linguistic perspective, senses are not properties of words, but of lemmas, which
are canonical forms that stand in for a set of inﬂected words. For example, arm/N is a
lemma that includes the inﬂected form arms/N — the /N indicates that it we are refer-
ring to the noun, and not its homonym arm/V, which is another lemma that includes
the inﬂected verbs (arm/V, arms/V, armed/V, arming/V). Therefore, word sense disam-
biguation requires ﬁrst identifying the correct part-of-speech and lemma for each token,
These examples, and many more, can be found at http://www.ling.upenn.edu/˜beatrice/
humor/headlines.html
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
and then choosing the correct sense from the inventory associated with the corresponding
lemma. (Part-of-speech tagging is discussed in § ..)
How many word senses?
Words sometimes have many more than two senses, as exempliﬁed by the word serve:
[FUNCTION]: The tree stump served as a table
[CONTRIBUTE TO]: His evasive replies only served to heighten suspicion
[PROVIDE]: We serve only the rawest ﬁsh
[ENLIST]: She served in an elite combat unit
[JAIL]: He served six years for a crime he didn’t commit
[LEGAL]: They were served with subpoenas
These sense distinctions are annotated in WORDNET (http://wordnet.princeton.
edu), a lexical semantic database for English. WORDNET consists of roughly ,
synsets, which are groups of lemmas (or phrases) that are synonymous. An example
synset is {chump, fool, sucker, mark}, where the superscripts index the sense of each
lemma that is included in the synset: for example, there are at least eight other senses of
mark that have different meanings, and are not part of this synset. A lemma is polysemous
if it participates in multiple synsets.
WORDNET deﬁnes the scope of the word sense disambiguation problem, and, more
generally, formalizes lexical semantic knowledge of English. (WordNets have been cre-
ated for a few dozen other languages, at varying levels of detail.) Some have argued
that WordNet’s sense granularity is too ﬁne (Ide and Wilks, ); more fundamentally,
the premise that word senses can be differentiated in a task-neutral way has been criti-
cized as linguistically na¨ıve (Kilgarriff, ). One way of testing this question is to ask
whether people tend to agree on the appropriate sense for example sentences: accord-
ing to Mihalcea et al. (), people agree on roughly % of examples using WordNet
senses; far better than chance, but less than agreement on other tasks, such as sentiment
annotation (Wilson et al., ).
*Other lexical semantic relations
Besides synonymy, WordNet also describes many
other lexical semantic relationships, including:
antonymy: x means the opposite of y, e.g. FRIEND-ENEMY;
Navigli () provides a survey of approaches for word-sense disambiguation.
Several of the examples are adapted from WORDNET (Fellbaum, ).
Jacob Eisenstein. Draft of November , .

.. WORD SENSE DISAMBIGUATION
hyponymy: x is a special case of y, e.g.
RED-COLOR; the inverse relationship is
hypernymy;
meronymy: x is a part of y, e.g., WHEEL-BICYCLE; the inverse relationship is holonymy.
Classiﬁcation of these relations can be performed by searching for characteristic pat-
terns between pairs of words, e.g., X, such as Y, which signals hyponymy (Hearst, ),
or X but Y, which signals antonymy (Hatzivassiloglou and McKeown, ). Another ap-
proach is to analyze each term’s distributional statistics (the frequency of its neighboring
words). Such approaches are described in detail in chapter .
Word sense disambiguation as classiﬁcation
How can we tell living plants from manufacturing plants? The context is often critical:
a. Town ofﬁcials are hoping to attract new manufacturing plants through weak-
ened environmental regulations.
b. The endangered plants play an important role in the local ecosystem.
It is possible to build a feature vector using the bag-of-words representation, by treat-
ing each context as a pseudo-document. The feature function is then,
f((plant, The endangered plants play an ...), y) =
{(the, y) : , (endangered, y) : , (play, y) : , (an, y) : , . . .}
As in document classiﬁcation, many of these features are irrelevant, but a few are very
strong predictors. In this example, the context word endangered is a strong signal that
the intended sense is biology rather than manufacturing. We would therefore expect a
learning algorithm to assign high weight to (endangered, BIOLOGY), and low weight to
(endangered, MANUFACTURING).
It may also be helpful to go beyond the bag-of-words: for example, one might encode
the position of each context word with respect to the target, e.g.,
f((bank, I went to the bank to deposit my paycheck), y) =
{(i − , went, y) : , (i + , deposit, y) : , (i + , paycheck, y) : }
These are called collocation features, and they give more information about the speciﬁc
role played by each context word. This idea can be taken further by incorporating addi-
tional syntactic information about the grammatical role played by each context feature,
such as the dependency path (see chapter ).
The context bag-of-words can be also used be used to perform word-sense disambiguation without
machine learning: the Lesk () algorithm selects the word sense whose dictionary deﬁnition best overlaps
the local context.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
Using such features, a classiﬁer can be trained from labeled data. A semantic concor-
dance is a corpus in which each open-class word (nouns, verbs, adjectives, and adverbs)
is tagged with its word sense from the target dictionary or thesaurus. SemCor is a seman-
tic concordance built from K tokens of the Brown corpus (Francis and Kucera, ),
annotated as part of the WORDNET project (Fellbaum, ). SemCor annotations look
like this:
As of Sunday
N night
N there was
V no word
N ...,
with the superscripts indicating the annotated sense of each polysemous word, and the
subscripts indicating the part-of-speech.
As always, supervised classiﬁcation is only possible if enough labeled examples can
be accumulated. This is difﬁcult in word sense disambiguation, because each polysemous
lemma requires its own training set: having a good classiﬁer for the senses of serve is no
help towards disambiguating plant. For this reason, unsupervised and semi-supervised
methods are particularly important for word sense disambiguation (e.g., Yarowsky, ).
These methods will be discussed in chapter . Unsupervised methods typically lean on
the heuristic of “one sense per discourse”, which means that a lemma will usually have
a single, consistent sense throughout any given document (Gale et al., ). Based on
this heuristic, we can propagate information from high-conﬁdence instances to lower-
conﬁdence instances in the same document (Yarowsky, ). Semi-supervised methods
combine labeled and unlabeled data, and are discussed in more detail in chapter .
Design decisions for text classiﬁcation
Text classiﬁcation involves a number of design decisions. In some cases, the design deci-
sion is clear from the mathematics: if you are using regularization, then a regularization
weight λ must be chosen. Other decisions are more subtle, arising only in the low level
“plumbing” code that ingests and processes the raw data. Such decision can be surpris-
ingly consequential for classiﬁcation accuracy.
What is a word?
The bag-of-words representation presupposes that extracting a vector of word counts
from text is unambiguous. But text documents are generally represented as a sequences of
characters (in an encoding such as ascii or unicode), and the conversion to bag-of-words
presupposes a deﬁnition of the “words” that are to be counted.
Jacob Eisenstein. Draft of November , .

.. DESIGN DECISIONS FOR TEXT CLASSIFICATION
Whitespace
Isn’t
Ahab,
Ahab?
Treebank
Is
n’t
Ahab
Ahab
Tweet
Isn’t
Ahab
Ahab
TokTok (Dehdari, )
Isn
Ahab
Ahab
Figure .: The output of four NLTK tokenizers, applied to the string Isn’t Ahab, Ahab? ;)
Tokenization
The ﬁrst subtask for constructing a bag-of-words vector is tokenization: converting the
text from a sequence of characters to a sequence of word!tokens. A simple approach is
to deﬁne a subset of characters as whitespace, and then split the text on these tokens.
However, whitespace-based tokenization is not ideal: we may want to split conjunctions
like isn’t and hyphenated phrases like prize-winning and half-asleep, and we likely want
to separate words from commas and periods that immediately follow them. At the same
time, it would be better not to split abbreviations like U.S. and Ph.D. In languages with
Roman scripts, tokenization is typically performed using regular expressions, with mod-
ules designed to handle each of these cases. For example, the NLTK package includes a
number of tokenizers (Loper and Bird, ); the outputs of four of the better-known tok-
enizers are shown in Figure .. Social media researchers have found that emoticons and
other forms of orthographic variation pose new challenges for tokenization, leading to the
development of special purpose tokenizers to handle these phenomena (O’Connor et al.,
Tokenization is a language-speciﬁc problem, and each language poses unique chal-
lenges. For example, Chinese does not include spaces between words, nor any other
consistent orthographic markers of word boundaries. A “greedy” approach is to scan the
input for character substrings that are in a predeﬁned lexicon. However, Xue et al. ()
notes that this can be ambiguous, since many character sequences could be segmented in
multiple ways. Instead, he trains a classiﬁer to determine whether each Chinese character,
or hanzi, is a word boundary. More advanced sequence labeling methods for word seg-
mentation are discussed in § .. Similar problems can occur in languages with alphabetic
scripts, such as German, which does not include whitespace in compound nouns, yield-
ing examples such as Freundschaftsbezeigungen (demonstration of friendship) and Dilet-
tantenaufdringlichkeiten (the importunities of dilettantes). As Twain () argues, “These
things are not words, they are alphabetic processions.” Social media raises similar problems
for English and other languages, with hashtags such as #TrueLoveInFourWords requiring
decomposition for analysis (Brun and Roux, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
Original
The
Williams
sisters
are
leaving
this
tennis
centre
Porter stemmer
the
william
sister
are
leav
thi
tenni
centr
Lancaster stemmer
the
william
sist
ar
leav
thi
ten
cent
WordNet lemmatizer
The
Williams
sister
are
leaving
this
tennis
centre
Figure .: Sample outputs of the Porter () and Lancaster (Paice, ) stemmers, and
the WORDNET lemmatizer
Text normalization
After splitting the text into tokens, the next question is which tokens are really distinct.
Is it necessary to distinguish great, Great, and GREAT? Sentence-initial capitalization may
be irrelevant to the classiﬁcation task. Going further, the complete elimination of case
distinctions will result in a smaller vocabulary, and thus smaller feature vectors. However,
case distinctions might be relevant in some situations: for example, apple is a delicious
pie ﬁlling, while Apple is a company that specializes in proprietary dongles and power
adapters.
For Roman script, case conversion can be performed using unicode string libraries.
Many scripts do not have case distinctions (e.g., the Devanagari script used for South
Asian languages, the Thai alphabet, and Japanese kana), and case conversion for all scripts
may not be available in every programming environment. (Unicode support is an im-
portant distinction between Python’s versions  and , and is a good reason for mi-
grating to Python  if you have not already done so. Compare the output of the code
"\`a l\’hˆotel".upper() in the two language versions.)
Case conversion is a type of text normalization, which refers to string transforma-
tions that remove distinctions that are irrelevant to downstream applications (Sproat et al.,
). Other forms of normalization include the standardization of numbers (e.g., , to
) and dates (e.g., August ,  to //). Depending on the application, it may
even be worthwhile to convert all numbers and dates to special tokens, !NUM and !DATE.
In social media, there are additional orthographic phenomena that may be normalized,
such as expressive lengthening, e.g., cooooool (Aw et al., ; Yang and Eisenstein, ).
Similarly, historical texts feature spelling variations that may need to be normalized to a
contemporary standard form (Baron and Rayson, ).
A more extreme form of normalization is to eliminate inﬂectional afﬁxes, such as the
-ed and -s sufﬁxes in English. On this view, whale, whales, and whaling all refer to the
same underlying concept, so they should be grouped into a single feature. A stemmer is
a program for eliminating afﬁxes, usually by applying a series of regular expression sub-
stitutions. Character-based stemming algorithms are necessarily approximate, as shown
in Figure .: the Lancaster stemmer incorrectly identiﬁes -ers as an inﬂectional sufﬁx of
Jacob Eisenstein. Draft of November , .

.. DESIGN DECISIONS FOR TEXT CLASSIFICATION
Pang and Lee Movie Reviews (English)
MAC-Morpho Corpus (Brazilian Portuguese)
Token coverage
Token coverage

Vocabulary size
Vocabulary size
(a) Movie review data in English
(b) News articles in Brazilian Portuguese
Figure .: Tradeoff between token coverage (y-axis) and vocabulary size, on the NLTK
movie review dataset, after sorting the vocabulary by decreasing frequency.
The red
dashed lines indicate %, %, and % coverage.
sisters (by analogy to ﬁx/ﬁxers), and both stemmers incorrectly identify -s as a sufﬁx of this
and Williams. Fortunately, even inaccurate stemming can improve bag-of-words classiﬁ-
cation models, by merging related strings and thereby reducing the vocabulary size.
Accurately handling irregular orthography requires word-speciﬁc rules. Lemmatizers
are systems that identify the underlying lemma of a given wordform. They must avoid the
over-generalization errors of the stemmers in Figure ., and also handle more complex
transformations, such as geese→goose. The output of the WordNet lemmatizer is shown in
the ﬁnal line of Figure .. Both stemming and lemmatization are language-speciﬁc: an
English stemmer or lemmatizer is of little use on a text written in another language. The
discipline of morphology relates to the study of word-internal structure, and is described
in more detail in § ...
The value of normalization depends on the data and the task.
Normalization re-
duces the size of the feature space, which can help in generalization. However, there
is always the risk of merging away linguistically meaningful distinctions. In supervised
machine learning, regularization and smoothing can play a similar role to normalization
— preventing the learner from overﬁtting to rare features — while avoiding the language-
speciﬁc engineering required for accurate normalization. In unsupervised scenarios, such
as content-based information retrieval (Manning et al., ) and topic modeling (Blei
et al., ), normalization is more critical.
How many words?
Limiting the size of the feature vector reduces the memory footprint of the resulting mod-
els, and increases the speed of prediction. Normalization can help to play this role, but
a more direct approach is simply to limit the vocabulary to the N most frequent words
in the dataset. For example, in the MOVIE-REVIEWS dataset provided with NLTK (origi-
nally from Pang et al., ), there are , word types, and .M tokens. As shown
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
in Figure .a, the most frequent  word types cover % of all tokens, offering an
order-of-magnitude reduction in the model size. Such ratios are language-speciﬁc: in for
example, in the Brazilian Portuguese Mac-Morpho corpus (Alu´ısio et al., ), attain-
ing % coverage requires more than  word types (Figure .b). This reﬂects the
morphological complexity of Portuguese, which includes many more inﬂectional sufﬁxes
than English.
Eliminating rare words is not always advantageous for classiﬁcation performance: for
example, names, which are typically rare, play a large role in distinguishing topics of news
articles. Another way to reduce the size of the feature space is to eliminate stopwords such
as the, to, and and, which may seem to play little role in expressing the topic, sentiment,
or stance. This is typically done by creating a stoplist (e.g., NLTK.CORPUS.STOPWORDS),
and then ignoring all terms that match the list. However, corpus linguists and social psy-
chologists have shown that seemingly inconsequential words can offer surprising insights
about the author or nature of the text (Biber, ; Chung and Pennebaker, ). Further-
more, high-frequency words are unlikely to cause overﬁtting in discriminative classiﬁers.
As with normalization, stopword ﬁltering is more important for unsupervised problems,
such as term-based document retrieval.
Another alternative for controlling model size is feature hashing (Weinberger et al.,
). Each feature is assigned an index using a hash function. If a hash function that
permits collisions is chosen (typically by taking the hash output modulo some integer),
then the model can be made arbitrarily small, as multiple features share a single weight.
Because most features are rare, accuracy is surprisingly robust to such collisions (Ganchev
and Dredze, ).
Count or binary?
Finally, we may consider whether we want our feature vector to include the count of each
word, or its presence. This gets at a subtle limitation of linear classiﬁcation: it’s worse to
have two failures than one, but is it really twice as bad? Motivated by this intuition, Pang
et al. () use binary indicators of presence or absence in the feature vector: fj(x, y) ∈
{, }. They ﬁnd that classiﬁers trained on these binary vectors tend to outperform feature
vectors based on word counts. One explanation is that words tend to appear in clumps:
if a word has appeared once in a document, it is likely to appear again (Church, ).
These subsequent appearances can be attributed to this tendency towards repetition, and
thus provide little additional information about the class label of the document.
Evaluating classiﬁers
In any supervised machine learning application, it is critical to reserve a held-out test set.
This data should be used for only one purpose: to evaluate the overall accuracy of a single
Jacob Eisenstein. Draft of November , .

.. EVALUATING CLASSIFIERS
classiﬁer. Using this data more than once would cause the estimated accuracy to be overly
optimistic, because the classiﬁer would be customized to this data, and would not perform
as well as on unseen data in the future. It is usually necessary to set hyperparameters or
perform feature selection, so you may need to construct a tuning or development set for
this purpose, as discussed in § ...
There are a number of ways to evaluate classiﬁer performance. The simplest is accu-
racy: the number of correct predictions, divided by the total number of instances,
acc(y, ˆy) =
δ(y(i) = ˆy).
Exams are usually graded by accuracy. Why are other metrics necessary? The main
reason is class imbalance. Suppose you are building a classiﬁer to detect whether an
electronic health record (EHR) describes symptoms of a rare disease, which appears in
only % of all documents in the dataset. A classiﬁer that reports ˆy = NEGATIVE for
all documents would achieve % accuracy, but would be practically useless. We need
metrics that are capable of detecting the classiﬁer’s ability to discriminate between classes,
even when the distribution is skewed.
One solution is to build a balanced test set, in which each possible label is equally rep-
resented. But in the EHR example, this would mean throwing away % of the original
dataset! Furthermore, the detection threshold itself might be a design consideration: in
health-related applications, we might prefer a very sensitive classiﬁer, which returned a
positive prediction if there is even a small chance that y(i) = POSITIVE. In other applica-
tions, a positive result might trigger a costly action, so we would prefer a classiﬁer that
only makes positive predictions when absolutely certain. We need additional metrics to
capture these characteristics.
Precision, recall, and F -MEASURE
For any label (e.g., positive for presence of symptoms of a disease), there are two possible
errors:
False positive: the system incorrectly predicts the label.
False negative: the system incorrectly fails to predict the label.
Similarly, for any label, there are two ways to be correct:
True positive: the system correctly predicts the label.
True negative: the system correctly predicts that the label does not apply to this
instance.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
Classiﬁers that make a lot of false positives have low precision: they predict the label
even when it isn’t there. Classiﬁers that make a lot of false negatives have low recall: they
fail to predict the label, even when it is there. These metrics distinguish these two sources
of error, and are deﬁned formally as:
RECALL(y, ˆy, k) =
TP
TP + FN
PRECISION(y, ˆy, k) =
TP
TP + FP.
Recall and precision are both conditional likelihoods of a correct prediction, which is why
their numerators are the same. Recall is conditioned on k being the correct label, y(i) = k,
so the denominator sums over true positive and false negatives. Precision is conditioned
on k being the prediction, so the denominator sums over true positives and false positives.
Note that true negatives are not considered in either statistic. The classiﬁer that labels
every document as “negative” would achieve zero recall; precision would be
Recall and precision are complementary. A high-recall classiﬁer is preferred when
false positives are cheaper than false negatives: for example, in a preliminary screening
for symptoms of a disease, the cost of a false positive might be an additional test, while a
false negative would result in the disease going untreated. Conversely, a high-precision
classiﬁer is preferred when false positives are more expensive: for example, in spam de-
tection, a false negative is a relatively minor inconvenience, while a false positive might
mean that an important message goes unread.
The F -MEASURE combines recall and precision into a single metric, using the har-
monic mean:
F -MEASURE(y, ˆy, k) = rp
r + p,
where r is recall and p is precision.
Evaluating multi-class classiﬁcation
Recall, precision, and F -MEASURE are deﬁned with
respect to a speciﬁc label k. When there are multiple labels of interest (e.g., in word sense
disambiguation or emotion classiﬁcation), it is necessary to combine the F -MEASURE
across each class. Macro F -MEASURE is the average F -MEASURE across several classes,
Macro-F(y, ˆy) =
|K|
k∈K
F -MEASURE(y, ˆy, k)
F -MEASURE is sometimes called F, and generalizes to Fβ = (+β)rp
βp+r . The β parameter can be tuned to
emphasize recall or precision.
Jacob Eisenstein. Draft of November , .

.. EVALUATING CLASSIFIERS
True positive rate
AUC=.
AUC=.
AUC=.
False positive rate
Figure .: ROC curves for three classiﬁers of varying discriminative power, measured by
AUC (area under the curve)
In multi-class problems with unbalanced class distributions, the macro F -MEASURE is a
balanced measure of how well the classiﬁer recognizes each class. In micro F -MEASURE,
we compute true positives, false positives, and false negatives for each class, and then add
them up to compute a single recall, precision, and F -MEASURE. This metric is balanced
across instances rather than classes, so it weights each class in proportion to its frequency
— unlike macro F -MEASURE, which weights each class equally.
Threshold-free metrics
In binary classiﬁcation problems, it is possible to trade off between recall and precision by
adding a constant “threshold” to the output of the scoring function. This makes it possible
to trace out a curve, where each point indicates the performance at a single threshold. In
the receiver operating characteristic (ROC) curve, the x-axis indicates the false positive
rate,
FP
FP+TN, and the y-axis indicates the recall, or true positive rate. A perfect classiﬁer
attains perfect recall without any false positives, tracing a “curve” from the origin (,) to
the upper left corner (,), and then to (,). In expectation, a non-discriminative classiﬁer
traces a diagonal line from the origin (,) to the upper right corner (,). Real classiﬁers
tend to fall between these two extremes. Examples are shown in Figure ..
The ROC curve can be summarized in a single number by taking its integral, the area
under the curve (AUC). The AUC can be interpreted as the probability that a randomly-
selected positive example will be assigned a higher score by the classiﬁer than a randomly-
The name “receiver operator characteristic” comes from the metric’s origin in signal processing applica-
tions (Peterson et al., ). Other threshold-free metrics include precision-recall curves, precision-at-k, and
balanced F -MEASURE; see Manning et al. () for more details.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
selected negative example. A perfect classiﬁer has AUC =  (all positive examples score
higher than all negative examples); a non-discriminative classiﬁer has AUC = . (given
a randomly selected positive and negative example, either could score higher with equal
probability); a perfectly wrong classiﬁer would have AUC =  (all negative examples score
higher than all positive examples). One advantage of AUC in comparison to F -MEASURE
is that the baseline rate of . does not depend on the label distribution.
Classiﬁer comparison and statistical signiﬁcance
Natural language processing research and engineering often involves comparing different
classiﬁcation techniques. In some cases, the comparison is between algorithms, such as
logistic regression versus averaged perceptron, or L regularization versus L. In other
cases, the comparison is between feature sets, such as the bag-of-words versus positional
bag-of-words (see § ..). Ablation testing involves systematically removing (ablating)
various aspects of the classiﬁer, such as feature groups, and testing the null hypothesis
that the ablated classiﬁer is as good as the full model.
A full treatment of hypothesis testing is beyond the scope of this text, but this section
contains a brief summary of the techniques necessary to compare classiﬁers. The main
aim of hypothesis testing is to determine whether the difference between two statistics
— for example, the accuracies of two classiﬁers — is likely to arise by chance. We will
be concerned with chance ﬂuctuations that arise due to the ﬁnite size of the test set. An
improvement of % on a test set with ten instances may reﬂect a random ﬂuctuation that
makes the test set more favorable to classiﬁer c than c; on another test set with a different
ten instances, we might ﬁnd that c does better than c. But if we observe the same %
improvement on a test set with  instances, this is highly unlikely to be explained
by chance. Such a ﬁnding is said to be statistically signiﬁcant at a level p, which is the
probability of observing an effect of equal or greater magnitude when the null hypothesis
is true. The notation p < . indicates that the likelihood of an equal or greater effect is
less than %, assuming the null hypothesis is true.
The binomial test
The statistical signiﬁcance of a difference in accuracy can be evaluated using classical tests,
such as the binomial test. Suppose that classiﬁers c and c disagree on N instances in a
Other sources of variance include the initialization of non-convex classiﬁers such as neural networks,
and the ordering of instances in online learning such as stochastic gradient descent and perceptron.
Statistical hypothesis testing is useful only to the extent that the existing test set is representative of
the instances that will be encountered in the future. If, for example, the test set is constructed from news
documents, no hypothesis test can predict which classiﬁer will perform best on documents from another
domain, such as electronic health records.
A well-known alternative to the binomial test is McNemar’s test, which computes a test statistic based
on the number of examples that are correctly classiﬁed by one system and incorrectly classiﬁed by the other.
Jacob Eisenstein. Draft of November , .

.. EVALUATING CLASSIFIERS
p(k
N = ,
= .)
Instances where c is right and c is wrong
Figure .: Probability mass function for the binomial distribution. The pink highlighted
areas represent the cumulative probability for a signiﬁcance test on an observation of
k =  and N = .
test set with binary labels, and that c is correct on k of those instances. Under the null hy-
pothesis that the classiﬁers are equally accurate, we would expect k/N to be roughly equal
to /, and as N increases, k/N should be increasingly close to this expected value. These
properties are captured by the binomial distribution, which is a probability over counts
of binary random variables. We write k ∼ Binom(θ, N) to indicate that k is drawn from
a binomial distribution, with parameter N indicating the number of random “draws”,
and θ indicating the probability of “success” on each draw. Each draw is an example on
which the two classiﬁers disagree, and a “success” is a case in which c is right and c is
wrong. (The label space is assumed to be binary, so if the classiﬁers disagree, exactly one
of them is correct. The test can be generalized to multi-class classiﬁcation by focusing on
the examples in which exactly one classiﬁer is correct.)
The probability mass function (PMF) of the binomial distribution is,
pBinom(k; N, θ) =

θk( − θ)N−k,
with θk representing the probability of the k successes, ( − θ)N−k representing the prob-
ability of the N − k unsuccessful draws. The expression
 N
N!
k!(N−k)! is a binomial
coefﬁcient, representing the number of possible orderings of events; this ensures that the
distribution sums to one over all k ∈ {, , , . . . , N}.
Under the null hypothesis, when the classiﬁers disagree, each classiﬁer is equally
likely to be right, so θ =
. Now suppose that among N disagreements, c is correct
k < N
times. The probability of c being correct k or fewer times is the one-tailed p-value,
The null hypothesis distribution for this test statistic is known to be drawn from a chi-squared distribution
with a single degree of freedom, so a p-value can be computed from the cumulative density function of this
distribution (Dietterich, ). Both tests give similar results in most circumstances, but the binomial test is
easier to understand from ﬁrst principles.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
because it is computed from the area under the binomial probability mass function from
to k, as shown in the left tail of Figure .. This cumulative probability is computed as
a sum over all values i ≤ k,
Pr
Binom
i=
pBinom

count(ˆy(i)
= y(i) ̸= ˆy(i)
) ≤ k; N, θ =

i; N, θ =
The one-tailed p-value applies only to the asymmetric null hypothesis that c is at least
as accurate as c. To test the two-tailed null hypothesis that c and c are equally accu-
rate, we would take the sum of one-tailed p-values, where the second term is computed
from the right tail of Figure .. The binomial distribution is symmetric, so this can be
computed by simply doubling the one-tailed p-value.
Two-tailed tests are more stringent, but they are necessary in cases in which there is
no prior intuition about whether c or c is better. For example, in comparing logistic
regression versus averaged perceptron, a two-tailed test is appropriate. In an ablation
test, c may contain a superset of the features available to c. If the additional features are
thought to be likely to improve performance, then a one-tailed test would be appropriate,
if chosen in advance. However, such a test can only prove that c is more accurate than
c, and not the reverse.
*Randomized testing
The binomial test is appropriate for accuracy, but not for more complex metrics such as
F -MEASURE. To compute statistical signiﬁcance for arbitrary metrics, we can apply ran-
domization. Speciﬁcally, draw a set of M bootstrap samples (Efron and Tibshirani, ),
by resampling instances from the original test set with replacement. Each bootstrap sam-
ple is itself a test set of size N. Some instances from the original test set will not appear
in any given bootstrap sample, while others will appear multiple times; but overall, the
sample will be drawn from the same distribution as the original test set. We can then com-
pute any desired evaluation on each bootstrap sample, which gives a distribution over the
value of the metric. Algorithm  shows how to perform this computation.
To compare the F -MEASURE of two classiﬁers c and c, we set the function δ() to
compute the difference in F -MEASURE on the bootstrap sample. If the difference is less
than or equal to zero in at least % of the samples, then we cannot reject the one-tailed
null hypothesis that c is at least as good as c (Berg-Kirkpatrick et al., ). We may
also be interested in the % conﬁdence interval around a metric of interest, such as
the F -MEASURE of a single classiﬁer. This can be computed by sorting the output of
Algorithm , and then setting the top and bottom of the % conﬁdence interval to the
values at the .% and .% percentiles of the sorted outputs. Alternatively, you can ﬁt
a normal distribution to the set of differences across bootstrap samples, and compute a
Gaussian conﬁdence interval from the mean and variance.
Jacob Eisenstein. Draft of November , .

.. EVALUATING CLASSIFIERS
Algorithm  Bootstrap sampling for classiﬁer evaluation.
The original test set is
{x(:N), y(:N)}, the metric is δ(), and the number of samples is M.
procedure BOOTSTRAP-SAMPLE(x(:N), y(:N), δ(), M)
for t ∈ {, , . . . , M} do
for i ∈ {, , . . . , N} do
j ∼ UniformInteger(, N)
˜x(i) ← x(j)
˜y(i) ← y(j)
d(t) ← δ(˜x(:N), ˜y(:N))
return {d(t)}M
t=
M (Robert and Casella, ).
As the number of bootstrap samples goes to inﬁnity, M → ∞, the bootstrap estimate
is increasingly accurate. A typical choice for M is  or ; larger numbers of samples
are necessary for smaller p-values. One way to validate your choice of M is to run the test
multiple times, and ensure that the p-values are similar; if not, increase M by an order of
magnitude. This is a heuristic measure of the variance of the test, which can decreases
with the square root
*Multiple comparisons
Sometimes it is necessary to perform multiple hypothesis tests, such as when compar-
ing the performance of several classiﬁers on multiple datasets. Suppose you have ﬁve
datasets, and you compare four versions of your classiﬁer against a baseline system, for a
total of  comparisons. Even if none of your classiﬁers is better than the baseline, there
will be some chance variation in the results, and in expectation you will get one statis-
tically signiﬁcant improvement at p = . =
. It is therefore necessary to adjust the
p-values when reporting the results of multiple comparisons.
One approach is to require a threshold of α
m to report a p value of p < α when per-
forming m tests. This is known as the Bonferroni correction, and it limits the overall
probability of incorrectly rejecting the null hypothesis at α. Another approach is to bound
the false discovery rate (FDR), which is the fraction of null hypothesis rejections that are
incorrect. Benjamini and Hochberg () propose a p-value correction that bounds the
fraction of false discoveries at α: sort the p-values of each individual test in ascending
order, and set the signiﬁcance threshold equal to largest k such that pk ≤ k
mα. If k > , the
FDR adjustment is more permissive than the Bonferroni correction.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
Building datasets
Sometimes, if you want to build a classiﬁer, you must ﬁrst build a dataset of your own.
This includes selecting a set of documents or instances to annotate, and then performing
the annotations. The scope of the dataset may be determined by the application: if you
want to build a system to classify electronic health records, then you must work with a
corpus of records of the type that your classiﬁer will encounter when deployed. In other
cases, the goal is to build a system that will work across a broad range of documents. In
this case, it is best to have a balanced corpus, with contributions from many styles and
genres. For example, the Brown corpus draws from texts ranging from government doc-
uments to romance novels (Francis, ), and the Google Web Treebank includes an-
notations for ﬁve “domains” of web documents: question answers, emails, newsgroups,
reviews, and blogs (Petrov and McDonald, ).
Metadata as labels
Annotation is difﬁcult and time-consuming, and most people would rather avoid it. It
is sometimes possible to exploit existing metadata to obtain labels for training a classi-
ﬁer. For example, reviews are often accompanied by a numerical rating, which can be
converted into a classiﬁcation label (see § .). Similarly, the nationalities of social media
users can be estimated from their proﬁles (Dredze et al., ) or even the time zones of
their posts (Gouws et al., ). More ambitiously, we may try to classify the political af-
ﬁliations of social media proﬁles based on their social network connections to politicians
and major political parties (Rao et al., ).
The convenience of quickly constructing large labeled datasets without manual an-
notation is appealing. However this approach relies on the assumption that unlabeled
instances — for which metadata is unavailable — will be similar to labeled instances.
Consider the example of labeling the political afﬁliation of social media users based on
their network ties to politicians. If a classiﬁer attains high accuracy on such a test set,
is it safe to assume that it accurately predicts the political afﬁliation of all social media
users? Probably not. Social media users who establish social network ties to politicians
may be more likely to mention politics in the text of their messages, as compared to the
average user, for whom no political metadata is available. If so, the accuracy on a test set
constructed from social network metadata would give an overly optimistic picture of the
method’s true performance on unlabeled data.
Labeling data
In many cases, there is no way to get ground truth labels other than manual annotation.
An annotation protocol should satisfy several criteria: the annotations should be expressive
enough to capture the phenomenon of interest; they should be replicable, meaning that
Jacob Eisenstein. Draft of November , .

.. BUILDING DATASETS
another annotator or team of annotators would produce very similar annotations if given
the same data; and they should be scalable, so that they can be produced relatively quickly.
Hovy and Lavid () propose a structured procedure for obtaining annotations that
meet these criteria, which is summarized below.
. Determine what to annotate. This is usually based on some theory of the under-
lying phenomenon: for example, if the goal is to produce annotations about the
emotional state of a document’s author, one should start with a theoretical account
of the types or dimensions of emotion (e.g., Mohammad and Turney, ). At this
stage, the tradeoff between expressiveness and scalability should be considered: a
full instantiation of the underlying theory might be too costly to annotate at scale,
so reasonable approximations should be considered.
. Optionally, one may design or select a software tool to support the annotation
effort. Existing general-purpose annotation tools include BRAT (Stenetorp et al.,
) and MMAX (M¨uller and Strube, ).
. Formalize the instructions for the annotation task. To the extent that the instruc-
tions are not explicit, the resulting annotations will depend on the intuitions of the
annotators. These intuitions may not be shared by other annotators, or by the users
of the annotated data. Therefore explicit instructions are critical to ensuring the an-
notations are replicable and usable by other researchers.
. Perform a pilot annotation of a small subset of data, with multiple annotators for
each instance. This will give a preliminary assessment of both the replicability and
scalability of the current annotation instructions. Metrics for computing the rate of
agreement are described below. Manual analysis of speciﬁc disagreements should
help to clarify the instructions, and may lead to modiﬁcations of the annotation task
itself. For example, if two labels are commonly conﬂated by annotators, it may be
best to merge them.
. Annotate the data. After ﬁnalizing the annotation protocol and instructions, the
main annotation effort can begin. Some, if not all, of the instances should receive
multiple annotations, so that inter-annotator agreement can be computed. In some
annotation projects, instances receive many annotations, which are then aggregated
into a “consensus” label (e.g., Danescu-Niculescu-Mizil et al., ). However, if the
annotations are time-consuming or require signiﬁcant expertise, it may be preferable
to maximize scalability by obtaining multiple annotations for only a small subset of
examples.
. Compute and report inter-annotator agreement, and release the data. In some
cases, the raw text data cannot be released, due to concerns related to copyright or
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
privacy. In these cases, one solution is to publicly release stand-off annotations,
which contain links to document identiﬁers. The documents themselves can be re-
leased under the terms of a licensing agreement, which can impose conditions on
how the data is used. It is important to think through the potential consequences of
releasing data: people may make personal data publicly available without realizing
that it could be redistributed in a dataset and publicized far beyond their expecta-
tions (boyd and Crawford, ).
Measuring inter-annotator agreement
To measure the replicability of annotations, a standard practice is to compute the extent to
which annotators agree with each other. If the annotators frequently disagree, this casts
doubt on either their reliability or on the annotation system itself. For classiﬁcation, one
can compute the frequency with which the annotators agree; for rating scales, one can
compute the average distance between ratings. These raw agreement statistics must then
be compared with the rate of agreement by chance — the expected level of agreement that
would be obtained between two annotators who ignored the data.
Cohen’s Kappa is widely used for quantifying the agreement on discrete labeling
tasks (Cohen, ; Carletta, ),
κ = agreement − E[agreement]
− E[agreement]
The numerator is the difference between the observed agreement and the chance agree-
ment, and the denominator is the difference between perfect agreement and chance agree-
ment. Thus, κ =  when the annotators agree in every case, and κ =  when the annota-
tors agree only as often as would happen by chance. Various heuristic scales have been
proposed for determining when κ indicates “moderate”, “good”, or “substantial” agree-
ment; for reference, Lee and Narayanan () report κ ≈ . − . for annotations
of emotions in spoken dialogues, which they describe as “moderate agreement”; Stolcke
et al. () report κ = . for annotations of dialogue acts, which are labels for the pur-
pose of each turn in a conversation.
When there are two annotators, the expected chance agreement is computed as,
ˆPr(Y = k),
E[agreement] =
where k is a sum over labels, and ˆPr(Y = k) is the empirical probability of label k across
all annotations. The formula is derived from the expected number of agreements if the
annotations were randomly shufﬂed. Thus, in a binary labeling task, if one label is applied
to % of instances, chance agreement is . + . = ..
For other types of annotations, Krippendorf’s alpha is a popular choice (Hayes and Krippendorff, ;
Artstein and Poesio, ).
Jacob Eisenstein. Draft of November , .

.. BUILDING DATASETS
Crowdsourcing
Crowdsourcing is often used to rapidly obtain annotations for classiﬁcation problems.
For example, Amazon Mechanical Turk makes it possible to deﬁne “human intelligence
tasks (hits)”, such as labeling data. The researcher sets a price for each set of annotations
and a list of minimal qualiﬁcations for annotators, such as their native language and their
satisfaction rate on previous tasks. The use of relatively untrained “crowdworkers” con-
trasts with earlier annotation efforts, which relied on professional linguists (Marcus et al.,
). However, crowdsourcing has been found to produce reliable annotations for many
language-related tasks (Snow et al., ). Crowdsourcing is part of the broader ﬁeld
of human computation (Law and Ahn, ).For a critical examination of ethical issues
related to crowdsourcing, see Fort et al. ().
Additional resources
Many of the preprocessing issues discussed in this chapter also arise in information re-
trieval. See Manning et al. () for discussion of tokenization and related algorithms.
For more on hypothesis testing in particular and replicability in general, see (Dror et al.,
, ).
Exercises
. As noted in § .., words tend to appear in clumps, with subsequent occurrences
of a word being more probable. More concretely, if word j has probability φy,j
of appearing in a document with label y, then the probability of two appearances
(x(i)
= ) is greater than φ
y,j.
Suppose you are applying Na¨ıve Bayes to a binary classiﬁcation. Focus on a word j
which is more probable under label y = , so that,
Pr(w = j | y = ) > Pr(w = j | y = ).
Now suppose that x(i)
> . All else equal, will the classiﬁer overestimate or under-
estimate the posterior Pr(y =  | x)?
. Prove that F-measure is never greater than the arithmetic mean of recall and preci-
sion, r+p
iff r = p.
. Your solution should also show that F-measure is equal to r+p
. Given a binary classiﬁcation problem in which the probability of the “positive” label
is equal to α, what is the expected F -MEASURE of a random classiﬁer which ignores
the data, and selects ˆy = + with probability
? (Assume that p(ˆy)⊥p(y).) What is
the expected F -MEASURE of a classiﬁer that selects ˆy = + with probability α (also
independent of y(i))? Depending on α, which random classiﬁer will score better?
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
. Suppose that binary classiﬁers c and c disagree on N =  cases, and that c is
correct in k =  of those cases.
Write a program that uses primitive functions such as exp and factorial to com-
pute the two-tailed p-value — you may use an implementation of the “choose”
function if one is avaiable. Verify your code against the output of a library for
computing the binomial test or the binomial CDF, such as SCIPY.STATS.BINOM
in Python.
Then use a randomized test to try to obtain the same p-value. In each sample,
draw from a binomial distribution with N =  and θ =
. Count the fraction
of samples in which k ≤ . This is the one-tailed p-value; double this to
compute the two-tailed p-value.
Try this with varying numbers of bootstrap samples: M ∈ {, , , }.
For M =  and M = , run the test  times, and plot the resulting p-
values.
Finally, perform the same tests for N =  and k = .
. SemCor . is a labeled dataset for word sense disambiguation. You can download
it, or access it in NLTK.CORPORA.SEMCOR.
Choose a word that appears at least ten times in SemCor (ﬁnd), and annotate its
WordNet senses across ten randomly-selected examples, without looking at the ground
truth. Use online WordNet to understand the deﬁnition of each of the senses. Have
a partner do the same annotations, and compute the raw rate of agreement, expected
chance rate of agreement, and Cohen’s kappa.
. Download the Pang and Lee movie review data, currently available from http:
//www.cs.cornell.edu/people/pabo/movie-review-data/. Hold out a
randomly-selected  reviews as a test set.
Download a sentiment lexicon, such as the one currently available from Bing Liu,
https://www.cs.uic.edu/˜liub/FBS/sentiment-analysis.html. Tokenize
the data, and classify each document as positive iff it has more positive sentiment
words than negative sentiment words. Compute the accuracy and F -MEASURE on
detecting positive reviews on the test set, using this lexicon-based classiﬁer.
Then train a discriminative classiﬁer (averaged perceptron or logistic regression) on
the training set, and compute its accuracy and F -MEASURE on the test set.
Determine whether the differences are statistically signiﬁcant, using two-tailed hy-
pothesis tests: Binomial for the difference in accuracy, and bootstrap for the differ-
ence in macro-F -MEASURE.
e.g.,
https://github.com/google-research-datasets/word_sense_disambigation_
corpora or http://globalwordnet.org/wordnet-annotated-corpora/
http://wordnetweb.princeton.edu/perl/webwn
Jacob Eisenstein. Draft of November , .

.. BUILDING DATASETS
The remaining problems will require you to build a classiﬁer and test its properties. Pick
a multi-class text classiﬁcation dataset that is not already tokenized. One example is a
dataset of New York Times headlines and topics (Boydstun, ). Divide your data
into training (%), development (%), and test sets (%), if no such division already
exists. If your dataset is very large, you may want to focus on a few thousand instances at
ﬁrst.
. Compare various vocabulary sizes of , , , , using the most frequent words
in each case (you may use any reasonable tokenizer). Train logistic regression clas-
siﬁers for each vocabulary size, and apply them to the development set. Plot the
accuracy and Macro-F -MEASURE with the increasing vocabulary size. For each vo-
cabulary size, tune the regularizer to maximize accuracy on a subset of data that is
held out from the training set.
. Compare the following tokenization algorithms:
Whitespace, using a regular expression;
The Penn Treebank tokenizer from NLTK;
Splitting the input into non-overlapping ﬁve-character units, regardless of whites-
pace or punctuation.
Compute the token/type ratio for each tokenizer on the training data, and explain
what you ﬁnd. Train your classiﬁer on each tokenized dataset, tuning the regularizer
on a subset of data that is held out from the training data. Tokenize the development
set, and report accuracy and Macro-F -MEASURE.
. Apply the Porter and Lancaster stemmers to the training set, using any reasonable
tokenizer, and compute the token/type ratios. Train your classiﬁer on the stemmed
data, and compute the accuracy and Macro-F -MEASURE on stemmed development
data, again using a held-out portion of the training data to tune the regularizer.
. Identify the best combination of vocabulary ﬁltering, tokenization, and stemming
from the previous three problems. Apply this preprocessing to the test set, and
compute the test set accuracy and Macro-F -MEASURE. Compare against a baseline
system that applies no vocabulary ﬁltering, whitespace tokenization, and no stem-
ming.
Use the binomial test to determine whether your best-performing system is signiﬁ-
cantly more accurate than the baseline.
Available
as
CSV
ﬁle
at
http://www.amber-boydstun.com/
supplementary-information-for-making-the-news.html.
Use the ﬁeld TOPIC DIGIT for
this problem.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LINGUISTIC APPLICATIONS OF CLASSIFICATION
Use the bootstrap test with M =  to determine whether your best-performing
system achieves signiﬁcantly higher macro-F -MEASURE.
Jacob Eisenstein. Draft of November , .

Chapter
Learning without supervision
So far, we have assumed the following setup:
a training set where you get observations x and labels y;
a test set where you only get observations x.
Without labeled data, is it possible to learn anything? This scenario is known as unsu-
pervised learning, and we will see that indeed it is possible to learn about the underlying
structure of unlabeled observations. This chapter will also explore some related scenarios:
semi-supervised learning, in which only some instances are labeled, and domain adap-
tation, in which the training data differs from the data on which the trained system will
be deployed.
Unsupervised learning
To motivate unsupervised learning, consider the problem of word sense disambiguation
(§ .). The goal is to classify each instance of a word, such as bank into a sense,
bank#: a ﬁnancial institution
bank#: the land bordering a river
It is difﬁcult to obtain sufﬁcient training data for word sense disambiguation, because
even a large corpus will contain only a few instances of all but the most common words.
Is it possible to learn anything about these different senses without labeled data?
Word sense disambiguation is usually performed using feature vectors constructed
from the local context of the word to be disambiguated.
For example, for the word
CHAPTER . LEARNING WITHOUT SUPERVISION
density of word group
density of word group
Figure .: Counts of words from two different context groups
bank, the immediate context might typically include words from one of the following two
groups:
. ﬁnancial, deposits, credit, lending, capital, markets, regulated, reserve, liquid, assets
. land, water, geography, stream, river, ﬂow, deposits, discharge, channel, ecology
Now consider a scatterplot, in which each point is a document containing the word bank.
The location of the document on the x-axis is the count of words in group , and the
location on the y-axis is the count for group . In such a plot, shown in Figure ., two
“blobs” might emerge, and these blobs correspond to the different senses of bank.
Here’s a related scenario, from a different problem. Suppose you download thousands
of news articles, and make a scatterplot, where each point corresponds to a document:
the x-axis is the frequency of the group of words (hurricane, winds, storm); the y-axis is the
frequency of the group (election, voters, vote). This time, three blobs might emerge: one
for documents that are largely about a hurricane, another for documents largely about a
election, and a third for documents about neither topic.
These clumps represent the underlying structure of the data. But the two-dimensional
scatter plots are based on groupings of context words, and in real scenarios these word
lists are unknown. Unsupervised learning applies the same basic idea, but in a high-
dimensional space with one dimension for every context word. This space can’t be di-
rectly visualized, but the goal is the same: try to identify the underlying structure of the
observed data, such that there are a few clusters of points, each of which is internally
coherent. Clustering algorithms are capable of ﬁnding such structure automatically.
K-means clustering
Clustering algorithms assign each data point to a discrete cluster, zi ∈ , , . . . K. One of
the best known clustering algorithms is K-means, an iterative algorithm that maintains
Jacob Eisenstein. Draft of November , .

.. UNSUPERVISED LEARNING
Algorithm  K-means clustering algorithm
: procedure K-MEANS(x:N, K)
for i ∈  . . . N do
▷ initialize cluster memberships
z(i) ← RANDOMINT(, K)
repeat
for k ∈  . . . K do
▷ recompute cluster centers
νk ←
δ(z(i)=k)
PN
i= δ(z(i) = k)x(i)
for i ∈  . . . N do
▷ reassign instances to nearest clusters
z(i) ← argmink ||x(i) − νk||
until converged
return {z(i)}
▷ return cluster assignments
a cluster assignment for each instance, and a central (“mean”) location for each cluster.
K-means iterates between updates to the assignments and the centers:
. each instance is placed in the cluster with the closest center;
. each center is recomputed as the average over points in the cluster.
This procedure is formalized in Algorithm . The term ||x(i) − ν|| refers to the squared
Euclidean norm, PV
j=(x(i)
− νj). An important property of K-means is that the con-
verged solution depends on the initialization, and a better clustering can sometimes be
found simply by re-running the algorithm from a different random starting point.
Soft K-means is a particularly relevant variant. Instead of directly assigning each
point to a speciﬁc cluster, soft K-means assigns to each point a distribution over clusters
q(i), so that PK
k= q(i)(k) = , and ∀k, q(i)(k) ≥ . The soft weight q(i)(k) is computed from
the distance of x(i) to the cluster center νk. In turn, the center of each cluster is computed
from a weighted average of the points in the cluster,
i=
q(i)(k)x(i).
νk =
PN
i= q(i)(k)
We will now explore a probablistic version of soft K-means clustering, based on expectation-
maximization (EM). Because EM clustering can be derived as an approximation to maximum-
likelihood estimation, it can be extended in a number of useful ways.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
Expectation-Maximization (EM)
Expectation-maximization combines the idea of soft K-means with Na¨ıve Bayes classiﬁ-
cation. To review, Na¨ıve Bayes deﬁnes a probability distribution over the data,
log p(x, y; φ, µ) =
i=
log

p(x(i) | y(i); φ) × p(y(i); µ)

Now suppose that you never observe the labels. To indicate this, we’ll refer to the label
of each instance as z(i), rather than y(i), which is usually reserved for observed variables.
By marginalizing over the latent variables z, we obtain the marginal probability of the
observed instances x:
log p(x; φ, µ) =
i=
log p(x(i); φ, µ)
z=
p(x(i), z; φ, µ)
i=
log
z=
p(x(i) | z; φ) × p(z; µ).
i=
log
The parameters φ and µ can be obtained by maximizing the marginal likelihood in
Equation .. Why is this the right thing to maximize? Without labels, discriminative
learning is impossible — there’s nothing to discriminate. So maximum likelihood is all
we have.
When the labels are observed, we can estimate the parameters of the Na¨ıve Bayes
probability model separately for each label. But marginalizing over the labels couples
these parameters, making direct optimization of log p(x) intractable. We will approxi-
mate the log-likelihood by introducing an auxiliary variable q(i), which is a distribution
over the label set Z = {, , . . . , K}. The optimization procedure will alternate between
updates to q and updates to the parameters (φ, µ). Thus, q(i) plays here as in soft K-
means.
To derive the updates for this optimization, multiply the right side of Equation . by
Jacob Eisenstein. Draft of November , .

.. UNSUPERVISED LEARNING
the ratio q(i)(z)
q(i)(z) = ,
log p(x; φ, µ) =
q(i)(z)
z=
p(x(i) | z; φ) × p(z; µ) × q(i)(z)
i=
log
q(i)(z)
z=
q(i)(z) × p(x(i) | z; φ) × p(z; µ) ×
i=
log
q(i)(z)
p(x(i) | z; φ)p(z; µ)
i=
log Eq(i)
where Eq(i) [f(z)] = PK
z= q(i)(z) × f(z) refers to the expectation of the function f under
the distribution z ∼ q(i).
Jensen’s inequality says that because log is a concave function, we can push it inside
the expectation, and obtain a lower bound.
log p(x(i) | z; φ)p(z; µ)
log p(x; φ, µ) ≥
q(i)(z)
i=
Eq(i)
J ≜
i=
Eq(i)
log p(x(i) | z; φ) + log p(z; µ) − log q(i)(z)
i=
Eq(i)
log p(x(i), z; φ, µ)
+ H(q(i))
We will focus on Equation ., which is the lower bound on the marginal log-likelihood
of the observed data, log p(x). Equation . shows the connection to the information
theoretic concept of entropy, H(q(i)) = − PK
z= q(i)(z) log q(i)(z), which measures the av-
erage amount of information produced by a draw from the distribution q(i). The lower
bound J is a function of two groups of arguments:
the distributions q(i) for each instance;
the parameters µ and φ.
The expectation-maximization (EM) algorithm maximizes the bound with respect to each
of these arguments in turn, while holding the other ﬁxed.
The E-step
The step in which we update q(i) is known as the E-step, because it updates the distribu-
tion under which the expectation is computed. To derive this update, ﬁrst write out the
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
expectation in the lower bound as a sum,
J =
i=
z=
q(i)(z)
log p(x(i) | z; φ) + log p(z; µ) − log q(i)(z)
When optimizing this bound, we must also respect a set of “sum-to-one” constraints,
PK
z= q(i)(z) =  for all i. Just as in Na¨ıve Bayes, this constraint can be incorporated into a
Lagrangian:
Jq =
z=
q(i)(z)),
i=
z=
q(i)(z)

log p(x(i) | z; φ) + log p(z; µ) − log q(i)(z)

+ λ(i)( −
where λ(i) is the Lagrange multiplier for instance i.
The Lagrangian is maximized by taking the derivative and solving for q(i):
∂Jq
∂q(i)(z) = log p(x(i) | z; φ) + log p(z; θ) − log q(i)(z) −  − λ(i)
log q(i)(z) = log p(x(i) | z; φ) + log p(z; µ) −  − λ(i)
q(i)(z) ∝p(x(i) | z; φ) × p(z; µ).
Applying the sum-to-one constraint gives an exact solution,
q(i)(z) =
p(x(i) | z; φ) × p(z; µ)
PK
z′= p(x(i) | z′; φ) × p(z′; µ)
=p(z | x(i); φ, µ).
After normalizing, each q(i) — which is the soft distribution over clusters for data x(i) —
is set to the posterior probability p(z | x(i); φ, µ) under the current parameters. Although
the Lagrange multipliers λ(i) were introduced as additional parameters, they drop out
during normalization.
The M-step
Jacob Eisenstein. Draft of November , .
Next, we hold ﬁxed the soft assignments q(i), and maximize with respect to the pa-
rameters, φ and µ. Let’s focus on the parameter φ, which parametrizes the likelihood
p(x | z; φ), and leave µ for an exercise. The parameter φ is a distribution over words for
each cluster, so it is optimized under the constraint that PV
j= φz,j = . To incorporate this

.. UNSUPERVISED LEARNING
constraint, we introduce a set of Lagrange multiplers {λz}K
z=, and from the Lagrangian,
Jφ =
z=
λz( −
i=
j=
φz,j).
z=
q(i)(z)

log p(x(i) | z; φ) + log p(z; µ) − log q(i)(z)

The term log p(x(i) | z; φ) is the conditional log-likelihood for the multinomial, which
expands to,
log p(x(i) | z, φ) = C +
j=
xj log φz,j,
where C is a constant with respect to φ — see Equation . in § . for more discussion
of this probability function.
Setting the derivative of Jφ equal to zero,
∂Jφ
∂φz,j
φz,j
− λz
i=
q(i)(z) ×
x(i)
φz,j ∝
i=
q(i)(z) × x(i)
j .
Because φz is constrained to be a probability distribution, the exact solution is computed
as,
φz,j =
PN
i= q(i)(z) × x(i)
PV
j′=
PN
i= q(i)(z) × x(i)
j′
Eq [count(z, j)]
PV
j′= Eq [count(z, j′)]
where the counter j ∈ {, , . . . , V } indexes over base features, such as words.
This update sets φz equal to the relative frequency estimate of the expected counts under
the distribution q. As in supervised Na¨ıve Bayes, we can smooth these counts by adding
a constant α. The update for µ is similar: µz ∝ PN
i= q(i)(z) = Eq [count(z)], which is the
expected frequency of cluster z. These probabilities can also be smoothed. In sum, the
M-step is just like Na¨ıve Bayes, but with expected counts rather than observed counts.
The multinomial likelihood p(x | z) can be replaced with other probability distribu-
tions: for example, for continuous observations, a Gaussian distribution can be used. In
some cases, there is no closed-form update to the parameters of the likelihood. One ap-
proach is to run gradient-based optimization at each M-step; another is to simply take a
single step along the gradient step and then return to the E-step (Berg-Kirkpatrick et al.,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
negative log-likelihood bound
iteration
Figure .: Sensitivity of expectation-maximization to initialization. Each line shows the
progress of optimization from a different random initialization.
EM as an optimization algorithm
Algorithms that update a global objective by alternating between updates to subsets of the
parameters are called coordinate ascent algorithms. The objective J (the lower bound on
the marginal likelihood of the data) is separately convex in q and (µ, φ), but it is not jointly
convex in all terms; this condition is known as biconvexity. Each step of the expectation-
maximization algorithm is guaranteed not to decrease the lower bound J, which means
that EM will converge towards a solution at which no nearby points yield further im-
provements. This solution is a local optimum — it is as good or better than any of its
immediate neighbors, but is not guaranteed to be optimal among all possible conﬁgura-
tions of (q, µ, φ).
The fact that there is no guarantee of global optimality means that initialization is
important: where you start can determine where you ﬁnish.
To illustrate this point,
Figure . shows the objective function for EM with ten different random initializations:
while the objective function improves monotonically in each run, it converges to several
different values. For the convex objectives that we encountered in chapter , it was not
necessary to worry about initialization, because gradient-based optimization guaranteed
to reach the global minimum. But in expectation-maximization — as in the deep neural
networks from chapter  — initialization matters.
In hard EM, each q(i) distribution assigns probability of  to a single label ˆz(i), and zero
probability to all others (Neal and Hinton, ). This is similar in spirit to K-means clus-
tering, and can outperform standard EM in some cases (Spitkovsky et al., ). Another
variant of expectation-maximization incorporates stochastic gradient descent (SGD): after
performing a local E-step at each instance x(i), we immediately make a gradient update
to the parameters (µ, φ). This algorithm has been called incremental expectation maxi-
mization (Neal and Hinton, ) and online expectation maximization (Sato and Ishii,
The ﬁgure shows the upper bound on the negative log-likelihood, because optimization is typically
framed as minimization rather than maximization.
Jacob Eisenstein. Draft of November , .

.. UNSUPERVISED LEARNING
; Capp´e and Moulines, ), and is especially useful when there is no closed-form
optimum for the likelihood p(x | z), and in online settings where new data is constantly
streamed in (see Liang and Klein, , for a comparison for online EM variants).
How many clusters?
So far, we have assumed that the number of clusters K is given. In some cases, this as-
sumption is valid. For example, a lexical semantic resource like WORDNET might deﬁne
the number of senses for a word. In other cases, the number of clusters could be a parame-
ter for the user to tune: some readers want a coarse-grained clustering of news stories into
three or four clusters, while others want a ﬁne-grained clustering into twenty or more. But
many times there is little extrinsic guidance for how to choose K.
One solution is to choose the number of clusters to maximize a metric of clustering
quality. The other parameters µ and φ are chosen to maximize the log-likelihood bound
J, so this might seem a potential candidate for tuning K. However, J will never decrease
with K: if it is possible to obtain a bound of JK with K clusters, then it is always possible
to do at least as well with K +  clusters, by simply ignoring the additional cluster and
setting its probability to zero in q and µ. It is therefore necessary to introduce a penalty
for model complexity, so that fewer clusters are preferred. For example, the Akaike Infor-
mation Crition (AIC; Akaike, ) is the linear combination of the number of parameters
and the log-likelihood,
AIC = M − J,
where M is the number of parameters. In an expectation-maximization clustering algo-
rithm, M = K × V + K. Since the number of parameters increases with the number of
clusters K, the AIC may prefer more parsimonious models, even if they do not ﬁt the data
quite as well.
Another choice is to maximize the predictive likelihood on heldout data. This data
is not used to estimate the model parameters φ and µ, and so it is not the case that the
likelihood on this data is guaranteed to increase with K. Figure . shows the negative
log-likelihood on training and heldout data, as well as the AIC.
*Bayesian nonparametrics
An alternative approach is to treat the number of clusters
as another latent variable. This requires statistical inference over a set of models with a
variable number of clusters. This is not possible within the framework of expectation-
maximization, but there are several alternative inference procedures which can be ap-
plied, including Markov Chain Monte Carlo (MCMC), which is brieﬂy discussed in
§ . (for more details, see Chapter  of Murphy, ). Bayesian nonparametrics have
been applied to the problem of unsupervised word sense induction, learning not only the
word senses but also the number of senses per word (Reisinger and Mooney, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
Out-of-sample negative log likelihood
Negative log-likelihood bound
AIC
Number of clusters
Number of clusters
Figure .:
The negative log-likelihood and AIC for several runs of expectation-
maximization, on synthetic data. Although the data was generated from a model with
K = , the optimal number of clusters is ˆK = , according to AIC and the heldout
log-likelihood. The training set log-likelihood continues to improve as K increases.
Applications of expectation-maximization
EM is not really an “algorithm” like, say, quicksort. Rather, it is a framework for learning
with missing data. The recipe for using EM on a problem of interest is:
Introduce latent variables z, such that it is easy to write the probability P(x, z). It
should also be easy to estimate the associated parameters, given knowledge of z.
Derive the E-step updates for q(z), which is typically factored as q(z) = QN
i= qz(i)(z(i)),
where i is an index over instances.
The M-step updates typically correspond to the soft version of a probabilistic super-
vised learning algorithm, like Na¨ıve Bayes.
This section discusses a few of the many applications of this general framework.
Word sense induction
The chapter began by considering the problem of word sense disambiguation when the
senses are not known in advance. Expectation-maximization can be applied to this prob-
lem by treating each cluster as a word sense. Each instance represents the use of an
ambiguous word, and x(i) is a vector of counts for the other words that appear nearby:
Sch¨utze () uses all words within a -word window. The probability p(x(i) | z) can be
set to the multinomial distribution, as in Na¨ıve Bayes. The EM algorithm can be applied
directly to this data, yielding clusters that (hopefully) correspond to the word senses.
Better performance can be obtained by ﬁrst applying singular value decomposition
(SVD) to the matrix of context-counts Cij = count(i, j), where count(i, j) is the count of
word j in the context of instance i. Truncated singular value decomposition approximates
Jacob Eisenstein. Draft of November , .

.. APPLICATIONS OF EXPECTATION-MAXIMIZATION
the matrix C as a product of three matrices, U, S, V, under the constraint that U and V
are orthonormal, and S is diagonal:
min
U,S,V||C − USV⊤||F
s.t.U ∈ RV ×K, UU⊤ = I
S = Diag(s, s, . . . , sK)
V⊤ ∈ RNp×K, VV⊤ = I,
where ||  ||F is the Frobenius norm, ||X||F =
qP
i,j X
i,j. The matrix U contains the
left singular vectors of C, and the rows of this matrix can be used as low-dimensional
representations of the count vectors ci. EM clustering can be made more robust by setting
the instance descriptions x(i) equal to these rows, rather than using raw counts (Sch¨utze,
). However, because the instances are now dense vectors of continuous numbers, the
probability p(x(i) | z) must be deﬁned as a multivariate Gaussian distribution.
In truncated singular value decomposition, the hyperparameter K is the truncation
limit: when K is equal to the rank of C, the norm of the difference between the original
matrix C and its reconstruction USV⊤ will be zero. Lower values of K increase the recon-
struction error, but yield vector representations that are smaller and easier to learn from.
Singular value decomposition is discussed in more detail in chapter .
Semi-supervised learning
Expectation-maximization can also be applied to the problem of semi-supervised learn-
ing: learning from both labeled and unlabeled data in a single model. Semi-supervised
learning makes use of annotated examples, ensuring that each label y corresponds to the
desired concept. By adding unlabeled examples, it is possible to cover a greater fraction of
the features than would appear in labeled data alone. Other methods for semi-supervised
learning are discussed in § ., but for now, let’s approach the problem within the frame-
work of expectation-maximization (Nigam et al., ).
Suppose we have labeled data {(x(i), y(i))}Nℓ
i=, and unlabeled data {x(i)}Nℓ+Nu
i=Nℓ+, where
Nℓ is the number of labeled instances and Nu is the number of unlabeled instances. We can
learn from the combined data by maximizing a lower bound on the joint log-likelihood,
L =
i=
log p(x(i), y(i); µ, φ) +
j=Nℓ+
log p(x(j); µ, φ)
Nℓ
Nℓ+Nu
y=
p(x(j), y; µ, φ).
i=
j=Nℓ+
log

log p(x(i) | y(i); φ) + log p(y(i); µ)

Nℓ
Nℓ+Nu
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
Algorithm  Generative process for the Na¨ıve Bayes classiﬁer with hidden components
for Instance i ∈ {, , . . . , N} do:
Draw the label y(i) ∼ Categorical(µ);
Draw the component z(i) ∼ Categorical(βy(i));
Draw the word counts x(i) | y(i), z(i) ∼ Multinomial(φz(i)).
The left sum is identical to the objective in Na¨ıve Bayes; the right sum is the marginal log-
likelihood for expectation-maximization clustering, from Equation .. We can construct a
lower bound on this log-likelihood by introducing distributions q(j) for all j ∈ {Nℓ + , . . . , Nℓ + Nu}.
The E-step updates these distributions; the M-step updates the parameters φ and µ, us-
ing the expected counts from the unlabeled data and the observed counts from the labeled
data.
A critical issue in semi-supervised learning is how to balance the impact of the labeled
and unlabeled data on the classiﬁer weights, especially when the unlabeled data is much
larger than the labeled dataset. The risk is that the unlabeled data will dominate, caus-
ing the parameters to drift towards a “natural clustering” of the instances — which may
not correspond to a good classiﬁer for the labeled data. One solution is to heuristically
reweight the two components of Equation ., tuning the weight of the two components
on a heldout development set (Nigam et al., ).
Multi-component modeling
As a ﬁnal application, let’s return to fully supervised classiﬁcation. A classic dataset for
text classiﬁcation is  newsgroups, which contains posts to a set of online forums, called
newsgroups. One of the newsgroups is comp.sys.mac.hardware, which discusses Ap-
ple computing hardware. Suppose that within this newsgroup there are two kinds of
posts: reviews of new hardware, and question-answer posts about hardware problems.
The language in these components of the mac.hardware class might have little in com-
mon; if so, it would be better to model these components separately, rather than treating
their union as a single class. However, the component responsible for each instance is not
directly observed.
Recall that Na¨ıve Bayes is based on a generative process, which provides a stochastic
explanation for the observed data. In Na¨ıve Bayes, each label is drawn from a categorical
distribution with parameter µ, and each vector of word counts is drawn from a multi-
nomial distribution with parameter φy. For multi-component modeling, we envision a
slightly different generative process, incorporating both the observed label y(i) and the
latent component z(i). This generative process is shown in Algorithm . A new parameter
βy(i) deﬁnes the distribution of components, conditioned on the label y(i). The component,
and not the class label, then parametrizes the distribution over words.
Jacob Eisenstein. Draft of November , .

.. SEMI-SUPERVISED LEARNING
Villeneuve a bel et bien r´eussi son pari de changer de perspectives tout en assurant
une coh´erence `a la franchise.
Il est ´egalement trop long et bancal dans sa narration, ti`ede dans ses intentions, et
tiraill´e entre deux personnages et directions qui ne parviennent pas `a coexister en har-
monie.
Denis Villeneuve a r´eussi une suite parfaitement maitris´ee
Long, bavard, hyper design, `a peine agit´e (le comble de l’action : une bagarre dans la
ﬂotte), m´etaphysique et, surtout, ennuyeux jusqu’`a la catalepsie.
Une suite d’une ´ecrasante puissance, mˆelant parfaitement le contemplatif au narratif.
Le ﬁlm impitoyablement bavard ﬁnit quand mˆeme par se taire quand se l`eve l’esp`ece
de bouquet ﬁnal o`u semble se d´echaˆıner, comme en libre parcours de poulets d´ecapit´es,
l’arm´ee des graphistes num´eriques griffant nerveusement la palette graphique entre ag-
onie et orgasme.
Table .: Labeled and unlabeled reviews of the ﬁlms Blade Runner  and Transformers:
The Last Knight.
The labeled data includes (x(i), y(i)), but not z(i), so this is another case of missing
data. Again, we sum over the missing data, applying Jensen’s inequality to as to obtain a
lower bound on the log-likelihood,
log p(x(i), y(i)) = log
z=
p(x(i), y(i), z; µ, φ, β)
Kz
≥ log p(y(i); µ) + Eq(i)
Z|Y [log p(x(i) | z; φ) + log p(z | y(i); β) − log q(i)(z)].
We are now ready to apply expectation-maximization. As usual, the E-step updates
the distribution over the missing data, q(i)
Z|Y . The M-step updates the parameters,
βy,z =
Eq [count(y, z)]
PKz
z′= Eq [count(y, z′)]
φz,j =
Eq [count(z, j)]
PV
j′= Eq [count(z, j′)]
Semi-supervised learning
In semi-supervised learning, the learner makes use of both labeled and unlabeled data.
To see how this could help, suppose you want to do sentiment analysis in French. In Ta-
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
ble ., there are two labeled examples, one positive and one negative. From this data, a
learner could conclude that r´eussi is positive and long is negative. This isn’t much! How-
ever, we can propagate this information to the unlabeled data, and potentially learn more.
If we are conﬁdent that r´eussi is positive, then we might guess that (.) is also posi-
tive.
That suggests that parfaitement is also positive.
We can then propagate this information to (.), and learn from the words in this
example.
Similarly, we can propagate from the labeled data to (.), which we guess to be
negative because it shares the word long. This suggests that bavard is also negative,
which we propagate to (.).
Instances (.) and (.) were “similar” to the labeled examples for positivity and negativ-
ity, respectively. By using these instances to expand the models for each class, it became
possible to correctly label instances (.) and (.), which didn’t share any important fea-
tures with the original labeled data. This requires a key assumption: that similar instances
will have similar labels.
In § .., we discussed how expectation-maximization can be applied to semi-supervised
learning. Using the labeled data, the initial parameters φ would assign a high weight for
r´eussi in the positive class, and a high weight for long in the negative class. These weights
helped to shape the distributions q for instances (.) and (.) in the E-step. In the next
iteration of the M-step, the parameters φ are updated with counts from these instances,
making it possible to correctly label the instances (.) and (.).
However, expectation-maximization has an important disadvantage: it requires using
a generative classiﬁcation model, which restricts the features that can be used for clas-
siﬁcation. In this section, we explore non-probabilistic approaches, which impose fewer
restrictions on the classiﬁcation model.
Multi-view learning
EM semi-supervised learning can be viewed as self-training: the labeled data guides the
initial estimates of the classiﬁcation parameters; these parameters are used to compute
a label distribution over the unlabeled instances, q(i); the label distributions are used to
update the parameters. The risk is that self-training drifts away from the original labeled
data. This problem can be ameliorated by multi-view learning. Here we take the as-
sumption that the features can be decomposed into multiple “views”, each of which is
conditionally independent, given the label. For example, consider the problem of classi-
fying a name as a person or location: one view is the name itself; another is the context in
which it appears. This situation is illustrated in Table ..
Jacob Eisenstein. Draft of November , .

.. SEMI-SUPERVISED LEARNING
x()
x()
Peachtree Street
located on
LOC
Dr. Walker
said
PER
Zanzibar
located in
? → LOC
Zanzibar
ﬂew to
? → LOC
Dr. Robert
recommended
? → PER
Oprah
recommended
? → PER
Table .: Example of multiview learning for named entity classiﬁcation
Co-training is an iterative multi-view learning algorithm, in which there are separate
classiﬁers for each view (Blum and Mitchell, ). At each iteration of the algorithm, each
classiﬁer predicts labels for a subset of the unlabeled instances, using only the features
available in its view. These predictions are then used as ground truth to train the classiﬁers
associated with the other views. In the example shown in Table ., the classiﬁer on x()
might correctly label instance # as a person, because of the feature Dr; this instance would
then serve as training data for the classiﬁer on x(), which would then be able to correctly
label instance #, thanks to the feature recommended. If the views are truly independent,
this procedure is robust to drift. Furthermore, it imposes no restrictions on the classiﬁers
that can be used for each view.
Word-sense disambiguation is particularly suited to multi-view learning, thanks to the
heuristic of “one sense per discourse”: if a polysemous word is used more than once in
a given text or conversation, all usages refer to the same sense (Gale et al., ). This
motivates a multi-view learning approach, in which one view corresponds to the local
context (the surrounding words), and another view corresponds to the global context at
the document level (Yarowsky, ). The local context view is ﬁrst trained on a small
seed dataset. We then identify its most conﬁdent predictions on unlabeled instances. The
global context view is then used to extend these conﬁdent predictions to other instances
within the same documents. These new instances are added to the training data to the
local context classiﬁer, which is retrained and then applied to the remaining unlabeled
data.
Graph-based algorithms
Another family of approaches to semi-supervised learning begins by constructing a graph,
in which pairs of instances are linked with symmetric weights ωi,j, e.g.,
ωi,j = exp(−α × ||x(i) − x(j)||).
The goal is to use this weighted graph to propagate labels from a small set of labeled
instances to larger set of unlabeled instances.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
In label propagation, this is done through a series of matrix operations (Zhu et al.,
). Let Q be a matrix of size N × K, in which each row q(i) describes the labeling
of instance i. When ground truth labels are available, then q(i) is an indicator vector,
with q(i)
y(i) =  and q(i)
y′̸=y(i) = . Let us refer to the submatrix of rows containing labeled
instances as QL, and the remaining rows as QU. The rows of QU are initialized to assign
equal probabilities to all labels, qi,k =
K .
Now, let Ti,j represent the “transition” probability of moving from node j to node i,
Ti,j ≜ Pr(j → i) =
ωi,j
PN
k= ωk,j
We compute values of Ti,j for all instances j and all unlabeled instances i, forming a matrix
of size NU × N. If the dataset is large, this matrix may be expensive to store and manip-
ulate; a solution is to sparsify it, by keeping only the κ largest values in each row, and
setting all other values to zero. We can then “propagate” the label distributions to the
unlabeled instances,
˜QU ←TQ
s ← ˜QU
QU ←Diag(s)− ˜QU.
The expression ˜QU indicates multiplication of ˜QU by a column vector of ones, which is
equivalent to computing the sum of each row of ˜QU. The matrix Diag(s) is a diagonal
matrix with the elements of s on the diagonals. The product Diag(s)− ˜QU has the effect
of normalizing the rows of ˜QU, so that each row of QU is a probability distribution over
labels.
Domain adaptation
In many practical scenarios, the labeled data differs in some key respect from the data
to which the trained model is to be applied. A classic example is in consumer reviews:
we may have labeled reviews of movies (the source domain), but we want to predict the
reviews of appliances (the target domain). A similar issue arises with genre differences:
most linguistically-annotated data is news text, but application domains range from social
media to electronic health records. In general, there may be several source and target
domains, each with their own properties; however, for simplicity, this discussion will
focus mainly on the case of a single source and target domain.
The simplest approach is “direct transfer”: train a classiﬁer on the source domain, and
apply it directly to the target domain. The accuracy of this approach depends on the extent
to which features are shared across domains. In review text, words like outstanding and
Jacob Eisenstein. Draft of November , .

.. DOMAIN ADAPTATION
disappointing will apply across both movies and appliances; but others, like terrifying, may
have meanings that are domain-speciﬁc. As a result, direct transfer performs poorly: for
example, an out-of-domain classiﬁer (trained on book reviews) suffers twice the error rate
of an in-domain classiﬁer on reviews of kitchen appliances (Blitzer et al., ). Domain
adaptation algorithms attempt to do better than direct transfer by learning from data in
both domains. There are two main families of domain adaptation algorithms, depending
on whether any labeled data is available in the target domain.
Supervised domain adaptation
In supervised domain adaptation, there is a small amount of labeled data in the target
domain, and a large amount of data in the source domain. The simplest approach would
be to ignore domain differences, and simply merge the training data from the source and
target domains. There are several other baseline approaches to dealing with this sce-
nario (Daum´e III, ):
Interpolation. Train a classiﬁer for each domain, and combine their predictions, e.g.,
ˆy = argmax
λsΨs(x, y) + ( − λs)Ψt(x, y),
where Ψs and Ψt are the scoring functions from the source and target domain clas-
siﬁers respectively, and λs is the interpolation weight.
Prediction. Train a classiﬁer on the source domain data, use its prediction as an additional
feature in a classiﬁer trained on the target domain data,
ˆys = argmax
Ψs(x, y)
ˆyt = argmax
Ψt([x; ˆyS], y).
Priors. Train a classiﬁer on the source domain data, and use its weights as a prior distri-
bution on the weights of the classiﬁer for the target domain data. This is equivalent
to regularizing the target domain weights towards the weights of the source domain
classiﬁer (Chelba and Acero, ),
ℓ(θt) =
i=
ℓ(i)(x(i), y(i); θt) + λ||θt − θs||
where ℓ(i) is the prediction loss on instance i, and λ is the regularization weight.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
An effective and “frustratingly simple” alternative is EASYADAPT (Daum´e III, ),
which creates copies of each feature: one for each domain and one for the cross-domain
setting. For example, a negative review of the ﬁlm Wonder Woman begins, As boring and
ﬂavorless as a three-day-old grilled cheese sandwich.... The resulting bag-of-words feature
vector would be,
f(x, y, d) = {(boring, /, MOVIE) : , (boring, /, ∗) : ,
(ﬂavorless, /, MOVIE) : , (ﬂavorless, /, ∗) : ,
(three-day-old, /, MOVIE) : , (three-day-old, /, ∗) : ,
. . .},
with (boring, /, MOVIE) indicating the word boring appearing in a negative labeled doc-
ument in the MOVIE domain, and (boring, /, ∗) indicating the same word in a negative
labeled document in any domain. It is up to the learner to allocate weight between the
domain-speciﬁc and cross-domain features: for words that facilitate prediction in both
domains, the learner will use the cross-domain features; for words that are relevant only
to a single domain, the domain-speciﬁc features will be used. Any discriminative classi-
ﬁer can be used with these augmented features.
Unsupervised domain adaptation
In unsupervised domain adaptation, there is no labeled data in the target domain. Un-
supervised domain adaptation algorithms cope with this problem by trying to make the
data from the source and target domains as similar as possible. This is typically done by
learning a projection function, which puts the source and target data in a shared space,
in which a learner can generalize across domains. This projection is learned from data in
both domains, and is applied to the base features — for example, the bag-of-words in text
classiﬁcation. The projected features can then be used both for training and for prediction.
Linear projection
In linear projection, the cross-domain representation is constructed by a matrix-vector
product,
g(x(i)) = Ux(i).
The projected vectors g(x(i)) can then be used as base features during both training (from
the source domain) and prediction (on the target domain).
http://www.colesmithey.com/capsules///wonder-woman.HTML, accessed October .
EASYADAPT can be explained as a hierarchical Bayesian model, in which the weights for each domain
are drawn from a shared prior (Finkel and Manning, ).
Jacob Eisenstein. Draft of November , .

.. DOMAIN ADAPTATION
The projection matrix U can be learned in a number of different ways, but many ap-
proaches focus on compressing and reconstructing the base features (Ando and Zhang,
). For example, we can deﬁne a set of pivot features, which are typically chosen be-
cause they appear in both domains: in the case of review documents, pivot features might
include evaluative adjectives like outstanding and disappointing (Blitzer et al., ). For
each pivot feature j, we deﬁne an auxiliary problem of predicting whether the feature is
present in each example, using the remaining base features. Let φj denote the weights of
this classiﬁer, and us horizontally concatenate the weights for each of the Np pivot features
into a matrix Φ = [φ, φ, . . . , φNP ].
We then perform truncated singular value decomposition on Φ, as described in § ..,
obtaining Φ ≈ USV⊤. The rows of the matrix U summarize information about each base
feature: indeed, the truncated singular value decomposition identiﬁes a low-dimension
basis for the weight matrix Φ, which in turn links base features to pivot features. Sup-
pose that a base feature reliable occurs only in the target domain of appliance reviews.
Nonetheless, it will have a positive weight towards some pivot features (e.g., outstanding,
recommended), and a negative weight towards others (e.g., worthless, unpleasant). A base
feature such as watchable might have the same associations with the pivot features, and
therefore, ureliable ≈ uwatchable. The matrix U can thus project the base features into a
space in which this information is shared.
Non-linear projection
Non-linear transformations of the base features can be accomplished by implementing
the transformation function as a deep neural network, which is trained from an auxiliary
objective.
Denoising objectives
One possibility is to train a projection function to reconstruct a
corrupted version of the original input. The original input can be corrupted in various
ways: by the addition of random noise (Glorot et al., ; Chen et al., ), or by the
deletion of features (Chen et al., ; Yang and Eisenstein, ). Denoising objectives
share many properties of the linear projection method described above: they enable the
projection function to be trained on large amounts of unlabeled data from the target do-
main, and allow information to be shared across the feature space, thereby reducing sen-
sitivity to rare and domain-speciﬁc features.
Adversarial objectives
The ultimate goal is for the transformed representations g(x(i))
to be domain-general. This can be made an explicit optimization criterion by comput-
ing the similarity of transformed instances both within and between domains (Tzeng
et al., ), or by formulating an auxiliary classiﬁcation task, in which the domain it-
self is treated as a label (Ganin et al., ). This setting is adversarial, because we want
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
ℓy
y(i)
g(x)
ℓd
d(i)
Figure .: A schematic view of adversarial domain adaptation. The loss ℓy is computed
only for instances from the source domain, where labels y(i) are available.
to learn a representation that makes this classiﬁer perform poorly. At the same time, we
want g(x(i)) to enable accurate predictions of the labels y(i).
To formalize this idea, let d(i) represent the domain of instance i, and let ℓd(g(x(i)), d(i); θd)
represent the loss of a classiﬁer (typically a deep neural network) trained to predict d(i)
from the transformed representation g(x(i)), using parameters θd. Analogously, let ℓy(g(x(i)), y(i); θy)
represent the loss of a classiﬁer trained to predict the label y(i) from g(x(i)), using param-
eters θy. The transformation g can then be trained from two criteria: it should yield accu-
rate predictions of the labels y(i), while making inaccurate predictions of the domains d(i).
This can be formulated as a joint optimization problem,
min
θgθy,θd
i=
ℓd(g(x(i); θg), d(i); θd) −
i=
ℓy(g(x(i); θg), y(i); θy),
Nℓ+Nu
Nℓ
where Nℓ is the number of labeled instances and Nu is the number of unlabeled instances,
with the labeled instances appearing ﬁrst in the dataset. This setup is shown in Figure ..
The loss can be optimized by stochastic gradient descent, jointly training the parameters
of the non-linear transformation θg, and the parameters of the prediction models θd and
θy.
*Other approaches to learning with latent variables
Expectation-maximization provides a general approach to learning with latent variables,
but it has limitations. One is the sensitivity to initialization; in practical applications,
considerable attention may need to be devoted to ﬁnding a good initialization. A second
issue is that EM tends to be easiest to apply in cases where the latent variables have a clear
decomposition (in the cases we have considered, they decompose across the instances).
For these reasons, it is worth brieﬂy considering some alternatives to EM.
Jacob Eisenstein. Draft of November , .

.. *OTHER APPROACHES TO LEARNING WITH LATENT VARIABLES
Sampling
In EM clustering, there is a distribution q(i) for the missing data related to each instance.
The M-step consists of updating the parameters of this distribution. An alternative is to
draw samples of the latent variables. If the sampling distribution is designed correctly,
this procedure will eventually converge to drawing samples from the true posterior over
the missing data, p(z(:Nz) | x(:Nx)). For example, in the case of clustering, the missing
data z(:Nz) is the set of cluster memberships, y(:N), so we draw samples from the pos-
terior distribution over clusterings of the data. If a single clustering is required, we can
select the one with the highest conditional likelihood, ˆz = argmaxz p(z(:Nz) | x(:Nx)).
This general family of algorithms is called Markov Chain Monte Carlo (MCMC):
“Monte Carlo” because it is based on a series of random draws; “Markov Chain” because
the sampling procedure must be designed such that each sample depends only on the
previous sample, and not on the entire sampling history. Gibbs sampling is an MCMC
algorithm in which each latent variable is sampled from its posterior distribution,
z(n) | x, z(−n) ∼ p(z(n) | x, z(−n)),
where z(−n) indicates {z\z(n)}, the set of all latent variables except for z(n). Repeatedly
drawing samples over all latent variables constructs a Markov chain that is guaranteed
to converge to a sequence of samples from p(z(:Nz) | x(:Nx)). In probabilistic clustering,
the sampling distribution has the following form,
p(z(i) | x, z(−i)) = p(x(i) | z(i); φ) × p(z(i); µ)
PK
z= p(x(i) | z; φ) × p(z; µ)
∝Multinomial(x(i); φz(i)) × µz(i).
In this case, the sampling distribution does not depend on the other instances: the poste-
rior distribution over each z(i) can be computed from x(i) and the parameters given the
parameters φ and µ.
In sampling algorithms, there are several choices for how to deal with the parameters.
One possibility is to sample them too. To do this, we must add them to the generative
story, by introducing a prior distribution. For the multinomial and categorical parameters
in the EM clustering model, the Dirichlet distribution is a typical choice, since it deﬁnes
a probability on exactly the set of vectors that can be parameters: vectors that sum to one
and include only non-negative numbers.
To incorporate this prior, the generative model must be augmented to indicate that
each φz ∼ Dirichlet(αφ), and µ ∼ Dirichlet(αµ). The hyperparameters α are typically set
to a constant vector α = [α, α, . . . , α]. When α is large, the Dirichlet distribution tends to
If PK
i θi =  and θi ≥  for all i, then θ is said to be on the K −  simplex. A Dirichlet distribution with
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
generate vectors that are nearly uniform; when α is small, it tends to generate vectors that
assign most of their probability mass to a few entries. Given prior distributions over φ
and µ, we can now include them in Gibbs sampling, drawing values for these parameters
from posterior distributions that are conditioned on the other variables in the model.
Unfortunately, sampling φ and µ usually leads to slow “mixing”, meaning that adja-
cent samples tend to be similar, so that a large number of samples is required to explore
the space of random variables. The reason is that the sampling distributions for the pa-
rameters are tightly constrained by the cluster memberships y(i), which in turn are tightly
constrained by the parameters. There are two solutions that are frequently employed:
Empirical Bayesian methods maintain φ and µ as parameters rather than latent
variables. They still employ sampling in the E-step of the EM algorithm, but they
update the parameters using expected counts that are computed from the samples
rather than from parametric distributions. This EM-MCMC hybrid is also known
as Monte Carlo Expectation Maximization (MCEM; Wei and Tanner, ), and is
well-suited for cases in which it is difﬁcult to compute q(i) directly.
In collapsed Gibbs sampling, we analytically integrate φ and µ out of the model.
The cluster memberships y(i) are the only remaining latent variable; we sample them
from the compound distribution,
φ,µ
p(φ, µ | y(−i), x(:N); αφ, αµ)p(y(i) | x(:N), y(−i), φ, µ)dφdµ.
p(y(i) | x(:N), y(−i); αφ, αµ) =
For multinomial and Dirichlet distributions, this integral can be computed in closed
form.
MCMC algorithms are guaranteed to converge to the true posterior distribution over
the latent variables, but there is no way to know how long this will take. In practice, the
rate of convergence depends on initialization, just as expectation-maximization depends
on initialization to avoid local optima. Thus, while Gibbs Sampling and other MCMC
algorithms provide a powerful and ﬂexible array of techniques for statistical inference in
latent variable models, they are not a panacea for the problems experienced by EM.
parameter α ∈ RK
+ has support over the K −  simplex,
B(α)
pDirichlet(θ | α) =
i=
θαi−
B(α) =
QK
i= Γ(αi)
Γ(PK
i= αi)
with Γ() indicating the gamma function, a generalization of the factorial function to non-negative reals.
Jacob Eisenstein. Draft of November , .

.. *OTHER APPROACHES TO LEARNING WITH LATENT VARIABLES
Spectral learning
Another approach to learning with latent variables is based on the method of moments,
which makes it possible to avoid the problem of non-convex log-likelihood. Write x(i) for
the normalized vector of word counts in document i, so that x(i) = x(i)/ PV
j= x(i)
j . Then
we can form a matrix of word-word co-occurrence probabilities,
C =
x(i)(x(i))⊤.
i=
The expected value of this matrix under p(x | φ, µ), as
E[C] =
i=
k=
Pr(Z(i) = k; µ)φkφ⊤
Nµkφkφ⊤
=ΦDiag(Nµ)Φ⊤,
where Φ is formed by horizontally concatenating φ . . . φK, and Diag(Nµ) indicates a
diagonal matrix with values Nµk at position (k, k). Setting C equal to its expectation
gives,
C =ΦDiag(Nµ)Φ⊤,
which is similar to the eigendecomposition C = QΛQ⊤. This suggests that simply by
ﬁnding the eigenvectors and eigenvalues of C, we could obtain the parameters φ and µ,
and this is what motivates the name spectral learning.
While moment-matching and eigendecomposition are similar in form, they impose
different constraints on the solutions: eigendecomposition requires orthonormality, so
that QQ⊤ = I; in estimating the parameters of a text clustering model, we require that µ
and the columns of Φ are probability vectors. Spectral learning algorithms must therefore
include a procedure for converting the solution into vectors that are non-negative and
sum to one. One approach is to replace eigendecomposition (or the related singular value
decomposition) with non-negative matrix factorization (Xu et al., ), which guarantees
that the solutions are non-negative (Arora et al., ).
After obtaining the parameters φ and µ, the distribution over clusters can be com-
puted from Bayes’ rule:
p(z(i) | x(i); φ, µ) ∝ p(x(i) | z(i); φ) × p(z(i); µ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
Spectral learning yields provably good solutions without regard to initialization, and can
be quite fast in practice. However, it is more difﬁcult to apply to a broad family of genera-
tive models than EM and Gibbs Sampling. For more on applying spectral learning across
a range of latent variable models, see Anandkumar et al. ().
Additional resources
There are a number of other learning paradigms that deviate from supervised learning.
Active learning: the learner selects unlabeled instances and requests annotations (Set-
tles, ).
Multiple instance learning: labels are applied to bags of instances, with a positive
label applied if at least one instance in the bag meets the criterion (Dietterich et al.,
; Maron and Lozano-P´erez, ).
Constraint-driven learning: supervision is provided in the form of explicit con-
straints on the learner (Chang et al., ; Ganchev et al., ).
Distant supervision: noisy labels are generated from an external resource (Mintz
et al., , also see § ..).
Multitask learning: the learner induces a representation that can be used to solve
multiple classiﬁcation tasks (Collobert et al., ).
Transfer learning: the learner must solve a classiﬁcation task that differs from the
labeled data (Pan and Yang, ).
Expectation-maximization was introduced by Dempster et al. (), and is discussed
in more detail by Murphy (). Like most machine learning treatments, Murphy focuses
on continuous observations and Gaussian likelihoods, rather than the discrete observa-
tions typically encountered in natural language processing. Murphy () also includes
an excellent chapter on MCMC; for a textbook-length treatment, see Robert and Casella
(). For still more on Bayesian latent variable models, see Barber (), and for ap-
plications of Bayesian models to natural language processing, see Cohen (). Surveys
are available for semi-supervised learning (Zhu and Goldberg, ) and domain adapta-
tion (Søgaard, ), although both pre-date the current wave of interest in deep learning.
Exercises
. Derive the expectation maximization update for the parameter µ in the EM cluster-
ing model.
Jacob Eisenstein. Draft of November , .

.. *OTHER APPROACHES TO LEARNING WITH LATENT VARIABLES
. Derive the E-step and M-step updates for the following generative model. You may
assume that the labels y(i) are observed, but z(i)
m is not.
For each instance i,
– Draw label y(i) ∼ Categorical(µ)
– For each token m ∈ {, , . . . , M(i)}
∗ Draw z(i)
m ∼ Categorical(π)
∗ If z(i)
m = , draw the current token from a label-speciﬁc distribution,
w(i)
m ∼ φy(i)
∗ If z(i)
m = , draw the current token from a document-speciﬁc distribu-
tion, w(i)
m ∼ ν(i)
. Using the iterative updates in Equations .-., compute the outcome of the label
propagation algorithm for the following examples.
The value inside the node indicates the label, y(i) ∈ {, }, with y(i) =? for unlabeled
nodes. The presence of an edge between two nodes indicates wi,j = , and the
absence of an edge indicates wi,j = . For the third example, you need only compute
the ﬁrst three iterations, and then you can guess at the solution in the limit.
. Use expectation-maximization clustering to train a word-sense induction system,
applied to the word say.
Import NLTK, run NLTK.DOWNLOAD() and select SEMCOR. Import SEMCOR
from NLTK.CORPUS.
The command SEMCOR.TAGGED SENTENCES(TAG=’SENSE’) returns an itera-
tor over sense-tagged sentences in the corpus. Each sentence can be viewed
as an iterator over TREE objects. For TREE objects that are sense-annotated
words, you can access the annotation as TREE.LABEL(), and the word itself with
TREE.LEAVES(). So SEMCOR.TAGGED SENTENCES(TAG=’SENSE’)[][].LABEL()
would return the sense annotation of the third word in the ﬁrst sentence.
Extract all sentences containing the senses SAY.V. and SAY.V..
Build bag-of-words vectors x(i), containing the counts of other words in those
sentences, including all words that occur in at least two sentences.
Implement and run expectation-maximization clustering on the merged data.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LEARNING WITHOUT SUPERVISION
Compute the frequency with which each cluster includes instances of SAY.V.
and SAY.V..
In the remaining exercises, you will try out some approaches for semisupervised learn-
ing and domain adaptation. You will need datasets in multiple domains. You can obtain
product reviews in multiple domains here: https://www.cs.jhu.edu/˜mdredze/
datasets/sentiment/processed_acl.tar.gz. Choose a source and target domain,
e.g. dvds and books, and divide the data for the target domain into training and test sets
of equal size.
. First, quantify the cost of cross-domain transfer.
Train a logistic regression classiﬁer on the source domain training set, and eval-
uate it on the target domain test set.
Train a logistic regression classiﬁer on the target domain training set, and eval-
uate it on the target domain test set. This it the “direct transfer” baseline.
Compute the difference in accuracy, which is a measure of the transfer loss across
domains.
. Next, apply the label propagation algorithm from § ...
As a baseline, using only % of the target domain training set, train a classiﬁer, and
compute its accuracy on the target domain test set.
Next, apply label propagation:
Compute the label matrix QL for the labeled data (% of the target domain
training set), with each row equal to an indicator vector for the label (positive
or negative).
Iterate through the target domain instances, including both test and training
data. At each instance i, compute all wij, using Equation ., with α = ..
Use these values to ﬁll in column i of the transition matrix T, setting all but the
ten largest values to zero for each column i. Be sure to normalize the column
so that the remaining values sum to one. You may need to use a sparse matrix
for this to ﬁt into memory.
Apply the iterative updates from Equations .-. to compute the outcome
of the label propagation algorithm for the unlabeled examples.
Select the test set instances from QU, and compute the accuracy of this method.
Compare with the supervised classiﬁer trained only on the % sample of the target
domain training set.
Jacob Eisenstein. Draft of November , .

.. *OTHER APPROACHES TO LEARNING WITH LATENT VARIABLES
. Using only % of the target domain training data (and all of the source domain train-
ing data), implement one of the supervised domain adaptation baselines in § ...
See if this improves on the “direct transfer” baseline from the previous problem
. Implement EASYADAPT (§ ..), again using % of the target domain training data
and all of the source domain data.
. Now try unsupervised domain adaptation, using the “linear projection” method
described in § ... Speciﬁcally:
Identify  pivot features as the words with the highest frequency in the (com-
plete) training data for the source and target domains. Speciﬁcally, let xd
i be the
count of the word i in domain d: choose the  words with the largest values
of min(xsource
, xtarget
Train a classiﬁer to predict each pivot feature from the remaining words in the
document.
Arrange the features of these classiﬁers into a matrix Φ, and perform truncated
singular value decomposition, with k =
Train a classiﬁer from the source domain data, using the combined features
x(i) ⊕ U⊤x(i) — these include the original bag-of-words features, plus the pro-
jected features.
Apply this classiﬁer to the target domain test set, and compute the accuracy.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Part II
Sequences and trees
Chapter
Language models
In probabilistic classiﬁcation, the problem is to compute the probability of a label, condi-
tioned on the text. Let’s now consider the inverse problem: computing the probability of
text itself. Speciﬁcally, we will consider models that assign probability to a sequence of
word tokens, p(w, w, . . . , wM), with wm ∈ V. The set V is a discrete vocabulary,
V = {aardvark, abacus, . . . , zither}.
Why would you want to compute the probability of a word sequence? In many appli-
cations, the goal is to produce word sequences as output:
In machine translation (chapter ), we convert from text in a source language to
text in a target language.
In speech recognition, we convert from audio signal to text.
In summarization (§ ..; § .), we convert from long texts into short texts.
In dialogue systems (§ .), we convert from the user’s input (and perhaps an
external knowledge base) into a text response.
In many of the systems for performing these tasks, there is a subcomponent that com-
putes the probability of the output text. The purpose of this component is to generate
texts that are more ﬂuent. For example, suppose we want to translate a sentence from
Spanish to English.
El cafe negro me gusta mucho.
Here is a literal word-for-word translation (a gloss):
The coffee black me pleases much.
CHAPTER . LANGUAGE MODELS
A good language model of English will tell us that the probability of this translation is
low, in comparison with more grammatical alternatives,
p(The coffee black me pleases much) < p(I love dark coffee).
How can we use this fact? Warren Weaver, one of the early leaders in machine trans-
lation, viewed it as a problem of breaking a secret code (Weaver, ):
When I look at an article in Russian, I say: ’This is really written in English,
but it has been coded in some strange symbols. I will now proceed to decode.’
This observation motivates a generative model (like Na¨ıve Bayes):
The English sentence w(e) is generated from a language model, pe(w(e)).
The Spanish sentence w(s) is then generated from a translation model, ps|e(w(s) | w(e)).
Given these two distributions, translation can be performed by Bayes’ rule:
pe|s(w(e) | w(s)) ∝pe,s(w(e), w(s))
=ps|e(w(s) | w(e)) × pe(w(e)).
This is sometimes called the noisy channel model, because it envisions English text
turning into Spanish by passing through a noisy channel, ps|e. What is the advantage of
modeling translation this way, as opposed to modeling pe|s directly? The crucial point is
that the two distributions ps|e (the translation model) and pe (the language model) can be
estimated from separate data. The translation model requires examples of correct trans-
lations, but the language model requires only text in English. Such monolingual data is
much more widely available. Furthermore, once estimated, the language model pe can
be reused in any application that involves generating English text, including translation
from other languages.
N-gram language models
A simple approach to computing the probability of a sequence of tokens is to use a relative
frequency estimate. Consider the quote, attributed to Picasso, “computers are useless, they
can only give you answers.” One way to estimate the probability of this sentence is,
p(Computers are useless, they can only give you answers)
= count(Computers are useless, they can only give you answers)
count(all sentences ever spoken)
Jacob Eisenstein. Draft of November , .

.. N-GRAM LANGUAGE MODELS
This estimator is unbiased: in the theoretical limit of inﬁnite data, the estimate will
be correct. But in practice, we are asking for accurate counts over an inﬁnite number of
events, since sequences of words can be arbitrarily long. Even with an aggressive upper
bound of, say, M =  tokens in the sequence, the number of possible sequences is V ,
where V = |V|. A small vocabularly for English would have V = , so there are
possible sequences. Clearly, this estimator is very data-hungry, and suffers from high vari-
ance: even grammatical sentences will have probability zero if they have not occurred in
the training data. We therefore need to introduce bias to have a chance of making reli-
able estimates from ﬁnite training data. The language models that follow in this chapter
introduce bias in various ways.
We begin with n-gram language models, which compute the probability of a sequence
as the product of probabilities of subsequences. The probability of a sequence p(w) =
p(w, w, . . . , wM) can be refactored using the chain rule (see § A.):
p(w) =p(w, w, . . . , wM)
=p(w) × p(w | w) × p(w | w, w) × . . . × p(wM | wM−, . . . , w)
Each element in the product is the probability of a word given all its predecessors. We
can think of this as a word prediction task: given the context Computers are, we want to com-
pute a probability over the next token. The relative frequency estimate of the probability
of the word useless in this context is,
p(useless | computers are) = count(computers are useless)
x∈V count(computers are x)
= count(computers are useless)
count(computers are)
We haven’t made any approximations yet, and we could have just as well applied the
chain rule in reverse order,
p(w) = p(wM) × p(wM− | wM) × . . . × p(w | w, . . . , wM),
or in any other order. But this means that we also haven’t really made any progress:
to compute the conditional probability p(wM | wM−, wM−, . . . , w), we would need to
model V M− contexts. Such a distribution cannot be estimated from any realistic sample
of text.
To solve this problem, n-gram models make a crucial simplifying approximation: they
condition on only the past n −  words.
p(wm | wm− . . . w) ≈p(wm | wm−, . . . , wm−n+)
Chomsky famously argued that this is evidence against the very concept of probabilistic language mod-
els: no such model could distinguish the grammatical sentence colorless green ideas sleep furiously from the
ungrammatical permutation furiously sleep ideas green colorless.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
This means that the probability of a sentence w can be approximated as
p(w, . . . , wM) ≈
m=
p(wm | wm−, . . . , wm−n+)
To compute the probability of an entire sentence, it is convenient to pad the beginning
and end with special symbols □ and ■. Then the bigram (n = ) approximation to the
probability of I like black coffee is:
p(I like black coffee) = p(I | □) × p(like | I) × p(black | like) × p(coffee | black) × p(■ | coffee).
This model requires estimating and storing the probability of only V n events, which is
exponential in the order of the n-gram, and not V M, which is exponential in the length of
the sentence. The n-gram probabilities can be computed by relative frequency estimation,
p(wm | wm−, wm−) =
count(wm−, wm−, wm)
w′ count(wm−, wm−, w′)
The hyperparameter n controls the size of the context used in each conditional proba-
bility. If this is misspeciﬁed, the language model will perform poorly. Let’s consider the
potential problems concretely.
When n is too small. Consider the following sentences:
Gorillas always like to groom their friends.
The computer that’s on the rd ﬂoor of our ofﬁce building crashed.
In each example, the words written in bold depend on each other: the likelihood
of their depends on knowing that gorillas is plural, and the likelihood of crashed de-
pends on knowing that the subject is a computer. If the n-grams are not big enough
to capture this context, then the resulting language model would offer probabili-
ties that are too low for these sentences, and too high for sentences that fail basic
linguistic tests like number agreement.
When n is too big. In this case, it is hard good estimates of the n-gram parameters from
our dataset, because of data sparsity. To handle the gorilla example, it is necessary to
model -grams, which means accounting for V  events. Under a very small vocab-
ulary of V = , this means estimating the probability of  distinct events.
Jacob Eisenstein. Draft of November , .

.. SMOOTHING AND DISCOUNTING
These two problems point to another bias-variance tradeoff (see § ..). A small n-
gram size introduces high bias, and a large n-gram size introduces high variance. We
can even have both problems at the same time! Language is full of long-range dependen-
cies that we cannot capture because n is too small; at the same time, language datasets
are full of rare phenomena, whose probabilities we fail to estimate accurately because n
is too large. One solution is to try to keep n large, while still making low-variance esti-
mates of the underlying parameters. To do this, we will introduce a different sort of bias:
smoothing.
Smoothing and discounting
Limited data is a persistent problem in estimating language models. In § ., we pre-
sented n-grams as a partial solution. Bit sparse data can be a problem even for low-order
n-grams; at the same time, many linguistic phenomena, like subject-verb agreement, can-
not be incorporated into language models without high-order n-grams. It is therefore
necessary to add additional inductive biases to n-gram language models. This section
covers some of the most intuitive and common approaches, but there are many more (see
Chen and Goodman, ).
Smoothing
A major concern in language modeling is to avoid the situation p(w) = , which could
arise as a result of a single unseen n-gram. A similar problem arose in Na¨ıve Bayes, and
the solution was smoothing: adding imaginary “pseudo” counts. The same idea can be
applied to n-gram language models, as shown here in the bigram case,
psmooth(wm | wm−) =
count(wm−, wm) + α
w′∈V count(wm−, w′) + V α.
This basic framework is called Lidstone smoothing, but special cases have other names:
Laplace smoothing corresponds to the case α = .
Jeffreys-Perks law corresponds to the case α = ., which works well in practice
and beneﬁts from some theoretical justiﬁcation (Manning and Sch¨utze, ).
To ensure that the probabilities are properly normalized, anything that we add to the
numerator (α) must also appear in the denominator (V α). This idea is reﬂected in the
concept of effective counts:
c∗
i = (ci + α)
M + V α,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
Lidstone smoothing, α = .
Discounting, d = .
counts
unsmoothed
probability
effective
counts
smoothed
probability
effective
counts
smoothed
probability
impropriety
offense
damage
deﬁciencies
outbreak
inﬁrmity
cephalopods
Table .: Example of Lidstone smoothing and absolute discounting in a bigram language
model, for the context (alleged, ), for a toy corpus with a total of twenty counts over the
seven words shown. Note that discounting decreases the probability for all but the un-
seen words, while Lidstone smoothing increases the effective counts and probabilities for
deﬁciencies and outbreak.
where ci is the count of event i, c∗
i is the effective count, and M = PV
i= ci is the total num-
ber of tokens in the dataset (w, w, . . . , wM). This term ensures that PV
i= c∗
i = PV
i= ci = M.
The discount for each n-gram is then computed as,
(M + V α).
di = c∗
ci
= (ci + α)
ci
Discounting and backoff
Discounting “borrows” probability mass from observed n-grams and redistributes it. In
Lidstone smoothing, the borrowing is done by increasing the denominator of the relative
frequency estimates. The borrowed probability mass is then redistributed by increasing
the numerator for all n-grams. Another approach would be to borrow the same amount
of probability mass from all observed n-grams, and redistribute it among only the unob-
served n-grams. This is called absolute discounting. For example, suppose we set an
absolute discount d = . in a bigram model, and then redistribute this probability mass
equally over the unseen words. The resulting probabilities are shown in Table ..
Discounting reserves some probability mass from the observed data, and we need not
redistribute this probability mass equally. Instead, we can backoff to a lower-order lan-
guage model: if you have trigrams, use trigrams; if you don’t have trigrams, use bigrams;
if you don’t even have bigrams, use unigrams. This is called Katz backoff. In the simple
Jacob Eisenstein. Draft of November , .

.. SMOOTHING AND DISCOUNTING
case of backing off from bigrams to unigrams, the bigram probabilities are,
c∗(i, j) =c(i, j) − d
c∗(i,j)
c(j)
if c(i, j) >
pKatz(i | j) =
α(j) ×
punigram(i)
i′:c(i′,j)= punigram(i′)
if c(i, j) = .
The term α(j) indicates the amount of probability mass that has been discounted for
context j. This probability mass is then divided across all the unseen events, {i′ : c(i′, j) =
}, proportional to the unigram probability of each word i′. The discount parameter d can
be optimized to maximize performance (typically held-out log-likelihood) on a develop-
ment set.
*Interpolation
Backoff is one way to combine different order n-gram models. An alternative approach
is interpolation: setting the probability of a word in context to a weighted sum of its
probabilities across progressively shorter contexts.
Instead of choosing a single n for the size of the n-gram, we can take the weighted
average across several n-gram probabilities. For example, for an interpolated trigram
model,
pInterpolation(wm | wm−, wm−) = λp∗
(wm | wm−, wm−)
+ λp∗
(wm | wm−)
+ λp∗
(wm).
In this equation, p∗
n is the unsmoothed empirical probability given by an n-gram lan-
guage model, and λn is the weight assigned to this model. To ensure that the interpolated
p(w) is still a valid probability distribution, the values of λ must obey the constraint,
Pnmax
n= λn = . But how to ﬁnd the speciﬁc values?
An elegant solution is expectation-maximization. Recall from chapter  that we can
think about EM as learning with missing data: we just need to choose missing data such
that learning would be easy if it weren’t missing. What’s missing in this case? Think of
each word wm as drawn from an n-gram of unknown size, zm ∈ { . . . nmax}. This zm is
the missing data that we are looking for. Therefore, the application of EM to this problem
involves the following generative model:
for Each token wm, m = , , . . . , M do:
draw the n-gram size zm ∼ Categorical(λ);
draw wm ∼ p∗
zm(wm | wm−, . . . , wm−zm).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
If the missing data {Zm} were known, then λ could be estimated as the relative fre-
quency,
λz =count(Zm = z)
m=
δ(Zm = z).
But since we do not know the values of the latent variables Zm, we impute a distribution
qm in the E-step, which represents the degree of belief that word token wm was generated
from a n-gram of order zm,
qm(z) ≜ Pr(Zm = z | w:m; λ)
p(wm | w:m−, Zm = z) × p(z)
z′ p(wm | w:m−, Zm = z′) × p(z′)
∝p∗
z(wm | w:m−) × λz.
In the M-step, λ is computed by summing the expected counts under q,
λz ∝
m=
qm(z).
A solution is obtained by iterating between updates to q and λ. The complete algorithm
is shown in Algorithm .
Algorithm  Expectation-maximization for interpolated language modeling
: procedure ESTIMATE INTERPOLATED n-GRAM (w:M, {p∗
n}n∈:nmax)
for z ∈ {, , . . . , nmax} do
▷ Initialization
nmax
λz ←
repeat
for m ∈ {, , . . . , M} do
▷ E-step
for z ∈ {, , . . . , nmax} do
qm(z) ← p∗
z(wm | w:m−) × λz
qm ← Normalize(qm)
for z ∈ {, , . . . , nmax} do
▷ M-step
until tired
λz ←
PM
m= qm(z)
return λ
Jacob Eisenstein. Draft of November , .

.. RECURRENT NEURAL NETWORK LANGUAGE MODELS
*Kneser-Ney smoothing
Kneser-Ney smoothing is based on absolute discounting, but it redistributes the result-
ing probability mass in a different way from Katz backoff. Empirical evidence points
to Kneser-Ney smoothing as the state-of-art for n-gram language modeling (Goodman,
To motivate Kneser-Ney smoothing, consider the example: I recently visited .
Which of the following is more likely: Francisco or Duluth?
Now suppose that both bigrams visited Duluth and visited Francisco are unobserved in
the training data, and furthermore, that the unigram probability p∗
(Francisco) is greater
than p∗
(Duluth). Nonetheless we would still guess that p(visited Duluth) > p(visited Francisco),
because Duluth is a more “versatile” word: it can occur in many contexts, while Francisco
usually occurs in a single context, following the word San. This notion of versatility is the
key to Kneser-Ney smoothing.
Writing u for a context of undeﬁned length, and count(w, u) as the count of word w in
context u, we deﬁne the Kneser-Ney bigram probability as
count(u)
count(w, u) >
pKN(w | u) =
( max(count(w,u)−d,)
α(u) × pcontinuation(w),
otherwise
pcontinuation(w) =
|u : count(w, u) > |
w′∈V |u′ : count(w′, u′) > |.
Probability mass using absolute discounting d, which is taken from all unobserved
n-grams. The total amount of discounting in context u is d × |w : count(w, u) > |, and
we divide this probability mass among the unseen n-grams. To account for versatility,
we deﬁne the continuation probability pcontinuation(w) as proportional to the number of ob-
served contexts in which w appears. The numerator of the continuation probability is the
number of contexts u in which w appears; the denominator normalizes the probability by
summing the same quantity over all words w′. The coefﬁcient α(u) is set to ensure that
the probability distribution pKN(w | u) sums to one over the vocabulary w.
The idea of modeling versatility by counting contexts may seem heuristic, but there is
an elegant theoretical justiﬁcation from Bayesian nonparametrics (Teh, ). Kneser-Ney
smoothing on n-grams was the dominant language modeling technique before the arrival
of neural language models.
Recurrent neural network language models
N-gram language models have been largely supplanted by neural networks. These mod-
els do not make the n-gram assumption of restricted context; indeed, they can incorporate
arbitrarily distant contextual information, while remaining computationally and statisti-
cally tractable.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
Figure .: The recurrent neural network language model, viewed as an “unrolled” com-
putation graph. Solid lines indicate direct computation, dotted blue lines indicate proba-
bilistic dependencies, circles indicate random variables, and squares indicate computation
nodes.
The ﬁrst insight behind neural language models is to treat word prediction as a dis-
criminative learning task. The goal is to compute the probability p(w | u), where w ∈ V is
a word, and u is the context, which depends on the previous words. Rather than directly
estimating the word probabilities from (smoothed) relative frequencies, we can treat treat
language modeling as a machine learning problem, and estimate parameters that maxi-
mize the log conditional probability of a corpus.
The second insight is to reparametrize the probability distribution p(w | u) as a func-
tion of two dense K-dimensional numerical vectors, βw ∈ RK, and vu ∈ RK,
p(w | u) =
exp(βw  vu)
w′∈V exp(βw′  vu),
where βw  vu represents a dot product. As usual, the denominator ensures that the prob-
ability distribution is properly normalized. This vector of probabilities is equivalent to
applying the softmax transformation (see § .) to the vector of dot-products,
p( | u) = SoftMax([β  vu, β  vu, . . . , βV  vu]).
The word vectors βw are parameters of the model, and are estimated directly. The
context vectors vu can be computed in various ways, depending on the model. A simple
but effective neural language model can be built from a recurrent neural network (RNN;
Mikolov et al., ). The basic idea is to recurrently update the context vectors while
moving through the sequence. Let hm represent the contextual information at position m
This idea predates neural language models (e.g., Rosenfeld, ; Roark et al., ).
Jacob Eisenstein. Draft of November , .

.. RECURRENT NEURAL NETWORK LANGUAGE MODELS
in the sequence. RNN language models are deﬁned,
xm ≜φwm
hm =RNN(xm, hm−)
p(wm+ | w, w, . . . , wm) =
exp(βwm+  hm)
w′∈V exp(βw′  hm),
where φ is a matrix of word embeddings, and xm denotes the embedding for word wm.
The conversion of wm to xm is sometimes known as a lookup layer, because we simply
lookup the embeddings for each word in a table; see § ...
The Elman unit deﬁnes a simple recurrent operation (Elman, ),
RNN(xm, hm−) ≜ g(Θhm− + xm),
where Θ ∈ RK×K is the recurrence matrix and g is a non-linear transformation function,
often deﬁned as the elementwise hyperbolic tangent tanh (see § .). The tanh acts as a
squashing function, ensuring that each element of hm is constrained to the range [−, ].
Although each wm depends on only the context vector hm−, this vector is in turn
inﬂuenced by all previous tokens, w, w, . . . wm−, through the recurrence operation: w
affects h, which affects h, and so on, until the information is propagated all the way to
hm−, and then on to wm (see Figure .). This is an important distinction from n-gram
language models, where any information outside the n-word window is ignored. In prin-
ciple, the RNN language model can handle long-range dependencies, such as number
agreement over long spans of text — although it would be difﬁcult to know where exactly
in the vector hm this information is represented. The main limitation is that informa-
tion is attenuated by repeated application of the squashing function g. Long short-term
memories (LSTMs), described below, are a variant of RNNs that address this issue, us-
ing memory cells to propagate information through the sequence without applying non-
linearities (Hochreiter and Schmidhuber, ).
The denominator in Equation . is a computational bottleneck, because it involves
a sum over the entire vocabulary. One solution is to use a hierarchical softmax function,
which computes the sum more efﬁciently by organizing the vocabulary into a tree (Mikolov
et al., ). Another strategy is to optimize an alternative metric, such as noise-contrastive
estimation (Gutmann and Hyv¨arinen, ), which learns by distinguishing observed in-
stances from artiﬁcial instances generated from a noise distribution (Mnih and Teh, ).
Both of these strategies are described in § ...
In the original Elman network, the sigmoid function was used in place of tanh. For an illuminating
mathematical discussion of the advantages and disadvantages of various nonlinearities in recurrent neural
networks, see the lecture notes from Cho ().
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
Backpropagation through time
The recurrent neural network language model has the following parameters:
φi ∈ RK, the “input” word vectors (these are sometimes called word embeddings,
since each word is embedded in a K-dimensional space; see chapter );
βi ∈ RK, the “output” word vectors;
Θ ∈ RK×K, the recurrence operator;
h, the initial state.
Each of these parameters can be estimated by formulating an objective function over the
training corpus, L(w), and then applying backpropagation to obtain gradients on the
parameters from a minibatch of training examples (see § ..). Gradient-based updates
can be computed from an online learning algorithm such as stochastic gradient descent
(see § ..).
The application of backpropagation to recurrent neural networks is known as back-
propagation through time, because the gradients on units at time m depend in turn on the
gradients of units at earlier times n < m. Let ℓm+ represent the negative log-likelihood
of word m + ,
ℓm+ = − log p(wm+ | w, w, . . . , wm).
We require the gradient of this loss with respect to each parameter, such as θk,k′, an indi-
vidual element in the recurrence matrix Θ. Since the loss depends on the parameters only
through hm, we can apply the chain rule of differentiation,
∂hm
∂ℓm+
∂θk,k′ =∂ℓm+
∂hm
∂θk,k′ .
The vector hm depends on Θ in several ways. First, hm is computed by multiplying Θ by
the previous state hm−. But the previous state hm− also depends on Θ:
hm =g(xm, hm−)
∂hm,k
∂θk,k′ =g′(xm,k + θk  hm−)(hm−,k′ + θk  ∂hm−
∂θk,k′ ),
where g′ is the local derivative of the nonlinear function g. The key point in this equation
is that the derivative
∂hm
∂θk,k′ depends on ∂hm−
∂θk,k′ , which will depend in turn on ∂hm−
∂θk,k′ , and
so on, until reaching the initial state h.
Each derivative
∂hm
∂θk,k′ will be reused many times: it appears in backpropagation from
the loss ℓm, but also in all subsequent losses ℓn>m.
Neural network toolkits such as
Torch (Collobert et al., ) and DyNet (Neubig et al., ) compute the necessary
Jacob Eisenstein. Draft of November , .

.. RECURRENT NEURAL NETWORK LANGUAGE MODELS
derivatives automatically, and cache them for future use. An important distinction from
the feedforward neural networks considered in chapter  is that the size of the computa-
tion graph is not ﬁxed, but varies with the length of the input. This poses difﬁculties for
toolkits that are designed around static computation graphs, such as TensorFlow (Abadi
et al., ).
Hyperparameters
The RNN language model has several hyperparameters that must be tuned to ensure good
performance. The model capacity is controlled by the size of the word and context vectors
K, which play a role that is somewhat analogous to the size of the n-gram context. For
datasets that are large with respect to the vocabulary (i.e., there is a large token-to-type
ratio), we can afford to estimate a model with a large K, which enables more subtle dis-
tinctions between words and contexts. When the dataset is relatively small, then K must
be smaller too, or else the model may “memorize” the training data, and fail to generalize.
Unfortunately, this general advice has not yet been formalized into any concrete formula
for choosing K, and trial-and-error is still necessary. Overﬁtting can also be prevented by
dropout, which involves randomly setting some elements of the computation to zero (Sri-
vastava et al., ), forcing the learner not to rely too much on any particular dimension
of the word or context vectors. The dropout rate must also be tuned on development data.
Gated recurrent neural networks
In principle, recurrent neural networks can propagate information across inﬁnitely long
sequences. But in practice, repeated applications of the nonlinear recurrence function
causes this information to be quickly attenuated. The same problem affects learning: back-
propagation can lead to vanishing gradients that decay to zero, or exploding gradients
that increase towards inﬁnity (Bengio et al., ). The exploding gradient problem can
be addressed by clipping gradients at some maximum value (Pascanu et al., ). The
other issues must be addressed by altering the model itself.
The long short-term memory (LSTM; Hochreiter and Schmidhuber, ) is a popular
variant of RNNs that is more robust to these problems. This model augments the hidden
state hm with a memory cell cm. The value of the memory cell at each time m is a gated
sum of two quantities: its previous value cm−, and an “update” ˜cm, which is computed
from the current input xm and the previous hidden state hm−. The next state hm is then
computed from the memory cell. Because the memory cell is not passed through a non-
linear squashing function during the update, it is possible for information to propagate
through the network over long distances.
See https://www.tensorflow.org/tutorials/recurrent (retrieved Feb , ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
hm
hm+
om
om+
cm
fm+
cm+
im
im+
˜cm
˜cm+
xm
xm+
Figure .: The long short-term memory (LSTM) architecture. Gates are shown in boxes
with dotted edges. In an LSTM language model, each hm would be used to predict the
next word wm+.
The gates are functions of the input and previous hidden state. They are computed
from elementwise sigmoid activations, σ(x) = (+exp(−x))−, ensuring that their values
will be in the range [, ]. They can therefore be viewed as soft, differentiable logic gates.
The LSTM architecture is shown in Figure ., and the complete update equations are:
fm+ =σ(Θ(h→f)hm + Θ(x→f)xm+ + bf)
forget gate
im+ =σ(Θ(h→i)hm + Θ(x→i)xm+ + bi)
input gate
˜cm+ = tanh(Θ(h→c)hm + Θ(w→c)xm+)
update candidate
cm+ =fm+ ⊙ cm + im+ ⊙ ˜cm+
memory cell update
om+ =σ(Θ(h→o)hm + Θ(x→o)xm+ + bo)
output gate
hm+ =om+ ⊙ tanh(cm+)
output.
The operator ⊙ is an elementwise (Hadamard) product. Each gate is controlled by a vec-
tor of weights, which parametrize the previous hidden state (e.g., Θ(h→f)) and the current
input (e.g., Θ(x→f)), plus a vector offset (e.g., bf). The overall operation can be infor-
mally summarized as (hm, cm) = LSTM(xm, (hm−, cm−)), with (hm, cm) representing
the LSTM state after reading token m.
The LSTM outperforms standard recurrent neural networks across a wide range of
problems. It was ﬁrst used for language modeling by Sundermeyer et al. (), but can
be applied more generally: the vector hm can be treated as a complete representation of
Jacob Eisenstein. Draft of November , .

.. EVALUATING LANGUAGE MODELS
the input sequence up to position m, and can be used for any labeling task on a sequence
of tokens, as we will see in the next chapter.
There are several LSTM variants, of which the Gated Recurrent Unit (Cho et al., )
is one of the more well known. Many software packages implement a variety of RNN
architectures, so choosing between them is simple from a user’s perspective. Jozefowicz
et al. () provide an empirical comparison of various modeling choices circa .
Evaluating language models
Language modeling is not usually an application in itself: language models are typically
components of larger systems, and they would ideally be evaluated extrinisically. This
means evaluating whether the language model improves performance on the application
task, such as machine translation or speech recognition. But this is often hard to do, and
depends on details of the overall system which may be irrelevant to language modeling.
In contrast, intrinsic evaluation is task-neutral. Better performance on intrinsic metrics
may be expected to improve extrinsic metrics across a variety of tasks, but there is always
the risk of over-optimizing the intrinsic metric. This section discusses some intrinsic met-
rics, but keep in mind the importance of performing extrinsic evaluations to ensure that
intrinsic performance gains carry over to real applications.
Held-out likelihood
The goal of probabilistic language models is to accurately measure the probability of se-
quences of word tokens. Therefore, an intrinsic evaluation metric is the likelihood that the
language model assigns to held-out data, which is not used during training. Speciﬁcally,
we compute,
ℓ(w) =
m=
log p(wm | wm−, . . . , w),
treating the entire held-out corpus as a single stream of tokens.
Typically, unknown words are mapped to the ⟨UNK⟩ token. This means that we have
to estimate some probability for ⟨UNK⟩ on the training data. One way to do this is to ﬁx
the vocabulary V to the V − words with the highest counts in the training data, and then
convert all other tokens to ⟨UNK⟩. Other strategies for dealing with out-of-vocabulary
terms are discussed in § ..
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
Perplexity
Held-out likelihood is usually presented as perplexity, which is a deterministic transfor-
mation of the log-likelihood into an information-theoretic quantity,
M ,
Perplex(w) = − ℓ(w)
where M is the total number of tokens in the held-out corpus.
Lower perplexities correspond to higher likelihoods, so lower scores are better on this
metric — it is better to be less perplexed. Here are some special cases:
M log  =  = .
In the limit of a perfect language model, probability  is assigned to the held-out
corpus, with Perplex(w) = −
In the opposite limit, probability zero is assigned to the held-out corpus, which cor-
responds to an inﬁnite perplexity, Perplex(w) = −
M log  = ∞ = ∞.
Assume a uniform, unigram model in which p(wi) =
V for all words in the vocab-
ulary. Then,
log(w) =
m=
log V = −M log V
m=
log
V = −
Perplex(w) =
M M log V
=log V
=V.
This is the “worst reasonable case” scenario, since you could build such a language
model without even looking at the data.
In practice, language models tend to give perplexities in the range between  and V .
A small benchmark dataset is the Penn Treebank, which contains roughly a million to-
kens; its vocabulary is limited to , words, with all other tokens mapped a special
⟨UNK⟩ symbol. On this dataset, a well-smoothed -gram model achieves a perplexity of
(Mikolov and Zweig, Mikolov and Zweig), and an LSTM language model achieves
perplexity of roughly  (Zaremba, Sutskever, and Vinyals, Zaremba et al.). Various en-
hancements to the LSTM architecture can bring the perplexity below  (Merity et al.,
). A larger-scale language modeling dataset is the B Word Benchmark (Chelba et al.,
), which contains text from Wikipedia. On this dataset, perplexities of around  can
be obtained by averaging together multiple LSTM language models (Jozefowicz et al.,
Jacob Eisenstein. Draft of November , .

.. OUT-OF-VOCABULARY WORDS
Out-of-vocabulary words
So far, we have assumed a closed-vocabulary setting — the vocabulary V is assumed to be
a ﬁnite set. In realistic application scenarios, this assumption may not hold. Consider, for
example, the problem of translating newspaper articles. The following sentence appeared
in a Reuters article on January , :
The report said U.S. intelligence agencies believe Russian military intelligence,
the GRU, used intermediaries such as WikiLeaks, DCLeaks.com and the Guc-
cifer . ”persona” to release emails...
Suppose that you trained a language model on the Gigaword corpus, which was released
in . The bolded terms either did not exist at this date, or were not widely known; they
are unlikely to be in the vocabulary. The same problem can occur for a variety of other
terms: new technologies, previously unknown individuals, new words (e.g., hashtag), and
numbers.
One solution is to simply mark all such terms with a special token, ⟨UNK⟩. While
training the language model, we decide in advance on the vocabulary (often the K most
common terms), and mark all other terms in the training data as ⟨UNK⟩. If we do not want
to determine the vocabulary size in advance, an alternative approach is to simply mark
the ﬁrst occurrence of each word type as ⟨UNK⟩.
But is often better to make distinctions about the likelihood of various unknown words.
This is particularly important in languages that have rich morphological systems, with
many inﬂections for each word. For example, Portuguese is only moderately complex
from a morphological perspective, yet each verb has dozens of inﬂected forms (see Fig-
ure .b). In such languages, there will be many word types that we do not encounter in a
corpus, which are nonetheless predictable from the morphological rules of the language.
To use a somewhat contrived English example, if transfenestrate is in the vocabulary, our
language model should assign a non-zero probability to the past tense transfenestrated,
even if it does not appear in the training data.
One way to accomplish this is to supplement word-level language models with character-
level language models. Such models can use n-grams or RNNs, but with a ﬁxed vocab-
ulary equal to the set of ASCII or Unicode characters. For example, Ling et al. ()
propose an LSTM model over characters, and Kim () employ a convolutional neural
network. A more linguistically motivated approach is to segment words into meaningful
subword units, known as morphemes (see chapter ). For example, Botha and Blunsom
Bayoumy,
Y.
and
Strobel,
W.
January
U.S.
intel
report:
Putin
directed
cy-
ber campaign to help Trump.
Reuters.
Retrieved from http://www.reuters.com/article/
us-usa-russia-cyber-idUSKBNQT on January , .
https://catalog.ldc.upenn.edu/LDCT
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LANGUAGE MODELS
() induce vector representations for morphemes, which they build into a log-bilinear
language model; Bhatia et al. () incorporate morpheme vectors into an LSTM.
Additional resources
A variety of neural network architectures have been applied to language modeling. No-
table earlier non-recurrent architectures include the neural probabilistic language model (Ben-
gio et al., ) and the log-bilinear language model (Mnih and Hinton, ). Much more
detail on these models can be found in the text by Goodfellow et al. ().
Exercises
. Prove that n-gram language models give valid probabilities if the n-gram probabil-
ities are valid. Speciﬁcally, assume that,
wm
p(wm | wm−, wm−, . . . , wm−n+) =
but you need not handle the end-of-string token.
for all contexts (wm−, wm−, . . . , wm−n+). Prove that P
w pn(w) =  for all w ∈ V∗,
where pn is the probability under an n-gram language model. Your proof should
proceed by induction. You should handle the start-of-string case p(w | □, . . . , □
{z
n−
. First, show that RNN language models are valid using a similar proof technique to
the one in the previous problem.
Next, let pr(w) indicate the probability of w under RNN r. An ensemble of RNN
language models computes the probability,
p(w) =
r=
pr(w).
Does an ensemble of RNN language models compute a valid probability?
. Consider a unigram language model over a vocabulary of size V . Suppose that a
word appears m times in a corpus with M tokens in total. With Lidstone smoothing
of α, for what values of m is the smoothed probability greater than the unsmoothed
probability?
. Consider a simple language in which each token is drawn from the vocabulary V
with probability
V , independent of all other tokens.
Jacob Eisenstein. Draft of November , .

.. OUT-OF-VOCABULARY WORDS
Given a corpus of size M, what is the expectation of the fraction of all possible
bigrams that have zero count? You may assume V is large enough that
V −.
V ≈
. Continuing the previous problem, determine the value of M such that the fraction
of bigrams with zero count is at most ϵ ∈ (, ). As a hint, you may use the approxi-
mation ln( + α) ≈ α for α ≈ .
. In real languages, words probabilities are neither uniform nor independent. Assume
that word probabilities are independent but not uniform, so that in general p(w) ̸=
V . Prove that the expected fraction of unseen bigrams will be higher than in the IID
case.
. Consider a recurrent neural network with a single hidden unit and a sigmoid acti-
vation, hm = σ(θhm− + xm). Prove that if |θ| < , then the gradient
∂hm
∂hm−k goes to
zero as k → ∞.
. Zipf’s law states that if the word types in a corpus are sorted by frequency, then the
frequency of the word at rank r is proportional to r−s, where s is a free parameter,
usually around . (Another way to view Zipf’s law is that a plot of log frequency
against log rank will be linear.) Solve for s using the counts of the ﬁrst and second
most frequent words, c and c.
. Download the wikitext- dataset. Read in the training data and compute word
counts. Estimate the Zipf’s law coefﬁcient by,

ˆs = exp
(log r)  (log c)
|| log r||
where r = [, , , . . .] is the vector of ranks of all words in the corpus, and c =
[c, c, c, . . .] is the vector of counts of all words in the corpus, sorted in descending
order.
Make a log-log plot of the observed counts, and the expected counts according to
Zipf’s law. The sum P∞
r= rs = ζ(s) is the Riemann zeta function, available in
python’s scipy library as scipy.special.zeta.
. Using the Pytorch library, train an LSTM language model from the Wikitext train-
ing corpus. After each epoch of training, compute its perplexity on the Wikitext
validation corpus. Stop training when the perplexity stops improving.
This proof generalizes to vector hidden units by considering the largest eigenvector of the matrix Θ (Pas-
canu et al., ).
Available
at
https://github.com/pytorch/examples/tree/master/word_language_
model/data/wikitext- in September . The dataset is already tokenized, and already replaces rare
words with ⟨UNK⟩, so no preprocessing is necessary.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Chapter
Sequence labeling
The goal of sequence labeling is to assign tags to words, or more generally, to assign
discrete labels to discrete elements in a sequence. There are many applications of se-
quence labeling in natural language processing, and chapter  presents an overview. For
now, we’ll focus on the classic problem of part-of-speech tagging, which requires tagging
each word by its grammatical category. Coarse-grained grammatical categories include
NOUNs, which describe things, properties, or ideas, and VERBs, which describe actions
and events. Consider a simple input:
They can ﬁsh.
A dictionary of coarse-grained part-of-speech tags might include NOUN as the only valid
tag for they, but both NOUN and VERB as potential tags for can and ﬁsh. A accurate se-
quence labeling algorithm should select the verb tag for both can and ﬁsh in (.), but it
should select noun for the same two words in the phrase can of ﬁsh.
Sequence labeling as classiﬁcation
One way to solve a tagging problem is to turn it into a classiﬁcation problem. Let f((w, m), y)
indicate the feature function for tag y at position m in the sequence w = (w, w, . . . , wM).
A simple tagging model would have a single base feature, the word itself:
f((w = they can ﬁsh, m = ), N) =(they, N)
f((w = they can ﬁsh, m = ), V) =(can, V)
f((w = they can ﬁsh, m = ), V) =(ﬁsh, V).
Here the feature function takes three arguments as input: the sentence to be tagged (e.g.,
they can ﬁsh), the proposed tag (e.g., N or V), and the index of the token to which this tag
CHAPTER . SEQUENCE LABELING
is applied. This simple feature function then returns a single feature: a tuple including
the word to be tagged and the tag that has been proposed. If the vocabulary size is V
and the number of tags is K, then there are V × K features. Each of these features must
be assigned a weight. These weights can be learned from a labeled dataset using a clas-
siﬁcation algorithm such as perceptron, but this isn’t necessary in this case: it would be
equivalent to deﬁne the classiﬁcation weights directly, with θw,y =  for the tag y most
frequently associated with word w, and θw,y =  for all other tags.
However, it is easy to see that this simple classiﬁcation approach cannot correctly tag
both they can ﬁsh and can of ﬁsh, because can and ﬁsh are grammatically ambiguous. To han-
dle both of these cases, the tagger must rely on context, such as the surrounding words.
We can build context into the feature set by incorporating the surrounding words as ad-
ditional features:
f((w = they can ﬁsh, ), N) = {(wm = they, ym = N),
(wm− = □, ym = N),
(wm+ = can, ym = N)}
f((w = they can ﬁsh, ), V) = {(wm = can, ym = V),
(wm− = they, ym = V),
(wm+ = ﬁsh, ym = V)}
f((w = they can ﬁsh, ), V) = {(wm = ﬁsh, ym = V),
(wm− = can, ym = V),
(wm+ = ■, ym = V)}.
These features contain enough information that a tagger should be able to choose the
right tag for the word ﬁsh: words that come after can are likely to be verbs, so the feature
(wm− = can, ym = V) should have a large positive weight.
However, even with this enhanced feature set, it may be difﬁcult to tag some se-
quences correctly. One reason is that there are often relationships between the tags them-
selves. For example, in English it is relatively rare for a verb to follow another verb —
particularly if we differentiate MODAL verbs like can and should from more typical verbs,
like give, transcend, and befuddle. We would like to incorporate preferences against tag se-
quences like VERB-VERB, and in favor of tag sequences like NOUN-VERB. The need for
such preferences is best illustrated by a garden path sentence:
The old man the boat.
Grammatically, the word the is a DETERMINER. When you read the sentence, what
part of speech did you ﬁrst assign to old? Typically, this word is an ADJECTIVE — abbrevi-
ated as J — which is a class of words that modify nouns. Similarly, man is usually a noun.
The resulting sequence of tags is D J N D N. But this is a mistaken “garden path” inter-
pretation, which ends up leading nowhere. It is unlikely that a determiner would directly
Jacob Eisenstein. Draft of November , .

.. SEQUENCE LABELING AS STRUCTURE PREDICTION
follow a noun, and it is particularly unlikely that the entire sentence would lack a verb.
The only possible verb in (.) is the word man, which can refer to the act of maintaining
and piloting something — often boats. But if man is tagged as a verb, then old is seated
between a determiner and a verb, and must be a noun. And indeed, adjectives often have
a second interpretation as nouns when used in this way (e.g., the young, the restless). This
reasoning, in which the labeling decisions are intertwined, cannot be applied in a setting
where each tag is produced by an independent classiﬁcation decision.
Sequence labeling as structure prediction
As an alternative, think of the entire sequence of tags as a label itself. For a given sequence
of words w = (w, w, . . . , wM), there is a set of possible taggings Y(w) = YM, where
Y = {N, V, D, . . .} refers to the set of individual tags, and YM refers to the set of tag
sequences of length M. We can then treat the sequence labeling problem as a classiﬁcation
problem in the label space Y(w),
ˆy = argmax
y∈Y(w)
Ψ(w, y),
where y = (y, y, . . . , yM) is a sequence of M tags, and Ψ is a scoring function on pairs
of sequences, V M × YM → R. Such a function can include features that capture the rela-
tionships between tagging decisions, such as the preference that determiners not follow
nouns, or that all sentences have verbs.
Given that the label space is exponentially large in the length of the sequence M, can
it ever be practical to perform tagging in this way? The problem of making a series of in-
terconnected labeling decisions is known as inference. Because natural language is full of
interrelated grammatical structures, inference is a crucial aspect of natural language pro-
cessing. In English, it is not unusual to have sentences of length M = ; part-of-speech
tag sets vary in size from  to several hundred. Taking the low end of this range, we have
|Y(w:M)| ≈ , one hundred billion billion possible tag sequences. Enumerating and
scoring each of these sequences would require an amount of work that is exponential in
the sequence length, so inference is intractable.
However, the situation changes when we restrict the scoring function. Suppose we
choose a function that decomposes into a sum of local parts,
Ψ(w, y) =
m=
ψ(w, ym, ym−, m),
M+
where each ψ() scores a local part of the tag sequence. Note that the sum goes up to M +,
so that we can include a score for a special end-of-sequence tag, ψ(w:M, ♦, yM, M + ).
We also deﬁne a special tag to begin the sequence, y ≜ ♦.
The main exception occurs with ditransitive verbs, such as They gave the winner a trophy.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
In a linear model, local scoring function can be deﬁned as a dot product of weights
and features,
ψ(w:M, ym, ym−, m) = θ  f(w, ym, ym−, m).
The feature vector f can consider the entire input w, and can look at pairs of adjacent
tags. This is a step up from per-token classiﬁcation: the weights can assign low scores
to infelicitous tag pairs, such as noun-determiner, and high scores for frequent tag pairs,
such as determiner-noun and noun-verb.
In the example they can ﬁsh, a minimal feature function would include features for
word-tag pairs (sometimes called emission features) and tag-tag pairs (sometimes called
transition features):
f(w = they can ﬁsh, y = N V V ) =
m=
f(w, ym, ym−, m)
M+
=f(w, N, ♦, )
+ f(w, V, N, )
+ f(w, V, V, )
+ f(w, ♦, V, )
=(wm = they, ym = N) + (ym = N, ym− = ♦)
+ (wm = can, ym = V) + (ym = V, ym− = N)
+ (wm = ﬁsh, ym = V) + (ym = V, ym− = V)
+ (ym = ♦, ym− = V).
There are seven active features for this example: one for each word-tag pair, and one
for each tag-tag pair, including a ﬁnal tag yM+ = ♦. These features capture the two main
sources of information for part-of-speech tagging in English: which tags are appropriate
for each word, and which tags tend to follow each other in sequence. Given appropriate
weights for these features, taggers can achieve high accuracy, even for difﬁcult cases like
the old man the boat. We will now discuss how this restricted scoring function enables
efﬁcient inference, through the Viterbi algorithm (Viterbi, ).
Jacob Eisenstein. Draft of November , .

.. THE VITERBI ALGORITHM
The Viterbi algorithm
By decomposing the scoring function into a sum of local parts, it is possible to rewrite the
tagging problem as follows:
ˆy = argmax
y∈Y(w)
Ψ(w, y)
= argmax
y:M
m=
ψ(w, ym, ym−, m)
M+
= argmax
y:M
m=
sm(ym, ym−),
M+
where the ﬁnal line simpliﬁes the notation with the shorthand,
sm(ym, ym−) ≜ ψ(w:M, ym, ym−, m).
This inference problem can be solved efﬁciently using dynamic programming, an al-
gorithmic technique for reusing work in recurrent computations. We begin by solving an
auxiliary problem: rather than ﬁnding the best tag sequence, we compute the score of the
best tag sequence,
max
y:M Ψ(w, y:M) = max
y:M
m=
sm(ym, ym−).
M+
This score involves a maximization over all tag sequences of length M, written maxy:M .
This maximization can be broken into two pieces,
max
y:M Ψ(w, y:M) = max
yM
max
y:M−
m=
sm(ym, ym−).
M+
Within the sum, only the ﬁnal term sM+(♦, yM) depends on yM, so we can pull this term
out of the second maximization,
max
y:M−
m=
sm(ym, ym−)
max
y:M Ψ(w, y:M) =

max
yM sM+(♦, yM)

The second term in Equation . has the same form as our original problem, with M
replaced by M−. This indicates that the problem can be reformulated as a recurrence. We
do this by deﬁning an auxiliary variable called the Viterbi variable vm(k), representing
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
Algorithm  The Viterbi algorithm. Each sm(k, k′) is a local score for tag ym = k and
ym− = k′.
for k ∈ {, . . . K} do
v(k) = s(k, ♦)
for m ∈ {, . . . , M} do
for k ∈ {, . . . , K} do
vm(k) = maxk′ sm(k, k′) + vm−(k′)
bm(k) = argmaxk′ sm(k, k′) + vm−(k′)
yM = argmaxk sM+(♦, k) + vM(k)
for m ∈ {M − , . . . } do
ym = bm(ym+)
return y:M
the score of the best sequence terminating in the tag k:
vm(ym) ≜ max
y:m−
n=
sn(yn, yn−)
= max
ym− sm(ym, ym−) + max
y:m−
n=
sn(yn, yn−)
m−
= max
ym− sm(ym, ym−) + vm−(ym−).
Each set of Viterbi variables is computed from the local score sm(ym, ym−), and from the
previous set of Viterbi variables. The initial condition of the recurrence is simply the score
for the ﬁrst tag,
v(y) ≜s(y, ♦).
The maximum overall score for the sequence is then the ﬁnal Viterbi variable,
max
y:M Ψ(w:M, y:M) =vM+(♦).
Thus, the score of the best labeling for the sequence can be computed in a single forward
sweep: ﬁrst compute all variables v() from Equation ., and then compute all variables
v() from the recurrence in Equation ., continuing until the ﬁnal variable vM+(♦).
The Viterbi variables can be arranged in a structure known as a trellis, shown in Fig-
ure .. Each column indexes a token m in the sequence, and each row indexes a tag in
Y; every vm−(k) is connected to every vm(k′), indicating that vm(k′) is computed from
vm−(k). Special nodes are set aside for the start and end states.
Jacob Eisenstein. Draft of November , .

.. THE VITERBI ALGORITHM
they
can
ﬁsh
Figure .: The trellis representation of the Viterbi variables, for the example they can ﬁsh,
using the weights shown in Table ..
The original goal was to ﬁnd the best scoring sequence, not simply to compute its
score. But by solving the auxiliary problem, we are almost there. Recall that each vm(k)
represents the score of the best tag sequence ending in that tag k in position m. To compute
this, we maximize over possible values of ym−. By keeping track of the “argmax” tag that
maximizes this choice at each step, we can walk backwards from the ﬁnal tag, and recover
the optimal tag sequence. This is indicated in Figure . by the thick lines, which we trace
back from the ﬁnal position. These backward pointers are written bm(k), indicating the
optimal tag ym− on the path to Ym = k.
The complete Viterbi algorithm is shown in Algorithm . When computing the initial
Viterbi variables v(), the special tag ♦ indicates the start of the sequence. When comput-
ing the ﬁnal tag YM, another special tag,♦ indicates the end of the sequence. These special
tags enable the use of transition features for the tags that begin and end the sequence: for
example, conjunctions are unlikely to end sentences in English, so we would like a low
score for sM+(♦, CC); nouns are relatively likely to appear at the beginning of sentences,
so we would like a high score for s(N, ♦), assuming the noun tag is compatible with the
ﬁrst word token w.
Complexity
If there are K tags and M positions in the sequence, then there are M × K
Viterbi variables to compute. Computing each variable requires ﬁnding a maximum over
K possible predecessor tags. The total time complexity of populating the trellis is there-
fore O(MK), with an additional factor for the number of active features at each position.
After completing the trellis, we simply trace the backwards pointers to the beginning of
the sequence, which takes O(M) operations.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
they
can
ﬁsh
(a) Weights for emission features.
(b) Weights for transition features.
The
“from” tags are on the columns, and the “to”
tags are on the rows.
Table .: Feature weights for the example trellis shown in Figure .. Emission weights
from ♦ and ♦ are implicitly set to −∞.
Example
Consider the minimal tagset {N, V}, corresponding to nouns and verbs. Even in this
tagset, there is considerable ambiguity: for example, the words can and ﬁsh can each take
both tags. Of the  ×  ×  =  possible taggings for the sentence they can ﬁsh, four are
possible given these possible tags, and two are grammatical.
The values in the trellis in Figure . are computed from the feature weights deﬁned in
Table .. We begin with v(N), which has only one possible predecessor, the start tag ♦.
This score is therefore equal to s(N, ♦) = − −  = −, which is the sum of the scores for
the emission and transition features respectively; the backpointer is b(N) = ♦. The score
for v(V) is computed in the same way: s(V, ♦) = − −  = −, and again b(V) = ♦.
The backpointers are represented in the ﬁgure by thick lines.
Things get more interesting at m = . The score v(N) is computed by maximizing
over the two possible predecessors,
v(N) = max(v(N) + s(N, N), v(V) + s(N, V))
= max(− −  − ,
− −  − ) = −
b(N) =N.
This continues until reaching v(♦), which is computed as,
v(♦) = max(v(N) + s(♦, N), v(V) + s(♦, V))
= max(− +  − ,
− +  − )
= − ,
so b(♦) = N. As there is no emission w, the emission features have scores of zero.
The tagging they/N can/V ﬁsh/N corresponds to the scenario of putting ﬁsh into cans, or perhaps of
ﬁring them.
Jacob Eisenstein. Draft of November , .

.. HIDDEN MARKOV MODELS
To compute the optimal tag sequence, we walk backwards from here, next checking
b(N) = V, and then b(V) = N, and ﬁnally b(N) = ♦. This yields y = (N, V, N), which
corresponds to the linguistic interpretation of the ﬁshes being put into cans.
Higher-order features
The Viterbi algorithm was made possible by a restriction of the scoring function to local
parts that consider only pairs of adjacent tags. We can think of this as a bigram language
model over tags. A natural question is how to generalize Viterbi to tag trigrams, which
would involve the following decomposition:
Ψ(w, y) =
m=
f(w, ym, ym−, ym−, m),
M+
where y− = ♦ and yM+ = ♦.
One solution is to create a new tagset Y() from the Cartesian product of the original
tagset with itself, Y() = Y × Y. The tags in this product space are ordered pairs, rep-
resenting adjacent tags at the token level: for example, the tag (N, V) would represent a
noun followed by a verb. Transitions between such tags must be consistent: we can have a
transition from (N, V) to (V, N) (corresponding to the tag sequence N V N), but not from
(N, V) to (N, N), which would not correspond to any coherent tag sequence. This con-
straint can be enforced in feature weights, with θ((a,b),(c,d)) = −∞ if b ̸= c. The remaining
feature weights can encode preferences for and against various tag trigrams.
In the Cartesian product tag space, there are K tags, suggesting that the time com-
plexity will increase to O(MK). However, it is unnecessary to max over predecessor tag
bigrams that are incompatible with the current tag bigram. By exploiting this constraint,
it is possible to limit the time complexity to O(MK). The space complexity grows to
O(MK), since the trellis must store all possible predecessors of each tag. In general, the
time and space complexity of higher-order Viterbi grows exponentially with the order of
the tag n-grams that are considered in the feature decomposition.
Hidden Markov Models
The Viterbi sequence labeling algorithm is built on the scores sm(y, y′). We will now
discuss how these scores can be estimated probabilistically. Recall from § . that the
probabilistic Na¨ıve Bayes classiﬁer selects the label y to maximize p(y | x) ∝ p(y, x). In
probabilistic sequence labeling, our goal is similar: select the tag sequence that maximizes
p(y | w) ∝ p(y, w). The locality restriction in Equation . can be viewed as a conditional
independence assumption on the random variables y.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
Algorithm  Generative process for the hidden Markov model
y ← ♦,
m ←
repeat
ym ∼ Categorical(λym−)
▷ sample the current tag
wm ∼ Categorical(φym)
▷ sample the current word
until ym = ♦
▷ terminate when the stop symbol is generated
Na¨ıve Bayes was introduced as a generative model — a probabilistic story that ex-
plains the observed data as well as the hidden label. A similar story can be constructed
for probabilistic sequence labeling: ﬁrst, the tags are drawn from a prior distribution; next,
the tokens are drawn from a conditional likelihood. However, for inference to be tractable,
additional independence assumptions are required. First, the probability of each token
depends only on its tag, and not on any other element in the sequence:
p(w | y) =
m=
p(wm | ym).
Second, each tag ym depends only on its predecessor,
p(y) =
m=
p(ym | ym−),
where y = ♦ in all cases. Due to this Markov assumption, probabilistic sequence labeling
models are known as hidden Markov models (HMMs).
The generative process for the hidden Markov model is shown in Algorithm . Given
the parameters λ and φ, we can compute p(w, y) for any token sequence w and tag se-
quence y. The HMM is often represented as a graphical model (Wainwright and Jordan,
), as shown in Figure .. This representation makes the independence assumptions
explicit: if a variable v is probabilistically conditioned on another variable v, then there
is an arrow v → v in the diagram. If there are no arrows between v and v, they
are conditionally independent, given each variable’s Markov blanket. In the hidden
Markov model, the Markov blanket for each tag ym includes the “parent” ym−, and the
“children” ym+ and wm.
It is important to reﬂect on the implications of the HMM independence assumptions.
A non-adjacent pair of tags ym and yn are conditionally independent; if m < n and we
are given yn−, then ym offers no additional information about yn. However, if we are
not given any information about the tags in a sequence, then all tags are probabilistically
coupled.
In general graphical models, a variable’s Markov blanket includes its parents, children, and its children’s
other parents (Murphy, ).
Jacob Eisenstein. Draft of November , .

.. HIDDEN MARKOV MODELS
yM
wM
Figure .: Graphical representation of the hidden Markov model. Arrows indicate prob-
abilistic dependencies.
Estimation
The hidden Markov model has two groups of parameters:
Emission probabilities. The probability pe(wm | ym; φ) is the emission probability, since
the words are treated as probabilistically “emitted”, conditioned on the tags.
Transition probabilities. The probability pt(ym | ym−; λ) is the transition probability,
since it assigns probability to each possible tag-to-tag transition.
Both of these groups of parameters are typically computed from smoothed relative
frequency estimation on a labeled corpus (see § . for a review of smoothing). The un-
smoothed probabilities are,
φk,i ≜ Pr(Wm = i | Ym = k) = count(Wm = i, Ym = k)
count(Ym = k)
λk,k′ ≜ Pr(Ym = k′ | Ym− = k) = count(Ym = k′, Ym− = k)
count(Ym− = k)
Smoothing is more important for the emission probability than the transition probability,
because the vocabulary is much larger than the number of tags.
Inference
The goal of inference in the hidden Markov model is to ﬁnd the highest probability tag
sequence,
ˆy = argmax
p(y | w).
As in Na¨ıve Bayes, it is equivalent to ﬁnd the tag sequence with the highest log-probability,
since the logarithm is a monotonically increasing function. It is furthermore equivalent
to maximize the joint probability p(y, w) = p(y | w) × p(w) ∝ p(y | w), which is pro-
portional to the conditional probability. Putting these observations together, the inference
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
problem can be reformulated as,
ˆy = argmax
log p(y, w).
We can now apply the HMM independence assumptions:
log p(y, w) = log p(y) + log p(w | y)
m=
log pY (ym | ym−) + log pW|Y (wm | ym)
M+
m=
log λym,ym− + log φym,wm
M+
m=
sm(ym, ym−),
M+
where,
sm(ym, ym−) ≜ log λym,ym− + log φym,wm,
and,
φ♦,w =
w = ■
otherwise,
which ensures that the stop tag ♦ can only be applied to the ﬁnal token ■.
This derivation shows that HMM inference can be viewed as an application of the
Viterbi decoding algorithm, given an appropriately deﬁned scoring function. The local
score sm(ym, ym−) can be interpreted probabilistically,
sm(ym, ym−) = log py(ym | ym−) + log pw|y(wm | ym)
= log p(ym, wm | ym−).
Now recall the deﬁnition of the Viterbi variables,
vm(ym) = max
ym− sm(ym, ym−) + vm−(ym−)
= max
ym− log p(ym, wm | ym−) + vm−(ym−).
By setting vm−(ym−) = maxy:m− log p(y:m−, w:m−), we obtain the recurrence,
vm(ym) = max
ym− log p(ym, wm | ym−) + max
y:m− log p(y:m−, w:m−)
= max
y:m− log p(ym, wm | ym−) + log p(y:m−, w:m−)
= max
y:m− log p(y:m, w:m).
Jacob Eisenstein. Draft of November , .

.. DISCRIMINATIVE SEQUENCE LABELING WITH FEATURES
In words, the Viterbi variable vm(ym) is the log probability of the best tag sequence ending
in ym, joint with the word sequence w:m. The log probability of the best complete tag
sequence is therefore,
max
y:M log p(y:M+, w:M+) = vM+(♦)
*Viterbi as an example of the max-product algorithm
The Viterbi algorithm can also be
implemented using probabilities, rather than log-probabilities. In this case, each vm(ym)
is equal to,
vm(ym) = max
y:m− p(y:m−, ym, w:m)
= max
ym− p(ym, wm | ym−) × max
y:m− p(y:m−, ym−, w:m−)
= max
ym− p(ym, wm | ym−) × vm−(ym−)
=pw|y(wm | ym) × max
ym− py(ym | ym−) × vm−(ym−).
Each Viterbi variable is computed by maximizing over a set of products. Thus, the Viterbi
algorithm is a special case of the max-product algorithm for inference in graphical mod-
els (Wainwright and Jordan, ). However, the product of probabilities tends towards
zero over long sequences, so the log-probability version of Viterbi is recommended in
practical implementations.
Discriminative sequence labeling with features
Today, hidden Markov models are rarely used for supervised sequence labeling. This is
because HMMs are limited to only two phenomena:
word-tag compatibility, via the emission probability pW|Y (wm | ym);
local context, via the transition probability pY (ym | ym−).
The Viterbi algorithm permits the inclusion of richer information in the local scoring func-
tion ψ(w:M, ym, ym−, m), which can be deﬁned as a weighted sum of arbitrary local fea-
tures,
ψ(w, ym, ym−, m) = θ  f(w, ym, ym−, m),
where f is a locally-deﬁned feature function, and θ is a vector of weights.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
The local decomposition of the scoring function Ψ is reﬂected in a corresponding de-
composition of the feature function:
Ψ(w, y) =
m=
ψ(w, ym, ym−, m)
M+
m=
θ  f(w, ym, ym−, m)
M+
=θ
m=
f(w, ym, ym−, m)
M+
=θ  f (global)(w, y:M),
where f (global)(w, y) is a global feature vector, which is a sum of local feature vectors,
f (global)(w, y) =
m=
f(w:M, ym, ym−, m),
M+
with yM+ = ♦ and y = ♦ by construction.
Let’s now consider what additional information these features might encode.
Word afﬁx features.
Consider the problem of part-of-speech tagging on the ﬁrst four
lines of the poem Jabberwocky (Carroll, ):
’Twas brillig, and the slithy toves
Did gyre and gimble in the wabe:
All mimsy were the borogoves,
And the mome raths outgrabe.
Many of these words were made up by the author of the poem, so a corpus would offer
no information about their probabilities of being associated with any particular part of
speech. Yet it is not so hard to see what their grammatical roles might be in this passage.
Context helps: for example, the word slithy follows the determiner the, so it is probably a
noun or adjective. Which do you think is more likely? The sufﬁx -thy is found in a number
of adjectives, like frothy, healthy, pithy, worthy. It is also found in a handful of nouns — e.g.,
apathy, sympathy — but nearly all of these have the longer coda -pathy, unlike slithy. So the
sufﬁx gives some evidence that slithy is an adjective, and indeed it is: later in the text we
ﬁnd that it is a combination of the adjectives lithe and slimy.
Morphology is the study of how words are formed from smaller linguistic units. chapter  touches on
computational approaches to morphological analysis. See Bender () for an overview of the underlying
linguistic principles, and Haspelmath and Sims () or Lieber () for a full treatment.
Jacob Eisenstein. Draft of November , .

.. DISCRIMINATIVE SEQUENCE LABELING WITH FEATURES
Fine-grained context.
The hidden Markov model captures contextual information in the
form of part-of-speech tag bigrams. But sometimes, the necessary contextual information
is more speciﬁc. Consider the noun phrases this ﬁsh and these ﬁsh. Many part-of-speech
tagsets distinguish between singular and plural nouns, but do not distinguish between
singular and plural determiners; for example, the well known Penn Treebank tagset fol-
lows these conventions. A hidden Markov model would be unable to correctly label ﬁsh as
singular or plural in both of these cases, because it only has access to two features: the pre-
ceding tag (determiner in both cases) and the word (ﬁsh in both cases). The classiﬁcation-
based tagger discussed in § . had the ability to use preceding and succeeding words as
features, and it can also be incorporated into a Viterbi-based sequence labeler as a local
feature.
Example.
Consider the tagging D J N (determiner, adjective, noun) for the sequence the
slithy toves, so that
w =the slithy toves
y =D J N.
Let’s create the feature vector for this example, assuming that we have word-tag features
(indicated by W), tag-tag features (indicated by T), and sufﬁx features (indicated by M).
You can assume that you have access to a method for extracting the sufﬁx -thy from slithy,
-es from toves, and ∅ from the, indicating that this word has no sufﬁx. The resulting
feature vector is,
f(the slithy toves, D J N) =f(the slithy toves, D, ♦, )
+ f(the slithy toves, J, D, )
+ f(the slithy toves, N, J, )
+ f(the slithy toves, ♦, N, )
={(T : ♦, D), (W : the, D), (M : ∅, D),
(T : D, J), (W : slithy, J), (M : -thy, J),
(T : J, N), (W : toves, N), (M : -es, N)
(T : N, ♦)}.
These examples show that local features can incorporate information that lies beyond
the scope of a hidden Markov model. Because the features are local, it is possible to apply
the Viterbi algorithm to identify the optimal sequence of tags. The remaining question
Such a system is called a morphological segmenter. The task of morphological segmentation is brieﬂy
described in § ..; a well known segmenter is MORFESSOR (Creutz and Lagus, ). In real applications, a
typical approach is to include features for all orthographic sufﬁxes up to some maximum number of charac-
ters: for slithy, we would have sufﬁx features for -y, -hy, and -thy.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
is how to estimate the weights on these features. § . presented three main types of
discriminative classiﬁers: perceptron, support vector machine, and logistic regression.
Each of these classiﬁers has a structured equivalent, enabling it to be trained from labeled
sequences rather than individual tokens.
Structured perceptron
The perceptron classiﬁer is trained by increasing the weights for features that are asso-
ciated with the correct label, and decreasing the weights for features that are associated
with incorrectly predicted labels:
ˆy = argmax
y∈Y
θ  f(x, y)
θ(t+) ← θ(t) + f(x, y) − f(x, ˆy).
We can apply exactly the same update in the case of structure prediction,
ˆy = argmax
y∈Y(w)
θ  f(w, y)
θ(t+) ← θ(t) + f(w, y) − f(w, ˆy).
This learning algorithm is called structured perceptron, because it learns to predict the
structured output y. The only difference is that instead of computing ˆy by enumerating
the entire set Y, the Viterbi algorithm is used to efﬁciently search the set of possible tag-
gings, YM. Structured perceptron can be applied to other structured outputs as long as
efﬁcient inference is possible. As in perceptron classiﬁcation, weight averaging is crucial
to get good performance (see § ..).
Example
For the example they can ﬁsh, suppose that the reference tag sequence is y(i) =
N V V, but the tagger incorrectly returns the tag sequence ˆy = N V N. Assuming a model
with features for emissions (wm, ym) and transitions (ym−, ym), the corresponding struc-
tured perceptron update is:
θ(ﬁsh,V) ← θ(ﬁsh,V) + ,
θ(ﬁsh,N) ← θ(ﬁsh,N) −
θ(V,V) ← θ(V,V) + ,
θ(V,N) ← θ(V,N) −
θ(V,♦) ← θ(V,♦) + ,
θ(N,♦) ← θ(N,♦) − .
Structured support vector machines
Large-margin classiﬁers such as the support vector machine improve on the perceptron by
pushing the classiﬁcation boundary away from the training instances. The same idea can
Jacob Eisenstein. Draft of November , .

.. DISCRIMINATIVE SEQUENCE LABELING WITH FEATURES
be applied to sequence labeling. A support vector machine in which the output is a struc-
tured object, such as a sequence, is called a structured support vector machine (Tsochan-
taridis et al., ).
In classiﬁcation, we formalized the large-margin constraint as,
∀y ̸= y(i), θ  f(x, y(i)) − θ  f(x, y) ≥ ,
requiring a margin of at least  between the scores for all labels y that are not equal to the
correct label y(i). The weights θ are then learned by constrained optimization (see § ..).
This idea can be applied to sequence labeling by formulating an equivalent set of con-
straints for all possible labelings Y(w) for an input w. However, there are two problems.
First, in sequence labeling, some predictions are more wrong than others: we may miss
only one tag out of ﬁfty, or we may get all ﬁfty wrong. We would like our learning algo-
rithm to be sensitive to this difference. Second, the number of constraints is equal to the
number of possible labelings, which is exponentially large in the length of the sequence.
The ﬁrst problem can be addressed by adjusting the constraint to require larger mar-
gins for more serious errors. Let c(y(i), ˆy) ≥  represent the cost of predicting label ˆy when
the true label is y(i). We can then generalize the margin constraint,
∀y, θ  f(w(i), y(i)) − θ  f(w(i), y) ≥ c(y(i), y).
This cost-augmented margin constraint specializes to the constraint in Equation . if we
choose the delta function c(y(i), y) = δ (() y(i) ̸= y). A more expressive cost function is
the Hamming cost,
c(y(i), y) =
m=
δ(y(i)
m ̸= ym),
which computes the number of errors in y. By incorporating the cost function as the
margin constraint, we require that the true labeling be seperated from the alternatives by
a margin that is proportional to the number of incorrect tags in each alternative labeling.
The second problem is that the number of constraints is exponential in the length
of the sequence. This can be addressed by focusing on the prediction ˆy that maximally
violates the margin constraint. This prediction can be identiﬁed by solving the following
cost-augmented decoding problem:
ˆy = argmax
y̸=y(i) θ  f(w(i), y) − θ  f(w(i), y(i)) + c(y(i), y)
= argmax
y̸=y(i) θ  f(w(i), y) + c(y(i), y),
This model is also known as a max-margin Markov network (Taskar et al., ), emphasizing that the
scoring function is constructed from a sum of components, which are Markov independent.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
where in the second line we drop the term θ  f(w(i), y(i)), which is constant in y.
We can now reformulate the margin constraint for sequence labeling,
θ  f(w(i), y(i)) − max
y∈Y(w)

θ  f(w(i), y) + c(y(i), y)

≥ .
If the score for θ f(w(i), y(i)) is greater than the cost-augmented score for all alternatives,
then the constraint will be met. The name “cost-augmented decoding” is due to the fact
that the objective includes the standard decoding problem, maxˆy∈Y(w) θ  f(w, ˆy), plus
an additional term for the cost. Essentially, we want to train against predictions that are
strong and wrong: they should score highly according to the model, yet incur a large loss
with respect to the ground truth. Training adjusts the weights to reduce the score of these
predictions.
For cost-augmented decoding to be tractable, the cost function must decompose into
local parts, just as the feature function f() does. The Hamming cost, deﬁned above,
obeys this property. To perform cost-augmented decoding using the Hamming cost, we
need only to add features fm(ym) = δ(ym ̸= y(i)
m ), and assign a constant weight of  to
these features. Decoding can then be performed using the Viterbi algorithm.
As with large-margin classiﬁers, it is possible to formulate the learning problem in an
unconstrained form, by combining a regularization term on the weights and a Lagrangian
for the constraints:
min
||θ||
− C
θ  f(w(i), y(i)) −
max
y∈Y(w(i))
θ  f(w(i), y) + c(y(i), y)
i!
In this formulation, C is a parameter that controls the tradeoff between the regulariza-
tion term and the margin constraints. A number of optimization algorithms have been
proposed for structured support vector machines, some of which are discussed in § ...
An empirical comparison by Kummerfeld et al. () shows that stochastic subgradient
descent — which is essentially a cost-augmented version of the structured perceptron —
is highly competitive.
Conditional random ﬁelds
The conditional random ﬁeld (CRF; Lafferty et al., ) is a conditional probabilistic
model for sequence labeling; just as structured perceptron is built on the perceptron clas-
siﬁer, conditional random ﬁelds are built on the logistic regression classiﬁer. The basic
Are there cost functions that do not decompose into local parts? Suppose we want to assign a constant
loss c to any prediction ˆy in which k or more predicted tags are incorrect, and zero loss otherwise. This loss
function is combinatorial over the predictions, and thus we cannot decompose it into parts.
The name “conditional random ﬁeld” is derived from Markov random ﬁelds, a general class of models
in which the probability of a conﬁguration of variables is proportional to a product of scores across pairs (or
Jacob Eisenstein. Draft of November , .

.. DISCRIMINATIVE SEQUENCE LABELING WITH FEATURES
probability model is,
p(y | w) =
exp(Ψ(w, y))
y′∈Y(w) exp(Ψ(w, y′)).
This is almost identical to logistic regression (§ .), but because the label space is now
sequences of tags, we require efﬁcient algorithms for both decoding (searching for the
best tag sequence given a sequence of words w and a model θ) and for normalization
(summing over all tag sequences). These algorithms will be based on the usual locality
assumption on the scoring function, Ψ(w, y) = PM+
m= ψ(w, ym, ym−, m).
Decoding in CRFs
Decoding — ﬁnding the tag sequence ˆy that maximizes p(y | w) — is a direct applica-
tion of the Viterbi algorithm. The key observation is that the decoding problem does not
depend on the denominator of p(y | w),
ˆy = argmax
log p(y | w)
y′∈Y(w)
exp Ψ(y′, w)
= argmax
Ψ(y, w) − log
= argmax
Ψ(y, w) = argmax
m=
sm(ym, ym−).
M+
This is identical to the decoding problem for structured perceptron, so the same Viterbi
recurrence as deﬁned in Equation . can be used.
Learning in CRFs
As with logistic regression, the weights θ are learned by minimizing the regularized neg-
ative log-probability,
ℓ =λ
i=
log p(y(i) | w(i); θ)
||θ|| −
=λ
||θ|| −
i=
θ  f(w(i), y(i)) + log
y′∈Y(w(i))
exp

θ  f(w(i), y′)

more generally, cliques) of variables in a factor graph. In sequence labeling, the pairs of variables include
all adjacent tags (ym, ym−). The probability is conditioned on the words w, which are always observed,
motivating the term “conditional” in the name.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
where λ controls the amount of regularization. The ﬁnal term in Equation . is a sum
over all possible labelings. This term is the log of the denominator in Equation ., some-
times known as the partition function. There are |Y|M possible labelings of an input of
size M, so we must again exploit the decomposition of the scoring function to compute
this sum efﬁciently.
The sum P
y∈Yw(i) exp Ψ(y, w) can be computed efﬁciently using the forward recur-
rence, which is closely related to the Viterbi recurrence. We ﬁrst deﬁne a set of forward
variables, αm(ym), which is equal to the sum of the scores of all paths leading to tag ym at
position m:
n=
sn(yn, yn−)
y:m−
exp
αm(ym) ≜
n=
exp sn(yn, yn−).
y:m−
Note the similarity to the deﬁnition of the Viterbi variable, vm(ym) = maxy:m−
Pm
n= sn(yn, yn−).
In the hidden Markov model, the Viterbi recurrence had an alternative interpretation as
the max-product algorithm (see Equation .); analogously, the forward recurrence is
known as the sum-product algorithm, because of the form of [.]. The forward variable
can also be computed through a recurrence:
n=
exp sn(yn, yn−)
y:m−
αm(ym) =
n=
exp sn(yn, yn−)
y:m−
ym−
(exp sm(ym, ym−))
m−
ym−
(exp sm(ym, ym−)) × αm−(ym−).
Using the forward recurrence, it is possible to compute the denominator of the condi-
tional probability,
m=
exp sm(ym, ym−)
y:M
(exp sM+(♦, yM))
y∈Y(w)
Ψ(w, y) =
=αM+(♦).
The terminology of “potentials” and “partition functions” comes from statistical mechanics (Bishop,
Jacob Eisenstein. Draft of November , .

.. DISCRIMINATIVE SEQUENCE LABELING WITH FEATURES
The conditional log-likelihood can be rewritten,
ℓ =λ
i=
θ  f(w(i), y(i)) + log αM+(♦).
||θ|| −
Probabilistic programming environments, such as TORCH (Collobert et al., ) and
DYNET (Neubig et al., ), can compute the gradient of this objective using automatic
differentiation. The programmer need only implement the forward algorithm as a com-
putation graph.
As in logistic regression, the gradient of the likelihood with respect to the parameters
is a difference between observed and expected feature counts:
dℓ
dθj
=λθj +
i=
E[fj(w(i), y)] − fj(w(i), y(i)),
where fj(w(i), y(i)) refers to the count of feature j for token sequence w(i) and tag se-
quence y(i). The expected feature counts are computed “under the hood” when automatic
differentiation is applied to Equation . (Eisner, ).
Before the widespread use of automatic differentiation, it was common to compute
the feature expectations from marginal tag probabilities p(ym | w). These marginal prob-
abilities are sometimes useful on their own, and can be computed using the forward-
backward algorithm. This algorithm combines the forward recurrence with an equivalent
backward recurrence, which traverses the input from wM back to w.
*Forward-backward algorithm
Marginal probabilities over tag bigrams can be written as,
Pr(Ym− = k′, Ym = k | w) =
y:Ym=k,Ym−=k′
QM
n= exp sn(yn, yn−)
y′
QM
n= exp sn(y′n, y′
n−)
The numerator sums over all tag sequences that include the transition (Ym− = k′) →
(Ym = k). Because we are only interested in sequences that include the tag bigram, this
sum can be decomposed into three parts: the preﬁxes y:m−, terminating in Ym− = k′; the
Recall the notational convention of upper-case letters for random variables, e.g. Ym, and lower case
letters for speciﬁc values, e.g., ym, so that Ym = k is interpreted as the event of random variable Ym taking
the value k.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
Ym− = k′
Ym = k
αm−(k′)
exp sm(k, k′)
βm(k)
Figure .:
A schematic illustration of the computation of the marginal probability
Pr(Ym− = k′, Ym = k), using the forward score αm−(k′) and the backward score βm(k).
transition (Ym− = k′) → (Ym = k); and the sufﬁxes ym:M, beginning with the tag Ym = k:
n=
exp sn(yn, yn−)
y:Ym=k,Ym−=k′
y:m−:Ym−=k′
n=
exp sn(yn, yn−) =
m−
× exp sm(k, k′)
n=m+
exp sn(yn, yn−).
ym:M:Ym=k
M+
The result is product of three terms: a score that sums over all the ways to get to the
position (Ym− = k′), a score for the transition from k′ to k, and a score that sums over
all the ways of ﬁnishing the sequence from (Ym = k). The ﬁrst term of Equation . is
equal to the forward variable, αm−(k′). The third term — the sum over ways to ﬁnish the
sequence — can also be deﬁned recursively, this time moving over the trellis from right to
left, which is known as the backward recurrence:
n=m
exp sn(yn, yn−)
ym:M:Ym=k
βm(k) ≜
M+
n=m+
exp sn(yn, yn−)
ym+:M:Ym=k′
k′∈Y
exp sm+(k′, k)
M+
k′∈Y
exp sm+(k′, k) × βm+(k′).
To understand this computation, compare with the forward recurrence in Equation ..
Jacob Eisenstein. Draft of November , .

.. NEURAL SEQUENCE LABELING
In practice, numerical stability demands that we work in the log domain,
log αm(k) = log
k′∈Y
exp
log sm(k, k′) + log αm−(k′)
log βm−(k) = log
k′∈Y
exp
log sm(k′, k) + log βm(k′)
The application of the forward and backward probabilities is shown in Figure ..
Both the forward and backward recurrences operate on the trellis, which implies a space
complexity O(MK). Because both recurrences require computing a sum over K terms at
each node in the trellis, their time complexity is O(MK).
Neural sequence labeling
In neural network approaches to sequence labeling, we construct a vector representa-
tion for each tagging decision, based on the word and its context. Neural networks can
perform tagging as a per-token classiﬁcation decision, or they can be combined with the
Viterbi algorithm to tag the entire sequence globally.
Recurrent neural networks
Recurrent neural networks (RNNs) were introduced in chapter  as a language model-
ing technique, in which the context at token m is summarized by a recurrently-updated
vector,
hm =g(xm, hm−),
m = , , . . . M,
where xm is the vector embedding of the token wm and the function g deﬁnes the recur-
rence. The starting condition h is an additional parameter of the model. The long short-
term memory (LSTM) is a more complex recurrence, in which a memory cell is through a
series of gates, avoiding repeated application of the non-linearity. Despite these bells and
whistles, both models share the basic architecture of recurrent updates across a sequence,
and both will be referred to as RNNs here.
A straightforward application of RNNs to sequence labeling is to score each tag ym as
a linear function of hm:
ψm(y) =βy  hm
ˆym = argmax
ψm(y).
The score ψm(y) can also be converted into a probability distribution using the usual soft-
max operation,
p(y | w:m) =
exp ψm(y)
y′∈Y exp ψm(y′).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
Using this transformation, it is possible to train the tagger from the negative log-likelihood
of the tags, as in a conditional random ﬁeld. Alternatively, a hinge loss or margin loss
objective can be constructed from the raw scores ψm(y).
The hidden state hm accounts for information in the input leading up to position m,
but it ignores the subsequent tokens, which may also be relevant to the tag ym. This can
be addressed by adding a second RNN, in which the input is reversed, running the recur-
rence from wM to w. This is known as a bidirectional recurrent neural network (Graves
and Schmidhuber, ), and is speciﬁed as:
h m =g(xm, ←−
h m+),
m = , , . . . , M.
The hidden states of the left-to-right RNN are denoted −→
h m. The left-to-right and right-to-
left vectors are concatenated, hm = [←−
h m; −→
h m]. The scoring function in Equation . is
applied to this concatenated vector.
Bidirectional RNN tagging has several attractive properties. Ideally, the representa-
tion hm summarizes the useful information from the surrounding context, so that it is not
necessary to design explicit features to capture this information. If the vector hm is an ad-
equate summary of this context, then it may not even be necessary to perform the tagging
jointly: in general, the gains offered by joint tagging of the entire sequence are diminished
as the individual tagging model becomes more powerful. Using backpropagation, the
word vectors x can be trained “end-to-end”, so that they capture word properties that are
useful for the tagging task. Alternatively, if limited labeled data is available, we can use
word embeddings that are “pre-trained” from unlabeled data, using a language modeling
objective (as in § .) or a related word embedding technique (see chapter ). It is even
possible to combine both ﬁne-tuned and pre-trained embeddings in a single model.
Neural structure prediction
The bidirectional recurrent neural network incorporates in-
formation from throughout the input, but each tagging decision is made independently.
In some sequence labeling applications, there are very strong dependencies between tags:
it may even be impossible for one tag to follow another. In such scenarios, the tagging
decision must be made jointly across the entire sequence.
Neural sequence labeling can be combined with the Viterbi algorithm by deﬁning the
local scores as:
sm(ym, ym−) = βym  hm + ηym−,ym,
where hm is the RNN hidden state, βym is a vector associated with tag ym, and ηym−,ym
is a scalar parameter for the tag transition (ym−, ym). These local scores can then be
incorporated into the Viterbi algorithm for inference, and into the forward algorithm for
training. This model is shown in Figure .. It can be trained from the conditional log-
likelihood objective deﬁned in Equation ., backpropagating to the tagging parameters
Jacob Eisenstein. Draft of November , .

.. NEURAL SEQUENCE LABELING
ym−
ym
ym+
h m
h m+
h m−
h m
h m+
h m−
xm−
xm
xm+
Figure .: Bidirectional LSTM for sequence labeling. The solid lines indicate computa-
tion, the dashed lines indicate probabilistic dependency, and the dotted lines indicate the
optional additional probabilistic dependencies between labels in the biLSTM-CRF.
β and η, as well as the parameters of the RNN. This model is called the LSTM-CRF, due
to its combination of aspects of the long short-term memory and conditional random ﬁeld
models (Huang et al., ).
The LSTM-CRF is especially effective on the task of named entity recognition (Lample
et al., ), a sequence labeling task that is described in detail in § .. This task has strong
dependencies between adjacent tags, so structure prediction is especially important.
Character-level models
As in language modeling, rare and unseen words are a challenge: if we encounter a word
that was not in the training data, then there is no obvious choice for the word embed-
ding xm. One solution is to use a generic unseen word embedding for all such words.
However, in many cases, properties of unseen words can be guessed from their spellings.
For example, whimsical does not appear in the Universal Dependencies (UD) English Tree-
bank, yet the sufﬁx -al makes it likely to be adjective; by the same logic, unﬂinchingly is
likely to be an adverb, and barnacle is likely to be a noun.
In feature-based models, these morphological properties were handled by sufﬁx fea-
tures; in a neural network, they can be incorporated by constructing the embeddings of
unseen words from their spellings or morphology. One way to do this is to incorporate
an additional layer of bidirectional RNNs, one for each word in the vocabulary (Ling
et al., ). For each such character-RNN, the inputs are the characters, and the output
is the concatenation of the ﬁnal states of the left-facing and right-facing passes, φw =
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
h (w)
Nw; ←−
h (w)
], where −→
h (w)
Nw is the ﬁnal state of the right-facing pass for word w, and Nw
is the number of characters in the word. The character RNN model is trained by back-
propagation from the tagging objective. On the test data, the trained RNN is applied to
out-of-vocabulary words (or all words), yielding inputs to the word-level tagging RNN.
Other approaches to compositional word embeddings are described in § ...
Convolutional Neural Networks for Sequence Labeling
One disadvantage of recurrent neural networks is that the architecture requires iterating
through the sequence of inputs and predictions: each hidden vector hm must be com-
puted from the previous hidden vector hm−, before predicting the tag ym. These iterative
computations are difﬁcult to parallelize, and fail to exploit the speedups offered by graph-
ics processing units (GPUs) on operations such as matrix multiplication. Convolutional
neural networks achieve better computational performance by predicting each label ym
from a set of matrix operations on the neighboring word embeddings, xm−k:m+k (Col-
lobert et al., ). Because there is no hidden state to update, the predictions for each
ym can be computed in parallel. For more on convolutional neural networks, see § ..
Character-based word embeddings can also be computed using convolutional neural net-
works (Santos and Zadrozny, ).
*Unsupervised sequence labeling
In unsupervised sequence labeling, the goal is to induce a hidden Markov model from a
corpus of unannotated text (w(), w(), . . . , w(N)), where each w(i) is a sequence of length
M(i). This is an example of the general problem of structure induction, which is the
unsupervised version of structure prediction. The tags that result from unsupervised se-
quence labeling might be useful for some downstream task, or they might help us to better
understand the language’s inherent structure. For part-of-speech tagging, it is common
to use a tag dictionary that lists the allowed tags for each word, simplifying the prob-
lem (Christodoulopoulos et al., ).
Unsupervised learning in hidden Markov models can be performed using the Baum-
Welch algorithm, which combines the forward-backward algorithm (§ ..) with expectation-
maximization (EM; § ..). In the M-step, the HMM parameters from expected counts:
Pr(W = i | Y = k) = φk,i =E[count(W = i, Y = k)]
E[count(Y = k)]
Pr(Ym = k | Ym− = k′) = λk′,k =E[count(Ym = k, Ym− = k′)]
E[count(Ym− = k′)]
Jacob Eisenstein. Draft of November , .

.. *UNSUPERVISED SEQUENCE LABELING
The expected counts are computed in the E-step, using the forward and backward
recurrences. The local scores follow the usual deﬁnition for hidden Markov models,
sm(k, k′) = log pE(wm | Ym = k; φ) + log pT (Ym = k | Ym− = k′; λ).
The expected transition counts for a single instance are,
E[count(Ym = k, Ym− = k′) | w] =
m=
Pr(Ym− = k′, Ym = k | w)
y:Ym=k,Ym−=k′
QM
n= exp sn(yn, yn−)
y′
QM
n= exp sn(y′n, y′
n−)
As described in § .., these marginal probabilities can be computed from the forward-
backward recurrence,
Pr(Ym− = k′, Ym = k | w) =αm−(k′) × exp sm(k, k′) × βm(k)
αM+(♦)
In a hidden Markov model, each element of the forward-backward computation has a
special interpretation:
αm−(k′) =p(Ym− = k′, w:m−)
exp sm(k, k′) =p(Ym = k, wm | Ym− = k′)
βm(k) =p(wm+:M | Ym = k).
Applying the conditional independence assumptions of the hidden Markov model (de-
ﬁned in Algorithm ), the product is equal to the joint probability of the tag bigram and
the entire input,
αm−(k′) × exp sm(k, k′) × βm(k) =p(Ym− = k′, w:m−)
× p(Ym = k, wm | Ym− = k′)
× p(wm+:M | Ym = k)
=p(Ym− = k′, Ym = k, w:M).
Dividing by αM+(♦) = p(w:M) gives the desired probability,
αm−(k′) × sm(k, k′) × βm(k)
p(w:M)
αM+(♦)
=p(Ym− = k′, Ym = k, w:M)
= Pr(Ym− = k′, Ym = k | w:M).
The expected emission counts can be computed in a similar manner, using the product
αm(k) × βm(k).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
Linear dynamical systems
The forward-backward algorithm can be viewed as Bayesian state estimation in a discrete
state space. In a continuous state space, ym ∈ RK, the equivalent algorithm is the Kalman
smoother. It also computes marginals p(ym | x:M), using a similar two-step algorithm
of forward and backward passes. Instead of computing a trellis of values at each step, the
Kalman smoother computes a probability density function qym(ym; µm, Σm), character-
ized by a mean µm and a covariance Σm around the latent state. Connections between the
Kalman smoother and the forward-backward algorithm are elucidated by Minka ()
and Murphy ().
Alternative unsupervised learning methods
As noted in § ., expectation-maximization is just one of many techniques for structure
induction. One alternative is to use Markov Chain Monte Carlo (MCMC) sampling al-
gorithms, which are brieﬂy described in § ... For the speciﬁc case of sequence labeling,
Gibbs sampling can be applied by iteratively sampling each tag ym conditioned on all the
others (Finkel et al., ):
p(ym | y−m, w:M) ∝ p(wm | ym)p(ym | y−m).
Gibbs Sampling has been applied to unsupervised part-of-speech tagging by Goldwater
and Grifﬁths (). Beam sampling is a more sophisticated sampling algorithm, which
randomly draws entire sequences y:M, rather than individual tags ym; this algorithm
was applied to unsupervised part-of-speech tagging by Van Gael et al. (). Spectral
learning (see § ..) can also be applied to sequence labeling. By factoring matrices of
co-occurrence counts of word bigrams and trigrams (Song et al., ; Hsu et al., ), it
is possible to obtain globally optimal estimates of the transition and emission parameters,
under mild assumptions.
Semiring notation and the generalized viterbi algorithm
The Viterbi and Forward recurrences can each be performed over probabilities or log
probabilities, yielding a total of four closely related recurrences. These four recurrence
scan in fact be expressed as a single recurrence in a more general notation, known as
semiring algebra. Let the symbols ⊕ and ⊗ represent generalized addition and multipli-
cation respectively. Given these operators, a generalized Viterbi recurrence is denoted,
k′∈Y
sm(k, k′) ⊗ vm−(k′).
vm(k) =
In a semiring, the addition and multiplication operators must both obey associativity, and multiplication
must distribute across addition; the addition operator must be commutative; there must be additive and
multiplicative identities  and , such that a ⊕  = a and a ⊗  = a; and there must be a multiplicative
annihilator , such that a ⊗  = .
Jacob Eisenstein. Draft of November , .

.. *UNSUPERVISED SEQUENCE LABELING
Each recurrence that we have seen so far is a special case of this generalized Viterbi
recurrence:
In the max-product Viterbi recurrence over probabilities, the ⊕ operation corre-
sponds to maximization, and the ⊗ operation corresponds to multiplication.
In the forward recurrence over probabilities, the ⊕ operation corresponds to addi-
tion, and the ⊗ operation corresponds to multiplication.
In the max-product Viterbi recurrence over log-probabilities, the ⊕ operation corre-
sponds to maximization, and the ⊗ operation corresponds to addition.
In the forward recurrence over log-probabilities, the ⊕ operation corresponds to log-
addition, a ⊕ b = log(ea + eb). The ⊗ operation corresponds to addition.
The mathematical abstraction offered by semiring notation can be applied to the soft-
ware implementations of these algorithms, yielding concise and modular implementa-
tions. For example, in the OPENFST library, generic operations are parametrized by the
choice of semiring (Allauzen et al., ).
Exercises
. Extend the example in § .. to the sentence they can can ﬁsh, meaning that “they can
put ﬁsh into cans.” Build the trellis for this example using the weights in Table .,
and identify the best-scoring tag sequence. If the scores for noun and verb are tied,
then you may assume that the backpointer always goes to noun.
. Using the tagset Y = {N, V }, and the feature set f(w, ym, ym−, m) = {(wm, ym), (ym, ym−)},
show that there is no set of weights that give the correct tagging for both they can
ﬁsh (N V V) and they can can ﬁsh (N V V N).
. Work out what happens if you train a structured perceptron on the two exam-
ples mentioned in the previous problem, using the transition and emission features
(ym, ym−) and (ym, wm). Initialize all weights at , and assume that the Viterbi algo-
rithm always chooses N when the scores for the two tags are tied, so that the initial
prediction for they can ﬁsh is N N N.
. Consider the garden path sentence, The old man the boat. Given word-tag and tag-tag
features, what inequality in the weights must hold for the correct tag sequence to
outscore the garden path tag sequence for this example?
This is sometimes called the tropical semiring, in honor of the Brazilian mathematician Imre Simon.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . SEQUENCE LABELING
. Using the weights in Table ., explicitly compute the log-probabilities for all pos-
sible taggings of the input ﬁsh can. Verify that the forward algorithm recovers the
aggregate log probability.
. Sketch out an algorithm for a variant of Viterbi that returns the top-n label se-
quences. What is the time and space complexity of this algorithm?
. Show how to compute the marginal probability Pr(ym− = k, ym = k′ | w:M), in
terms of the forward and backward variables, and the potentials sn(yn, yn−).
. Suppose you receive a stream of text, where some of tokens have been replaced at
random with NOISE. For example:
Source: I try all things, I achieve what I can
Message received: I try NOISE NOISE, I NOISE what I NOISE
Assume you have access to a pre-trained bigram language model, which gives prob-
abilities p(wm | wm−). These probabilities can be assumed to be non-zero for all
bigrams.
Show how to use the Viterbi algorithm to recover the source by maximizing the
bigram language model log-probability. Speciﬁcally, set the scores sm(ym, ym−) so
that the Viterbi algorithm selects a sequence of words that maximizes the bigram
language model log-probability, while leaving the non-noise tokens intact. Your
solution should not modify the logic of the Viterbi algorithm, it should only set the
scores sm(ym, ym−).
. Let α() and β() indicate the forward and backward variables as deﬁned in § ...
Prove that αM+(♦) = β(♦) = P
y αm(y)βm(y), ∀m ∈ {, , . . . , M}.
. Consider an RNN tagging model with a tanh activation function on the hidden
layer, and a hinge loss on the output. (The problem also works for the margin loss
and negative log-likelihood.) Suppose you initialize all parameters to zero: this in-
cludes the word embeddings that make up x, the transition matrix Θ, the output
weights β, and the initial hidden state h.
a) Prove that for any data and for any gradient-based learning algorithm, all pa-
rameters will be stuck at zero.
b) Would a sigmoid activation function avoid this problem?
Jacob Eisenstein. Draft of November , .

Chapter
Applications of sequence labeling
Sequence labeling has applications throughout natural language processing. This chap-
ter focuses on part-of-speech tagging, morpho-syntactic attribute tagging, named entity
recognition, and tokenization. It also touches brieﬂy on two applications to interactive
settings: dialogue act recognition and the detection of code-switching points between
languages.
Part-of-speech tagging
The syntax of a language is the set of principles under which sequences of words are
judged to be grammatically acceptable by ﬂuent speakers. One of the most basic syntactic
concepts is the part-of-speech (POS), which refers to the syntactic role of each word in a
sentence. This concept was used informally in the previous chapter, and you may have
some intuitions from your own study of English. For example, in the sentence We like
vegetarian sandwiches, you may already know that we and sandwiches are nouns, like is a
verb, and vegetarian is an adjective. These labels depend on the context in which the word
appears: in she eats like a vegetarian, the word like is a preposition, and the word vegetarian
is a noun.
Parts-of-speech can help to disentangle or explain various linguistic problems. Recall
Chomsky’s proposed distinction in chapter :
a. Colorless green ideas sleep furiously.
b.
* Ideas colorless furiously green sleep.
One difference between these two examples is that the ﬁrst contains part-of-speech tran-
sitions that are typical in English: adjective to adjective, adjective to noun, noun to verb,
and verb to adverb. The second example contains transitions that are unusual: noun to
adjective and adjective to verb. The ambiguity in a headline like,
CHAPTER . APPLICATIONS OF SEQUENCE LABELING
Teacher Strikes Idle Children
can also be explained in terms of parts of speech: in the interpretation that was likely
intended, strikes is a noun and idle is a verb; in the alternative explanation, strikes is a verb
and idle is an adjective.
Part-of-speech tagging is often taken as a early step in a natural language processing
pipeline. Indeed, parts-of-speech provide features that can be useful for many of the
tasks that we will encounter later, such as parsing (chapter ), coreference resolution
(chapter ), and relation extraction (chapter ).
Parts-of-Speech
The Universal Dependencies project (UD) is an effort to create syntactically-annotated
corpora across many languages, using a single annotation standard (Nivre et al., ). As
part of this effort, they have designed a part-of-speech tagset, which is meant to capture
word classes across as many languages as possible. This section describes that inventory,
giving rough deﬁnitions for each of tags, along with supporting examples.
Part-of-speech tags are morphosyntactic, rather than semantic, categories. This means
that they describe words in terms of how they pattern together and how they are inter-
nally constructed (e.g., what sufﬁxes and preﬁxes they include). For example, you may
think of a noun as referring to objects or concepts, and verbs as referring to actions or
events. But events can also be nouns:
. . . the howling of the shrieking storm.
Here howling and shrieking are events, but grammatically they act as a noun and adjective
respectively.
The Universal Dependency part-of-speech tagset
The UD tagset is broken up into three groups: open class tags, closed class tags, and
“others.”
Open class tags
Nearly all languages contain nouns, verbs, adjectives, and adverbs.
These are all open word classes, because new words can easily be added to them. The
UD tagset includes two other tags that are open classes: proper nouns and interjections.
Nouns (UD tag: NOUN) tend to describe entities and concepts, e.g.,
The UD tagset builds on earlier work from Petrov et al. (), in which a set of twelve universal tags
was identiﬁed by creating mappings from tagsets for individual languages.
One prominent exception is Korean, which some linguists argue does not have adjectives Kim ().
Jacob Eisenstein. Draft of November , .

.. PART-OF-SPEECH TAGGING
Toes are scarce among veteran blubber men.
In English, nouns tend to follow determiners and adjectives, and can play the subject
role in the sentence. They can be marked for the plural number by an -s sufﬁx.
Proper nouns (PROPN) are tokens in names, which uniquely specify a given entity,
“Moby Dick?” shouted Ahab.
Verbs (VERB), according to the UD guidelines, “typically signal events and ac-
tions.” But they are also deﬁned grammatically: they “can constitute a minimal
predicate in a clause, and govern the number and types of other constituents which
may occur in a clause.”
“Moby Dick?” shouted Ahab.
Shall we keep chasing this murderous ﬁsh?
English verbs tend to come in between the subject and some number of direct ob-
jects, depending on the verb. They can be marked for tense and aspect using sufﬁxes
such as -ed and -ing. (These sufﬁxes are an example of inﬂectional morphology,
which is discussed in more detail in § ...)
Adjectives (ADJ) describe properties of entities,
a. Shall we keep chasing this murderous ﬁsh?
b. Toes are scarce among veteran blubber men.
In the second example, scarce is a predicative adjective, linked to the subject by the
copula verb are. In contrast, murderous and veteran are attributive adjectives, modi-
fying the noun phrase in which they are embedded.
Adverbs (ADV) describe properties of events, and may also modify adjectives or
other adverbs:
a. It is not down on any map; true places never are.
b. . . . treacherously hidden beneath the loveliest tints of azure
c. Not drowned entirely, though.
Interjections (INTJ) are used in exclamations, e.g.,
Aye aye! it was that accursed white whale that razed me.
http://universaldependencies.org/u/pos/VERB.html
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . APPLICATIONS OF SEQUENCE LABELING
Closed class tags
Closed word classes rarely receive new members. They are sometimes
referred to as function words — as opposed to content words — as they have little lexical
meaning of their own, but rather, help to organize the components of the sentence.
Adpositions (ADP) describe the relationship between a complement (usually a noun
phrase) and another unit in the sentence, typically a noun or verb phrase.
a. Toes are scarce among veteran blubber men.
b. It is not down on any map.
c. Give not thyself up then.
As the examples show, English generally uses prepositions, which are adpositions
that appear before their complement. (An exception is ago, as in, we met three days
ago). Postpositions are used in other languages, such as Japanese and Turkish.
Auxiliary verbs (AUX) are a closed class of verbs that add information such as
tense, aspect, person, and number.
a. Shall we keep chasing this murderous ﬁsh?
b. What the white whale was to Ahab, has been hinted.
c. Ahab must use tools.
d. Meditation and water are wedded forever.
e. Toes are scarce among veteran blubber men.
The ﬁnal example is a copula verb, which is also tagged as an auxiliary in the UD
corpus.
Coordinating conjunctions (CCONJ) express relationships between two words or
phrases, which play a parallel role:
Meditation and water are wedded forever.
Subordinating conjunctions (SCONJ) link two clauses, making one syntactically
subordinate to the other:
It is the easiest thing in the world for a man to look as if he had a great
secret in him.
Note that
Pronouns (PRON) are words that substitute for nouns or noun phrases.
a. Be it what it will, I’ll go to it laughing.
Jacob Eisenstein. Draft of November , .

.. PART-OF-SPEECH TAGGING
b. I try all things, I achieve what I can.
The example includes the personal pronouns I and it, as well as the relative pronoun
what. Other pronouns include myself, somebody, and nothing.
Determiners (DET) provide additional information about the nouns or noun phrases
that they modify:
a. What the white whale was to Ahab, has been hinted.
b. It is not down on any map.
c. I try all things . . .
d. Shall we keep chasing this murderous ﬁsh?
Determiners include articles (the), possessive determiners (their), demonstratives
(this murderous ﬁsh), and quantiﬁers (any map).
Numerals (NUM) are an inﬁnite but closed class, which includes integers, fractions,
and decimals, regardless of whether spelled out or written in numerical form.
a. How then can this one small heart beat.
b. I am going to put him down for the three hundredth.
Particles (PART) are a catch-all of function words that combine with other words or
phrases, but do not meet the conditions of the other tags. In English, this includes
the inﬁnitival to, the possessive marker, and negation.
a. Better to sleep with a sober cannibal than a drunk Christian.
b. So man’s insanity is heaven’s sense
c. It is not down on any map
As the second example shows, the possessive marker is not considered part of the
same token as the word that it modiﬁes, so that man’s is split into two tokens. (Tok-
enization is described in more detail in § ..) A non-English example of a particle
is the Japanese question marker ka:
Sensei
Teacher
desu
is
ka
Is she a teacher?
In this notation, the ﬁrst line is the transliterated Japanese text, the second line is a token-to-token gloss,
and the third line is the translation.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . APPLICATIONS OF SEQUENCE LABELING
Other
The remaining UD tags include punctuation (PUN) and symbols (SYM). Punc-
tuation is purely structural — e.g., commas, periods, colons — while symbols can carry
content of their own. Examples of symbols include dollar and percentage symbols, math-
ematical operators, emoticons, emojis, and internet addresses. A ﬁnal catch-all tag is X,
which is used for words that cannot be assigned another part-of-speech category. The X
tag is also used in cases of code switching (between languages), described in § ..
Other tagsets
Prior to the Universal Dependency treebank, part-of-speech tagging was performed us-
ing language-speciﬁc tagsets. The dominant tagset for English was designed as part of
the Penn Treebank (PTB), and it includes  tags — more than three times as many as
the UD tagset. This granularity is reﬂected in distinctions between singular and plural
nouns, verb tenses and aspects, possessive and non-possessive pronouns, comparative
and superlative adjectives and adverbs (e.g., faster, fastest), and so on. The Brown corpus
includes a tagset that is even more detailed, with  tags (Francis, ), including special
tags for individual auxiliary verbs such as be, do, and have.
Different languages make different distinctions, and so the PTB and Brown tagsets are
not appropriate for a language such as Chinese, which does not mark the verb tense (Xia,
); nor for Spanish, which marks every combination of person and number in the
verb ending; nor for German, which marks the case of each noun phrase. Each of these
languages requires more detail than English in some areas of the tagset, and less in other
areas. The strategy of the Universal Dependencies corpus is to design a coarse-grained
tagset to be used across all languages, and then to additionally annotate language-speciﬁc
morphosyntactic attributes, such as number, tense, and case. The attribute tagging task
is described in more detail in § ..
Social media such as Twitter have been shown to require tagsets of their own (Gimpel
et al., ). Such corpora contain some tokens that are not equivalent to anything en-
countered in a typical written corpus: e.g., emoticons, URLs, and hashtags. Social media
also includes dialectal words like gonna (‘going to’, e.g. We gonna be ﬁne) and Ima (‘I’m
going to’, e.g., Ima tell you one more time), which can be analyzed either as non-standard
orthography (making tokenization impossible), or as lexical items in their own right. In
either case, it is clear that existing tags like NOUN and VERB cannot handle cases like Ima,
which combine aspects of the noun and verb. Gimpel et al. () therefore propose a new
set of tags to deal with these cases.
Accurate part-of-speech tagging
Part-of-speech tagging is the problem of selecting the correct tag for each word in a sen-
tence. Success is typically measured by accuracy on an annotated test set, which is simply
the fraction of tokens that were tagged correctly.
Jacob Eisenstein. Draft of November , .

.. PART-OF-SPEECH TAGGING
Baselines
A simple baseline for part-of-speech tagging is to choose the most common tag for each
word. For example, in the Universal Dependencies treebank, the word talk appears
times, and  of those times it is labeled as a VERB: therefore, this baseline will always
predict VERB for this word. For words that do not appear in the training corpus, the base-
line simply guesses the most common tag overall, which is NOUN. In the Penn Treebank,
this simple baseline obtains accuracy above %. A more rigorous evaluation is the accu-
racy on out-of-vocabulary words, which are not seen in the training data. Tagging these
words correctly requires attention to the context and the word’s internal structure.
Contemporary approaches
Conditional random ﬁelds and structured perceptron perform at or near the state-of-the-
art for part-of-speech tagging in English. For example, (Collins, ) achieved .%
accuracy on the Penn Treebank, using a structured perceptron with the following base
features (originally introduced by Ratnaparkhi ()):
current word, wm
previous words, wm−, wm−
next words, wm+, wm+
previous tag, ym−
previous two tags, (ym−, ym−)
for rare words:
– ﬁrst k characters, up to k =
– last k characters, up to k =
– whether wm contains a number, uppercase character, or hyphen.
Similar results for the PTB data have been achieved using conditional random ﬁelds (CRFs;
Toutanova et al., ).
More recent work has demonstrated the power of neural sequence models, such as the
long short-term memory (LSTM) (§ .). Plank et al. () apply a CRF and a bidirec-
tional LSTM to twenty-two languages in the UD corpus, achieving an average accuracy
of .% for the CRF, and .% with the bi-LSTM. Their neural model employs three
types of embeddings: ﬁne-tuned word embeddings, which are updated during training;
pre-trained word embeddings, which are never updated, but which help to tag out-of-
vocabulary words; and character-based embeddings. The character-based embeddings
are computed by running an LSTM on the individual characters in each word, thereby
capturing common orthographic patterns such as preﬁxes, sufﬁxes, and capitalization.
Extensive evaluations show that these additional embeddings are crucial to their model’s
success.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . APPLICATIONS OF SEQUENCE LABELING
word
PTB tag
UD tag
UD attributes
The
DT
DET
DEFINITE=DEF PRONTYPE=ART
German
JJ
ADJ
DEGREE=POS
Expressionist NN
NOUN
NUMBER=SING
movement
NN
NOUN
NUMBER=SING
was
VBD
AUX
MOOD=IND NUMBER=SING PERSON=
TENSE=PAST VERBFORM=FIN
destroyed
VBN
VERB
TENSE=PAST VERBFORM=PART
VOICE=PASS
as
IN
ADP
DT
DET
DEFINITE=IND PRONTYPE=ART
result
NN
NOUN
NUMBER=SING
PUNCT
Figure .: UD and PTB part-of-speech tags, and UD morphosyntactic attributes. Example
selected from the UD . English corpus.
Morphosyntactic Attributes
There is considerably more to say about a word than whether it is a noun or a verb: in En-
glish, verbs are distinguish by features such tense and aspect, nouns by number, adjectives
by degree, and so on. These features are language-speciﬁc: other languages distinguish
other features, such as case (the role of the noun with respect to the action of the sen-
tence, which is marked in languages such as Latin and German) and evidentiality (the
source of information for the speaker’s statement, which is marked in languages such as
Turkish). In the UD corpora, these attributes are annotated as feature-value pairs for each
token.
An example is shown in Figure .. The determiner the is marked with two attributes:
PRONTYPE=ART, which indicates that it is an article (as opposed to another type of deter-
Case is marked in English for some personal pronouns, e.g., She saw her, They saw them.
The annotation and tagging of morphosyntactic attributes can be traced back to earlier work on Turk-
ish (Oﬂazer and Kuru¨oz, ) and Czech (Hajiˇc and Hladk´a, ). MULTEXT-East was an early multilin-
gual corpus to include morphosyntactic attributes (Dimitrova et al., ).
Jacob Eisenstein. Draft of November , .

.. NAMED ENTITY RECOGNITION
miner or pronominal modiﬁer), and DEFINITE=DEF, which indicates that it is a deﬁnite
article (referring to a speciﬁc, known entity). The verbs are each marked with several
attributes. The auxiliary verb was is third-person, singular, past tense, ﬁnite (conjugated),
and indicative (describing an event that has happened or is currently happenings); the
main verb destroyed is in participle form (so there is no additional person and number
information), past tense, and passive voice. Some, but not all, of these distinctions are
reﬂected in the PTB tags VBD (past-tense verb) and VBN (past participle).
While there are thousands of papers on part-of-speech tagging, there is comparatively
little work on automatically labeling morphosyntactic attributes. Faruqui et al. ()
train a support vector machine classiﬁcation model, using a minimal feature set that in-
cludes the word itself, its preﬁxes and sufﬁxes, and type-level information listing all pos-
sible morphosyntactic attributes for each word and its neighbors. Mueller et al. () use
a conditional random ﬁeld (CRF), in which the tag space consists of all observed com-
binations of morphosyntactic attributes (e.g., the tag would be DEF+ART for the word
the in Figure .). This massive tag space is managed by decomposing the feature space
over individual attributes, and pruning paths through the trellis. More recent work has
employed bidirectional LSTM sequence models. For example, Pinter et al. () train
a bidirectional LSTM sequence model. The input layer and hidden vectors in the LSTM
are shared across attributes, but each attribute has its own output layer, culminating in
a softmax over all attribute values, e.g. yNUMBER
∈ {SING, PLURAL, . . .}. They ﬁnd that
character-level information is crucial, especially when the amount of labeled data is lim-
ited.
Evaluation is performed by ﬁrst computing recall and precision for each attribute.
These scores can then be averaged at either the type or token level to obtain micro- or
macro-F -MEASURE. Pinter et al. () evaluate on  languages in the UD treebank,
reporting a median micro-F -MEASURE of .. Performance is strongly correlated with the
size of the labeled dataset for each language, with a few outliers: for example, Chinese is
particularly difﬁcult, because although the dataset is relatively large ( tokens in the UD
. corpus), only % of tokens have any attributes, offering few useful labeled instances.
Named Entity Recognition
A classical problem in information extraction is to recognize and extract mentions of
named entities in text. In news documents, the core entity types are people, locations, and
organizations; more recently, the task has been extended to include amounts of money,
percentages, dates, and times. In item .a (Figure .), the named entities include: The
U.S. Army, an organization; Atlanta, a location; and May , , a date. Named en-
tity recognition is also a key task in biomedical natural language processing, with entity
types including proteins, DNA, RNA, and cell lines (e.g., Collier et al., ; Ohta et al.,
). Figure . shows an example from the GENIA corpus of biomedical research ab-
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . APPLICATIONS OF SEQUENCE LABELING
a. The
B-ORG
U.S.
I-ORG
Army
I-ORG
captured
Atlanta
B-LOC
on
May
B-DATE
I-DATE
I-DATE
I-DATE
b. Number
of
glucocorticoid
B-PROTEIN
receptors
I-PROTEIN
in
lymphocytes
B-CELLTYPE
and
Figure .: BIO notation for named entity recognition. Example (.b) is drawn from the
GENIA corpus of biomedical documents (Ohta et al., ).
stracts.
A standard approach to tagging named entity spans is to use discriminative sequence
labeling methods such as conditional random ﬁelds. However, the named entity recogni-
tion (NER) task would seem to be fundamentally different from sequence labeling tasks
like part-of-speech tagging: rather than tagging each token, the goal in is to recover spans
of tokens, such as The United States Army.
This is accomplished by the BIO notation, shown in Figure .. Each token at the
beginning of a name span is labeled with a B- preﬁx; each token within a name span is la-
beled with an I- preﬁx. These preﬁxes are followed by a tag for the entity type, e.g. B-LOC
for the beginning of a location, and I-PROTEIN for the inside of a protein name. Tokens
that are not parts of name spans are labeled as O. From this representation, the entity
name spans can be recovered unambiguously. This tagging scheme is also advantageous
for learning: tokens at the beginning of name spans may have different properties than
tokens within the name, and the learner can exploit this. This insight can be taken even
further, with special labels for the last tokens of a name span, and for unique tokens in
name spans, such as Atlanta in the example in Figure .. This is called BILOU notation,
and it can yield improvements in supervised named entity recognition (Ratinov and Roth,
Feature-based sequence labeling
Named entity recognition was one of the ﬁrst applica-
tions of conditional random ﬁelds (McCallum and Li, ). The use of Viterbi decoding
restricts the feature function f(w, y) to be a sum of local features, P
m f(w, ym, ym−, m),
so that each feature can consider only local adjacent tags. Typical features include tag tran-
sitions, word features for wm and its neighbors, character-level features for preﬁxes and
sufﬁxes, and “word shape” features for capitalization and other orthographic properties.
As an example, base features for the word Army in the example in (.a) include:
(CURR-WORD:Army, PREV-WORD:U.S., NEXT-WORD:captured, PREFIX-:A-,
PREFIX-:Ar-, SUFFIX-:-y, SUFFIX-:-my, SHAPE:Xxxx)
Features can also be obtained from a gazetteer, which is a list of known entity names. For
example, the U.S. Social Security Administration provides a list of tens of thousands of
Jacob Eisenstein. Draft of November , .

.. TOKENIZATION
日文
Japanese
章魚
octopus
怎麼
how
說?
say
How to say octopus in Japanese?
Japan
文章
essay
ﬁsh
怎麼
how
說?
say
Figure .: An example of tokenization ambiguity in Chinese (Sproat et al., )
given names — more than could be observed in any annotated corpus. Tokens or spans
that match an entry in a gazetteer can receive special features; this provides a way to
incorporate hand-crafted resources such as name lists in a learning-driven framework.
Neural sequence labeling for NER
Current research has emphasized neural sequence
labeling, using similar LSTM models to those employed in part-of-speech tagging (Ham-
merton, ; Huang et al., ; Lample et al., ). The bidirectional LSTM-CRF (Fig-
ure . in § .) does particularly well on this task, due to its ability to model tag-to-tag
dependencies. However, Strubell et al. () show that convolutional neural networks
can be equally accurate, with signiﬁcant improvement in speed due to the efﬁciency of
implementing ConvNets on graphics processing units (GPUs). The key innovation in
this work was the use of dilated convolution, which is described in more detail in § ..
Tokenization
A basic problem for text analysis, ﬁrst discussed in § .., is to break the text into a se-
quence of discrete tokens. For alphabetic languages such as English, deterministic scripts
usually sufﬁce to achieve accurate tokenization. However, in logographic writing systems
such as Chinese script, words are typically composed of a small number of characters,
without intervening whitespace. The tokenization must be determined by the reader, with
the potential for occasional ambiguity, as shown in Figure .. One approach is to match
character sequences against a known dictionary (e.g., Sproat et al., ), using additional
statistical information about word frequency. However, no dictionary is completely com-
prehensive, and dictionary-based approaches can struggle with such out-of-vocabulary
words.
Chinese word segmentation has therefore been approached as a supervised sequence
labeling problem. Xue et al. () train a logistic regression classiﬁer to make indepen-
dent segmentation decisions while moving a sliding window across the document. A set
of rules is then used to convert these individual classiﬁcation decisions into an overall to-
kenization of the input. However, these individual decisions may be globally suboptimal,
motivating a structure prediction approach. Peng et al. () train a conditional random
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . APPLICATIONS OF SEQUENCE LABELING
ﬁeld to predict labels of START or NONSTART on each character. More recent work has
employed neural network architectures. For example, Chen et al. () use an LSTM-
CRF architecture, as described in § .: they construct a trellis, in which each tag is scored
according to the hidden state of an LSTM, and tag-tag transitions are scored according
to learned transition weights. The best-scoring segmentation is then computed by the
Viterbi algorithm.
Code switching
Multilingual speakers and writers do not restrict themselves to a single language. Code
switching is the phenomenon of switching between languages in speech and text (Auer,
; Poplack, ). Written code switching has become more common in online social
media, as in the following extract from the website of Canadian President Justin Trudeau:
Although everything written on this site est
is
disponible
available
en
in
anglais
English
and in French, my personal videos seront
will be
bilingues
bilingual
Accurately analyzing such texts requires ﬁrst determining which languages are being
used. Furthermore, quantitative analysis of code switching can provide insights on the
languages themselves and their relative social positions.
Code switching can be viewed as a sequence labeling problem, where the goal is to la-
bel each token as a candidate switch point. In the example above, the words est, and, and
seront would be labeled as switch points. Solorio and Liu () detect English-Spanish
switch points using a supervised classiﬁer, with features that include the word, its part-of-
speech in each language (according to a supervised part-of-speech tagger), and the prob-
abilities of the word and part-of-speech in each language. Nguyen and Dogru¨oz ()
apply a conditional random ﬁeld to the problem of detecting code switching between
Turkish and Dutch.
Code switching is a special case of the more general problem of word level language
identiﬁcation, which Barman et al. () address in the context of trilingual code switch-
ing between Bengali, English, and Hindi. They further observe an even more challenging
phenomenon: intra-word code switching, such as the use of English sufﬁxes with Bengali
roots. They therefore mark each token as either () belonging to one of the three languages;
() a mix of multiple languages; () “universal” (e.g., symbols, numbers, emoticons); or
() undeﬁned.
As
quoted
in
http://blogues.lapresse.ca/lagace////
justin-trudeau-really-parfait-bilingue/, accessed August , .
Jacob Eisenstein. Draft of November , .

.. DIALOGUE ACTS
Speaker
Dialogue Act
Utterance
YES-NO-QUESTION
So do you go college right now?
ABANDONED
Are yo-
YES-ANSWER
Yeah,
STATEMENT
It’s my last year [laughter].
DECLARATIVE-QUESTION
You’re a, so you’re a senior now.
YES-ANSWER
Yeah,
STATEMENT
I’m working on my projects trying to graduate [laughter]
APPRECIATION
Oh, good for you.
BACKCHANNEL
Yeah.
Figure .: An example of dialogue act labeling (Stolcke et al., )
Dialogue acts
The sequence labeling problems that we have discussed so far have been over sequences
of word tokens or characters (in the case of tokenization). However, sequence labeling
can also be performed over higher-level units, such as utterances. Dialogue acts are la-
bels over utterances in a dialogue, corresponding roughly to the speaker’s intention —
the utterance’s illocutionary force (Austin, ). For example, an utterance may state a
proposition (it is not down on any map), pose a question (shall we keep chasing this murderous
ﬁsh?), or provide a response (aye aye!). Stolcke et al. () describe how a set of  dia-
logue acts were annotated for the , conversations in the Switchboard corpus (Godfrey
et al., ).
An example is shown in Figure .. The annotation is performed over UTTERANCES,
with the possibility of multiple utterances per conversational turn (in cases such as inter-
ruptions, an utterance may split over multiple turns). Some utterances are clauses (e.g., So
do you go to college right now?), while others are single words (e.g., yeah). Stolcke et al. ()
report that hidden Markov models (HMMs) achieve % accuracy on supervised utter-
ance segmentation. The labels themselves reﬂect the conversational goals of the speaker:
the utterance yeah functions as an answer in response to the question you’re a senior now,
but in the ﬁnal line of the excerpt, it is a backchannel (demonstrating comprehension).
For task of dialogue act labeling, Stolcke et al. () apply a hidden Markov model.
The probability p(wm | ym) must generate the entire sequence of words in the utterance,
and it is modeled as a trigram language model (§ .). Stolcke et al. () also account
for acoustic features, which capture the prosody of each utterance — for example, tonal
and rhythmic properties of speech, which can be used to distinguish dialogue acts such
Dialogue act modeling is not restricted to speech; it is relevant in any interactive conversation. For
example, Jeong et al. () annotate a more limited set of speech acts in a corpus of emails and online
forums.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . APPLICATIONS OF SEQUENCE LABELING
as questions and answers. These features are handled with an additional emission distri-
bution, p(am | ym), which is modeled with a probabilistic decision tree (Murphy, ).
While acoustic features yield small improvements overall, they play an important role in
distinguish questions from statements, and agreements from backchannels.
Recurrent neural architectures for dialogue act labeling have been proposed by Kalch-
brenner and Blunsom () and Ji et al. (), with strong empirical results. Both models
are recurrent at the utterance level, so that each complete utterance updates a hidden state.
The recurrent-convolutional network of Kalchbrenner and Blunsom () uses convolu-
tion to obtain a representation of each individual utterance, while Ji et al. () use a
second level of recurrence, over individual words. This enables their method to also func-
tion as a language model, giving probabilities over sequences of words in a document.
Exercises
. Using the Universal Dependencies part-of-speech tags, annotate the following sen-
tences. You may examine the UD tagging guidelines. Tokenization is shown with
whitespace. Don’t forget about punctuation.
a. I try all things , I achieve what I can .
b. It was that accursed white whale that razed me .
c. Better to sleep with a sober cannibal , than a drunk Christian .
d. Be it what it will , I ’ll go to it laughing .
. Select three short sentences from a recent news article, and annotate them for UD
part-of-speech tags. Ask a friend to annotate the same three sentences without look-
ing at your annotations. Compute the rate of agreement, using the Kappa metric
deﬁned in § ... Then work together to resolve any disagreements.
. Choose one of the following morphosyntactic attributes: MOOD, TENSE, VOICE. Re-
search the deﬁnition of this attribute on the universal dependencies website, http:
//universaldependencies.org/u/feat/index.html. Returning to the ex-
amples in the ﬁrst exercise, annotate all verbs for your chosen attribute. It may be
helpful to consult examples from an English-language universal dependencies cor-
pus, available at https://github.com/UniversalDependencies/UD_English-EWT/
tree/master.
. Download a dataset annotated for universal dependencies, such as the English Tree-
bank at https://github.com/UniversalDependencies/UD_English-EWT/
tree/master. This corpus is already segmented into training, development, and
test data.
Jacob Eisenstein. Draft of November , .

.. DIALOGUE ACTS
a) First, train a logistic regression or SVM classiﬁer using character sufﬁxes: char-
acter n-grams up to length . Compute the recall, precision, and F -MEASURE
on the development data.
b) Next, augment your classiﬁer using the same character sufﬁxes of the preced-
ing and succeeding tokens. Again, evaluate your classiﬁer on heldout data.
c) Optionally, train a Viterbi-based sequence labeling model, using a toolkit such
as CRFSuite (http://www.chokkan.org/software/crfsuite/) or your
own Viterbi implementation. This is more likely to be helpful for attributes
in which agreement is required between adjacent words. For example, many
Romance languages require gender and number agreement for determiners,
nouns, and adjectives.
. Provide BIO-style annotation of the named entities (person, place, organization,
date, or product) in the following expressions:
a. The third mate was Flask, a native of Tisbury, in Martha’s Vineyard.
b. Its ofﬁcial Nintendo announced today that they Will release the Nin-
tendo DS in north America march  (Ritter et al., ).
c. Jessica Reif, a media analyst at Merrill Lynch & Co., said, “If they can
get up and running with exclusive programming within six months, it
doesn’t set the venture back that far.”
. Run the examples above through the online version of a named entity recogni-
tion tagger, such as the Allen NLP system here: http://demo.allennlp.org/named-
entity-recognition. Do the predicted tags match your annotations?
. Build a whitespace tokenizer for English:
a) Using the NLTK library, download the complete text to the novel Alice in Won-
derland (Carroll, ). Hold out the ﬁnal  words as a test set.
b) Label each alphanumeric character as a segmentation point, ym =  if m is
the ﬁnal character of a token. Label every other character as ym = . Then
concatenate all the tokens in the training and test sets.Make sure that the num-
ber of labels {ym}M
m= is identical to the number of characters {cm}M
m= in your
concatenated datasets.
c) Train a logistic regression classiﬁer to predict ym, using the surrounding char-
acters cm−:m+ as features. After training the classiﬁer, run it on the test set,
using the predicted segmentation points to re-tokenize the text.
From the Message Understanding Conference (MUC-) dataset (Chinchor and Robinson, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . APPLICATIONS OF SEQUENCE LABELING
d) Compute the per-character segmentation accuracy on the test set. You should
be able to get at least % accuracy.
e) Print out a sample of segmented text from the test set, e.g.
Thereareno mice in the air , I ’ m afraid , but y oumight cat
chabat , and that ’ svery like a mouse , youknow . But
docatseat bats , I wonder ?’
. Perform the following extensions to your tokenizer in the previous problem.
a) Train a conditional random ﬁeld sequence labeler, by incorporating the tag
bigrams (ym−, ym) as additional features. You may use a structured predic-
tion library such as CRFSuite, or you may want to implement Viterbi yourself.
Compare the accuracy with your classiﬁcation-based approach.
b) Compute the token-level performance: treating the original tokenization as
ground truth, compute the number of true positives (tokens that are in both
the ground truth and predicted tokenization), false positives (tokens that are in
the predicted tokenization but not the ground truth), and false negatives (to-
kens that are in the ground truth but not the predicted tokenization). Compute
the F-measure.
Hint: to match predicted and ground truth tokens, add “anchors” for the start
character of each token. The number of true positives is then the size of the
intersection of the sets of predicted and ground truth tokens.
c) Apply the same methodology in a more practical setting: tokenization of Chi-
nese, which is written without whitespace. You can ﬁnd annotated datasets at
http://alias-i.com/lingpipe/demos/tutorial/chineseTokens/read-me.
html.
Jacob Eisenstein. Draft of November , .

Chapter
Formal language theory
We have now seen methods for learning to label individual words, vectors of word counts,
and sequences of words; we will soon proceed to more complex structural transforma-
tions. Most of these techniques could apply to counts or sequences from any discrete vo-
cabulary; there is nothing fundamentally linguistic about, say, a hidden Markov model.
This raises a basic question that this text has not yet considered: what is a language?
This chapter will take the perspective of formal language theory, in which a language
is deﬁned as a set of strings, each of which is a sequence of elements from a ﬁnite alphabet.
For interesting languages, there are an inﬁnite number of strings that are in the language,
and an inﬁnite number of strings that are not. For example:
the set of all even-length sequences from the alphabet {a, b}, e.g., {∅, aa, ab, ba, bb, aaaa, aaab, . . .};
the set of all sequences from the alphabet {a, b} that contain aaa as a substring, e.g.,
{aaa, aaaa, baaa, aaab, . . .};
the set of all sequences of English words (drawn from a ﬁnite dictionary) that con-
tain at least one verb (a ﬁnite subset of the dictionary);
the PYTHON programming language.
Formal language theory deﬁnes classes of languages and their computational prop-
erties. Of particular interest is the computational complexity of solving the membership
problem — determining whether a string is in a language. The chapter will focus on
three classes of formal languages: regular, context-free, and “mildly” context-sensitive
languages.
A key insight of th century linguistics is that formal language theory can be usefully
applied to natural languages such as English, by designing formal languages that cap-
ture as many properties of the natural language as possible. For many such formalisms, a
useful linguistic analysis comes as a byproduct of solving the membership problem. The
CHAPTER . FORMAL LANGUAGE THEORY
membership problem can be generalized to the problems of scoring strings for their ac-
ceptability (as in language modeling), and of transducing one string into another (as in
translation).
Regular languages
If you have written a regular expression, then you have deﬁned a regular language: a
regular language is any language that can be deﬁned by a regular expression. Formally, a
regular expression can include the following elements:
A literal character drawn from some ﬁnite alphabet Σ.
The empty string ϵ.
The concatenation of two regular expressions RS, where R and S are both regular
expressions. The resulting expression accepts any string that can be decomposed
x = yz, where y is accepted by R and z is accepted by S.
The alternation R | S, where R and S are both regular expressions. The resulting
expression accepts a string x if it is accepted by R or it is accepted by S.
The Kleene star R∗, which accepts any string x that can be decomposed into a se-
quence of strings which are all accepted by R.
Parenthesization (R), which is used to limit the scope of the concatenation, alterna-
tion, and Kleene star operators.
Here are some example regular expressions:
The set of all even length strings on the alphabet {a, b}: ((aa)|(ab)|(ba)|(bb))∗
The set of all sequences of the alphabet {a, b} that contain aaa as a substring: (a|b)∗aaa(a|b)∗
The set of all sequences of English words that contain at least one verb: W ∗V W ∗,
where W is an alternation between all words in the dictionary, and V is an alterna-
tion between all verbs (V ⊆ W).
This list does not include a regular expression for the Python programming language,
because this language is not regular — there is no regular expression that can capture its
syntax. We will discuss why towards the end of this section.
Regular languages are closed under union, intersection, and concatenation. This means
that if two languages L and L are regular, then so are the languages L ∪ L, L ∩ L,
and the language of strings that can be decomposed as s = tu, with s ∈ L and t ∈ L.
Regular languages are also closed under negation: if L is regular, then so is the language
L = {s /∈ L}.
Jacob Eisenstein. Draft of November , .

.. REGULAR LANGUAGES
start
Figure .: State diagram for the ﬁnite state acceptor M.
Finite state acceptors
A regular expression deﬁnes a regular language, but does not give an algorithm for de-
termining whether a string is in the language that it deﬁnes. Finite state automata are
theoretical models of computation on regular languages, which involve transitions be-
tween a ﬁnite number of states. The most basic type of ﬁnite state automaton is the ﬁnite
state acceptor (FSA), which describes the computation involved in testing if a string is
a member of a language. Formally, a ﬁnite state acceptor is a tuple M = (Q, Σ, q, F, δ),
consisting of:
a ﬁnite alphabet Σ of input symbols;
a ﬁnite set of states Q = {q, q, . . . , qn};
a start state q ∈ Q;
a set of ﬁnal states F ⊆ Q;
a transition function δ : Q × (Σ ∪ {ϵ}) → Q. The transition function maps from a
state and an input symbol (or empty string ϵ) to a set of possible resulting states.
A path in M is a sequence of transitions, π = t, t, . . . , tN, where each ti traverses an
arc in the transition function δ. The ﬁnite state acceptor M accepts a string ω if there is
an accepting path, in which the initial transition t begins at the start state q, the ﬁnal
transition tN terminates in a ﬁnal state in Q, and the entire input ω is consumed.
Example
Consider the following FSA, M.
Σ ={a, b}
Q ={q, q}
F ={q}
δ ={(q, a) → q, (q, b) → q, (q, b) → q}.
This FSA deﬁnes a language over an alphabet of two symbols, a and b. The transition
function δ is written as a set of arcs: (q, a) → q says that if the machine is in state
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
q and reads symbol a, it stays in q. Figure . provides a graphical representation of
M. Because each pair of initial state and symbol has at most one resulting state, M is
deterministic: each string ω induces at most one accepting path. Note that there are no
transitions for the symbol a in state q; if a is encountered in q, then the acceptor is stuck,
and the input string is rejected.
What strings does M accept? The start state is q, and we have to get to q, since this
is the only ﬁnal state. Any number of a symbols can be consumed in q, but a b symbol is
required to transition to q. Once there, any number of b symbols can be consumed, but
an a symbol cannot. So the regular expression corresponding to the language deﬁned by
M is a∗bb∗.
Computational properties of ﬁnite state acceptors
The key computational question for ﬁnite state acceptors is: how fast can we determine
whether a string is accepted? For determistic FSAs, this computation can be performed
by Dijkstra’s algorithm, with time complexity O(V log V + E), where V is the number of
vertices in the FSA, and E is the number of edges (Cormen et al., ). Non-deterministic
FSAs (NFSAs) can include multiple transitions from a given symbol and state. Any NSFA
can be converted into a deterministic FSA, but the resulting automaton may have a num-
ber of states that is exponential in the number of size of the original NFSA (Mohri et al.,
Morphology as a regular language
Many words have internal structure, such as preﬁxes and sufﬁxes that shape their mean-
ing. The study of word-internal structure is the domain of morphology, of which there
are two main types:
Derivational morphology describes the use of afﬁxes to convert a word from one
grammatical category to another (e.g., from the noun grace to the adjective graceful),
or to change the meaning of the word (e.g., from grace to disgrace).
Inﬂectional morphology describes the addition of details such as gender, number,
person, and tense (e.g., the -ed sufﬁx for past tense in English).
Morphology is a rich topic in linguistics, deserving of a course in its own right. The
focus here will be on the use of ﬁnite state automata for morphological analysis. The
A good starting point would be a chapter from a linguistics textbook (e.g., Akmajian et al., ; Bender,
). A key simpliﬁcation in this chapter is the focus on afﬁxes at the sole method of derivation and inﬂec-
tion. English makes use of afﬁxes, but also incorporates apophony, such as the inﬂection of foot to feet. Semitic
languages like Arabic and Hebrew feature a template-based system of morphology, in which roots are triples
of consonants (e.g., ktb), and words are created by adding vowels: kataba (Arabic: he wrote), kutub (books),
maktab (desk). For more detail on morphology, see texts from Haspelmath and Sims () and Lieber ().
Jacob Eisenstein. Draft of November , .

.. REGULAR LANGUAGES
current section deals with derivational morphology; inﬂectional morphology is discussed
in § ...
Suppose that we want to write a program that accepts only those words that are con-
structed in accordance with the rules of English derivational morphology:
a. grace, graceful, gracefully, *gracelyful
b. disgrace, *ungrace, disgraceful, disgracefully
c. allure, *allureful, alluring, alluringly
d. fairness, unfair, *disfair, fairly
(Recall that the asterisk indicates that a linguistic example is judged unacceptable by ﬂu-
ent speakers of a language.) These examples cover only a tiny corner of English deriva-
tional morphology, but a number of things stand out. The sufﬁx -ful converts the nouns
grace and disgrace into adjectives, and the sufﬁx -ly converts adjectives into adverbs. These
sufﬁxes must be applied in the correct order, as shown by the unacceptability of *grace-
lyful. The -ful sufﬁx works for only some words, as shown by the use of alluring as the
adjectival form of allure. Other changes are made with preﬁxes, such as the derivation
of disgrace from grace, which roughly corresponds to a negation; however, fair is negated
with the un- preﬁx instead. Finally, while the ﬁrst three examples suggest that the direc-
tion of derivation is noun → adjective → adverb, the example of fair suggests that the
adjective can also be the base form, with the -ness sufﬁx performing the conversion to a
noun.
Can we build a computer program that accepts only well-formed English words, and
rejects all others? This might at ﬁrst seem trivial to solve with a brute-force attack: simply
make a dictionary of all valid English words. But such an approach fails to account for
morphological productivity — the applicability of existing morphological rules to new
words and names, such as Trump to Trumpy and Trumpkin, and Clinton to Clintonian and
Clintonite. We need an approach that represents morphological rules explicitly, and for
this we will try a ﬁnite state acceptor.
The dictionary approach can be implemented as a ﬁnite state acceptor, with the vo-
cabulary Σ equal to the vocabulary of English, and a transition from the start state to the
accepting state for each word. But this would of course fail to generalize beyond the origi-
nal vocabulary, and would not capture anything about the morphotactic rules that govern
derivations from new words. The ﬁrst step towards a more general approach is shown in
Figure ., which is the state diagram for a ﬁnite state acceptor in which the vocabulary
consists of morphemes, which include stems (e.g., grace, allure) and afﬁxes (e.g., dis-, -ing,
-ly). This ﬁnite state acceptor consists of a set of paths leading away from the start state,
with derivational afﬁxes added along the path. Except for qneg, the states on these paths
are all ﬁnal, so the FSA will accept disgrace, disgraceful, and disgracefully, but not dis-.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
-ful
-ly
qN
qJ
qA
grace
grace
-ful
-ly
qneg
qN
qJ
qA
dis-
start
qN
qJ
qA
allure
-ing
-ly
fair
-ness
qJ
qN
qA
-ly
Figure .: A ﬁnite state acceptor for a fragment of English derivational morphology. Each
path represents possible derivations from a single root form.
This FSA can be minimized to the form shown in Figure ., which makes the gen-
erality of the ﬁnite state approach more apparent. For example, the transition from q to
qJ can be made to accept not only fair but any single-morpheme (monomorphemic) ad-
jective that takes -ness and -ly as sufﬁxes. In this way, the ﬁnite state acceptor can easily
be extended: as new word stems are added to the vocabulary, their derived forms will be
accepted automatically. Of course, this FSA would still need to be extended considerably
to cover even this small fragment of English morphology. As shown by cases like music
→ musical, athlete → athletic, English includes several classes of nouns, each with its own
rules for derivation.
The FSAs shown in Figure . and . accept allureing, not alluring. This reﬂects a dis-
tinction between morphology — the question of which morphemes to use, and in what
order — and orthography — the question of how the morphemes are rendered in written
language. Just as orthography requires dropping the e preceding the -ing sufﬁx, phonol-
ogy imposes a related set of constraints on how words are rendered in speech. As we will
see soon, these issues can be handled by ﬁnite state!transducers, which are ﬁnite state
automata that take inputs and produce outputs.
Weighted ﬁnite state acceptors
According to the FSA treatment of morphology, every word is either in or out of the lan-
guage, with no wiggle room. Perhaps you agree that musicky and ﬁshful are not valid
English words; but if forced to choose, you probably ﬁnd a ﬁshful stew or a musicky trib-
ute preferable to behaving disgracelyful. Rather than asking whether a word is acceptable,
we might like to ask how acceptable it is. Aronoff (, page ) puts it another way:
Jacob Eisenstein. Draft of November , .

.. REGULAR LANGUAGES
grace
-ful
-ly
qneg
qN
qJ
qA
dis-
grace
-ing
start
-ly
qN
allure
fair
-ness
qJ
qN
Figure .: Minimization of the ﬁnite state acceptor shown in Figure ..
“Though many things are possible in morphology, some are more possible than others.”
But ﬁnite state acceptors give no way to express preferences among technically valid
choices.
Weighted ﬁnite state acceptors (WFSAs) are generalizations of FSAs, in which each
accepting path is assigned a score, computed from the transitions, the initial state, and the
ﬁnal state. Formally, a weighted ﬁnite state acceptor M = (Q, Σ, λ, ρ, δ) consists of:
a ﬁnite set of states Q = {q, q, . . . , qn};
a ﬁnite alphabet Σ of input symbols;
an initial weight function, λ : Q → R;
a ﬁnal weight function ρ : Q → R;
a transition function δ : Q × Σ × Q → R.
WFSAs depart from the FSA formalism in three ways: every state can be an initial
state, with score λ(q); every state can be an accepting state, with score ρ(q); transitions are
possible between any pair of states on any input, with a score δ(qi, ω, qj). Nonetheless,
FSAs can be viewed as a special case: for any FSA M we can build an equivalent WFSA
by setting λ(q) = ∞ for all q ̸= q, ρ(q) = ∞ for all q /∈ F, and δ(qi, ω, qj) = ∞ for all
transitions {(q, ω) → q} that are not permitted by the transition function of M.
The total score for any path π = t, t, . . . , tN is equal to the sum of these scores,
d(π) = λ(from-state(t)) +
δ(tn) + ρ(to-state(tN)).
A shortest-path algorithm is used to ﬁnd the minimum-cost path through a WFSA for
string ω, with time complexity O(E + V log V ), where E is the number of edges and V is
the number of vertices (Cormen et al., ).
Shortest-path algorithms ﬁnd the path with the minimum cost. In many cases, the path weights are log
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
N-gram language models as WFSAs
In n-gram language models (see § .), the probability of a sequence of tokens w, w, . . . , wM
is modeled as,
p(w, . . . , wM) ≈
m=
pn(wm | wm−, . . . , wm−n+).
The log probability under an n-gram language model can be modeled in a WFSA. First
consider a unigram language model. We need only a single state q, with transition scores
δ(q, ω, q) = log p(ω). The initial and ﬁnal scores can be set to zero. Then the path score
for w, w, . . . , wM is equal to,
δ(q, wm, q) +  =
log p(wm).
For an n-gram language model with n > , we need probabilities that condition on
the past history. For example, in a bigram language model, the transition weights must
represent log p(wm | wm−). The transition scoring function must somehow “remember”
the previous word or words. This can be done by adding more states: to model the bigram
probability p(wm | wm−), we need a state for every possible wm− — a total of V states.
The construction indexes each state qi by a context event wm− = i. The weights are then
assigned as follows:
δ(qi, ω, qj) =
log Pr(wm = j | wm− = i),
ω = j
ω ̸= j
λ(qi) = log Pr(w = i | w = □)
ρ(qi) = log Pr(wM+ = ■ | wM = i).
The transition function is designed to ensure that the context is recorded accurately:
we can move to state j on input ω only if ω = j; otherwise, transitioning to state j is
forbidden by the weight of −∞. The initial weight function λ(qi) is the log probability of
receiving i as the ﬁrst token, and the ﬁnal weight function ρ(qi) is the log probability of
receiving an “end-of-string” token after observing wM = i.
*Semiring weighted ﬁnite state acceptors
The n-gram language model WFSA is deterministic: each input has exactly one accepting
path, for which the WFSA computes a score. In non-deterministic WFSAs, a given input
probabilities, so we want the path with the maximum score, which can be accomplished by making each local
score into a negative log-probability.
Jacob Eisenstein. Draft of November , .

.. REGULAR LANGUAGES
may have multiple accepting paths. In some applications, the score for the input is ag-
gregated across all such paths. Such aggregate scores can be computed by generalizing
WFSAs with semiring notation, ﬁrst introduced in § ...
Let d(π) represent the total score for path π = t, t, . . . , tN, which is computed as,
d(π) = λ(from-state(t)) ⊗ δ(t) ⊗ δ(t) ⊗ . . . ⊗ δ(tN) ⊗ ρ(to-state(tN)).
This is a generalization of Equation . to semiring notation, using the semiring multipli-
cation operator ⊗ in place of addition.
Now let s(ω) represent the total score for all paths Π(ω) that consume input ω,
π∈Π(ω)
d(π).
s(ω) =
Here, semiring addition (⊕) is used to combine the scores of multiple paths.
The generalization to semirings covers a number of useful special cases. In the log-
probability semiring, multiplication is deﬁned as log p(x) ⊗ log p(y) = log p(x) + log p(y),
and addition is deﬁned as log p(x) ⊕ log p(y) = log(p(x) + p(y)). Thus, s(ω) represents
the log-probability of accepting input ω, marginalizing over all paths π ∈ Π(ω). In the
boolean semiring, the ⊗ operator is logical conjunction, and the ⊕ operator is logical
disjunction. This reduces to the special case of unweighted ﬁnite state acceptors, where
the score s(ω) is a boolean indicating whether there exists any accepting path for ω. In
the tropical semiring, the ⊕ operator is a maximum, so the resulting score is the score of
the best-scoring path through the WFSA. The OPENFST toolkit uses semirings and poly-
morphism to implement general algorithms for weighted ﬁnite state automata (Allauzen
et al., ).
*Interpolated n-gram language models
Recall from § .. that an interpolated n-gram language model combines the probabili-
ties from multiple n-gram models. For example, an interpolated bigram language model
computes the probability,
ˆp(wm | wm−) = λp(wm) + λp(wm | wm−),
with ˆp indicating the interpolated probability, p indicating the bigram probability, and
p indicating the unigram probability. Setting λ = ( − λ) ensures that the probabilities
sum to one.
Interpolated bigram language models can be implemented using a non-deterministic
WFSA (Knight and May, ). The basic idea is shown in Figure .. In an interpolated
bigram language model, there is one state for each element in the vocabulary — in this
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
b : λp(b | a)
a : λp(a | a)
ϵ : λ
ϵ : λ
qA
qU
start
qB
a : p(a)
b : p(b)
b : λp(b | b)
a : λp(a | b)
Figure .: WFSA implementing an interpolated bigram/unigram language model, on
the alphabet Σ = {a, b}. For simplicity, the WFSA is contrained to force the ﬁrst token to
be generated from the unigram model, and does not model the emission of the end-of-
sequence token.
case, the states qA and qB — which are capture the contextual conditioning in the bigram
probabilities. To model unigram probabilities, there is an additional state qU, which “for-
gets” the context. Transitions out of qU involve unigram probabilities, p(a) and p(b);
transitions into qU emit the empty symbol ϵ, and have probability λ, reﬂecting the inter-
polation weight for the unigram model. The interpolation weight for the bigram model is
included in the weight of the transition qA → qB.
The epsilon transitions into qU make this WFSA non-deterministic. Consider the score
for the sequence (a, b, b). The initial state is qU, so the symbol a is generated with score
p(a) Next, we can generate b from the unigram model by taking the transition qA → qB,
with score λp(b | a). Alternatively, we can take a transition back to qU with score λ,
and then emit b from the unigram model with score p(b). To generate the ﬁnal b token,
we face the same choice: emit it directly from the self-transition to qB, or transition to qU
ﬁrst.
The total score for the sequence (a, b, b) is the semiring sum over all accepting paths,
s(a, b, b) =
p(a) ⊗ λp(b | a) ⊗ λp(b | b)
p(a) ⊗ λ ⊗ p(b) ⊗ λp(b | b)
p(a) ⊗ λp(b | a) ⊗ p(b) ⊗ p(b)
p(a) ⊗ λ ⊗ p(b) ⊗ p(b) ⊗ p(b)
Each line in Equation . represents the probability of a speciﬁc path through the WFSA.
In the probability semiring, ⊗ is multiplication, so that each path is the product of each
We could model the sequence-initial bigram probability p(a | □), but for simplicity the WFSA does not
admit this possibility, which would require another state.
Jacob Eisenstein. Draft of November , .

.. REGULAR LANGUAGES
transition weight, which are themselves probabilities. The ⊕ operator is addition, so that
the total score is the sum of the scores (probabilities) for each path. This corresponds to
the probability under the interpolated bigram language model.
Finite state transducers
Finite state acceptors can determine whether a string is in a regular language, and weighted
ﬁnite state acceptors can compute a score for every string over a given alphabet. Finite
state transducers (FSTs) extend the formalism further, by adding an output symbol to each
transition. Formally, a ﬁnite state transducer is a tuple T = (Q, Σ, Ω, λ, ρ, δ), with Ω repre-
senting an output vocabulary and the transition function δ : Q×(Σ∪ϵ)×(Ω∪ϵ)×Q → R
mapping from states, input symbols, and output symbols to states. The remaining ele-
ments (Q, Σ, λ, ρ) are identical to their deﬁnition in weighted ﬁnite state acceptors (§ ..).
Thus, each path through the FST T transduces the input string into an output.
String edit distance
The edit distance between two strings s and t is a measure of how many operations are
required to transform one string into another. There are several ways to compute edit
distance, but one of the most popular is the Levenshtein edit distance, which counts the
minimum number of insertions, deletions, and substitutions. This can be computed by
a one-state weighted ﬁnite state transducer, in which the input and output alphabets are
identical. For simplicity, consider the alphabet Σ = Ω = {a, b}. The edit distance can be
computed by a one-state transducer with the following transitions,
δ(q, a, a, q) = δ(q, b, b, q) =
δ(q, a, b, q) = δ(q, b, a, q) =
δ(q, a, ϵ, q) = δ(q, b, ϵ, q) =
δ(q, ϵ, a, q) = δ(q, ϵ, b, q) = .
The state diagram is shown in Figure ..
For a given string pair, there are multiple paths through the transducer: the best-
scoring path from dessert to desert involves a single deletion, for a total score of ; the
worst-scoring path involves seven deletions and six additions, for a score of .
The Porter stemmer
The Porter () stemming algorithm is a “lexicon-free” algorithm for stripping sufﬁxes
from English words, using a sequence of character-level rules. Each rule can be described
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
a/a, b/b :
a/ϵ, b/ϵ :
start
ϵ/a, ϵ/b :
a/b, b/a :
Figure .: State diagram for the Levenshtein edit distance ﬁnite state transducer. The
label x/y : c indicates a cost of c for a transition with input x and output y.
by an unweighted ﬁnite state transducer. The ﬁrst rule is:
-sses → -ss
e.g., dresses → dress
-ies → -i
e.g., parties → parti
-ss → -ss
e.g., dress → dress
-s → ϵ
e.g., cats → cat
The ﬁnal two lines appear to conﬂict; they are meant to be interpreted as an instruction
to remove a terminal -s unless it is part of an -ss ending. A state diagram to handle just
these ﬁnal two lines is shown in Figure .. Make sure you understand how this ﬁnite
state transducer handles cats, steps, bass, and basses.
Inﬂectional morphology
In inﬂectional morphology, word lemmas are modiﬁed to add grammatical information
such as tense, number, and case. For example, many English nouns are pluralized by the
sufﬁx -s, and many verbs are converted to past tense by the sufﬁx -ed. English’s inﬂectional
morphology is considerably simpler than many of the world’s languages. For example,
Romance languages (derived from Latin) feature complex systems of verb sufﬁxes which
must agree with the person and number of the verb, as shown in Table ..
The task of morphological analysis is to read a form like canto, and output an analysis
like CANTAR+VERB+PRESIND+P+SING, where +PRESIND describes the tense as present
indicative, +P indicates the ﬁrst-person, and +SING indicates the singular number. The
task of morphological generation is the reverse, going from CANTAR+VERB+PRESIND+P+SING
to canto. Finite state transducers are an attractive solution, because they can solve both
problems with a single model (Beesley and Karttunen, ). As an example, Figure .
shows a fragment of a ﬁnite state transducer for Spanish inﬂectional morphology. The
Jacob Eisenstein. Draft of November , .

.. REGULAR LANGUAGES
¬s/¬s
s/ϵ
start
ϵ/a
a/s
ϵ/b
b/s
. . .
Figure .: State diagram for ﬁnal two lines of step a of the Porter stemming diagram.
States q and q “remember” the observations a and b respectively; the ellipsis . . . repre-
sents additional states for each symbol in the input alphabet. The notation ¬s/¬s is not
part of the FST formalism; it is a shorthand to indicate a set of self-transition arcs for every
input/output symbol except s.
inﬁnitive
cantar (to sing)
comer (to eat)
vivir (to live)
yo (st singular)
canto
como
vivo
tu (nd singular)
cantas
comes
vives
´el, ella, usted (rd singular)
canta
come
vive
nosotros (st plural)
cantamos
comemos
vivimos
vosotros (nd plural, informal)
cant´ais
com´eis
viv´ıs
ellos, ellas (rd plural);
ustedes (nd plural)
cantan
comen
viven
Table .: Spanish verb inﬂections for the present indicative tense. Each row represents
a person and number, and each column is a regular example from a class of verbs, as
indicated by the ending of the inﬁnitive form.
input vocabulary Σ corresponds to the set of letters used in Spanish spelling, and the out-
put vocabulary Ω corresponds to these same letters, plus the vocabulary of morphological
features (e.g., +SING, +VERB). In Figure ., there are two paths that take canto as input,
corresponding to the verb and noun meanings; the choice between these paths could be
guided by a part-of-speech tagger. By inversion, the inputs and outputs for each tran-
sition are switched, resulting in a ﬁnite state generator, capable of producing the correct
surface form for any morphological analysis.
Finite state morphological analyzers and other unweighted transducers can be de-
signed by hand. The designer’s goal is to avoid overgeneration — accepting strings or
making transductions that are not valid in the language — as well as undergeneration
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
ϵ/+Noun
ϵ/+Masc
ϵ/+Sing
o/o
c/c
a/a
n/n
t/t
ϵ/a
ϵ/r
ϵ/+Verb
o/+PresInd
ϵ/+p
ϵ/+Sing
start
a/+PresInd
ϵ/+p
ϵ/+Sing
Figure .: Fragment of a ﬁnite state transducer for Spanish morphology. There are two
accepting paths for the input canto: canto+NOUN+MASC+SING (masculine singular noun,
meaning a song), and cantar+VERB+PRESIND+P+SING (I sing). There is also an accept-
ing path for canta, with output cantar+VERB+PRESIND+P+SING (he/she sings).
— failing to accept strings or transductions that are valid. For example, a pluralization
transducer that does not accept foot/feet would undergenerate. Suppose we “ﬁx” the trans-
ducer to accept this example, but as a side effect, it now accepts boot/beet; the transducer
would then be said to overgenerate. If a transducer accepts foot/foots but not foot/feet, then
it simultaneously overgenerates and undergenerates.
Finite state composition
Designing ﬁnite state transducers to capture the full range of morphological phenomena
in any real language is a huge task. Modularization is a classic computer science approach
for this situation: decompose a large and unwieldly problem into a set of subproblems,
each of which will hopefully have a concise solution. Finite state automata can be mod-
ularized through composition: feeding the output of one transducer T as the input to
another transducer T, written T◦T. Formally, if there exists some y such that (x, y) ∈ T
(meaning that T produces output y on input x), and (y, z) ∈ T, then (x, z) ∈ (T ◦ T).
Because ﬁnite state transducers are closed under composition, there is guaranteed to be
a single ﬁnite state transducer that T = T ◦ T, which can be constructed as a machine
with one state for each pair of states in T and T (Mohri et al., ).
Example: Morphology and orthography
In English morphology, the sufﬁx -ed is added
to signal the past tense for many verbs: cook→cooked, want→wanted, etc. However, English
orthography dictates that this process cannot produce a spelling with consecutive e’s, so
that bake→baked, not bakeed. A modular solution is to build separate transducers for mor-
phology and orthography. The morphological transducer TM transduces from bake+PAST
to bake+ed, with the + symbol indicating a segment boundary. The input alphabet of TM
includes the lexicon of words and the set of morphological features; the output alphabet
includes the characters a-z and the + boundary marker. Next, an orthographic transducer
TO is responsible for the transductions cook+ed → cooked, and bake+ed → baked. The input
alphabet of TO must be the same as the output alphabet for TM, and the output alphabet
Jacob Eisenstein. Draft of November , .

.. REGULAR LANGUAGES
is simply the characters a-z. The composed transducer (TO ◦ TM) then transduces from
bake+PAST to the spelling baked. The design of TO is left as an exercise.
Example: Hidden Markov models
Hidden Markov models (chapter ) can be viewed as
weighted ﬁnite state transducers, and they can be constructed by transduction. Recall that
a hidden Markov model deﬁnes a joint probability over words and tags, p(w, y), which
can be computed as a path through a trellis structure. This trellis is itself a weighted ﬁnite
state acceptor, with edges between all adjacent nodes qm−,i → qm,j on input Ym = j. The
edge weights are log-probabilities,
δ(qm−,i, Ym = j, qm,j) = log p(wm, Ym = j | Ym−i = j)
= log p(wm | Ym = j) + log Pr(Ym = j | Ym− = i).
Because there is only one possible transition for each tag Ym, this WFSA is deterministic.
The score for any tag sequence {ym}M
m= is the sum of these log-probabilities, correspond-
ing to the total log probability log p(w, y). Furthermore, the trellis can be constructed by
the composition of simpler FSTs.
First, construct a “transition” transducer to represent a bigram probability model
over tag sequences, TT . This transducer is almost identical to the n-gram language
model acceptor in § ..: there is one state for each tag, and the edge weights equal
to the transition log-probabilities, δ(qi, j, j, qj) = log Pr(Ym = j | Ym− = i). Note
that TT is a transducer, with identical input and output at each arc; this makes it
possible to compose TT with other transducers.
Next, construct an “emission” transducer to represent the probability of words given
tags, TE. This transducer has only a single state, with arcs for each word/tag pair,
δ(q, i, j, q) = log Pr(Wm = j | Ym = i). The input vocabulary is the set of all tags,
and the output vocabulary is the set of all words.
The composition TE ◦ TT is a ﬁnite state transducer with one state per tag, as shown
in Figure .. Each state has V × K outgoing edges, representing transitions to each
of the K other states, with outputs for each of the V words in the vocabulary. The
weights for these edges are equal to,
δ(qi, Ym = j, wm, qj) = log p(wm, Ym = j | Ym− = i).
The trellis is a structure with M ×K nodes, for each of the M words to be tagged and
each of the K tags in the tagset. It can be built by composition of (TE ◦TT ) against an
unweighted chain FSA MA(w) that is specially constructed to accept only a given
input w, w, . . . , wM, shown in Figure .. The trellis for input w is built from the
composition MA(w) ◦ (TE ◦ TT ). Composing with the unweighted MA(w) does not
affect the edge weights from (TE ◦TT ), but it selects the subset of paths that generate
the word sequence w.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
N/aardvark
N/abacus
N/. . .
end
start
start
V/. . .
V/abacus
V/aardvark
Figure .: Finite state transducer for hidden Markov models, with a small tagset of nouns
and verbs. For each pair of tags (including self-loops), there is an edge for every word in
the vocabulary. For simplicity, input and output are only shown for the edges from the
start state. Weights are also omitted from the diagram; for each edge from qi to qj, the
weight is equal to log p(wm, Ym = j | Ym− = i), except for edges to the end state, which
are equal to log Pr(Ym = ♦ | Ym− = i).
They
can
ﬁsh
start
Figure .: Chain ﬁnite state acceptor for the input They can ﬁsh.
*Learning weighted ﬁnite state automata
In generative models such as n-gram language models and hidden Markov models, the
edge weights correspond to log probabilities, which can be obtained from relative fre-
quency estimation. However, in other cases, we wish to learn the edge weights from in-
put/output pairs. This is difﬁcult in non-deterministic ﬁnite state automata, because we
do not observe the speciﬁc arcs that are traversed in accepting the input, or in transducing
from input to output. The path through the automaton is a latent variable.
Chapter  presented one method for learning with latent variables: expectation max-
imization (EM). This involves computing a distribution q() over the latent variable, and
iterating between updates to this distribution and updates to the parameters — in this
case, the arc weights. The forward-backward algorithm (§ ..) describes a dynamic
program for computing a distribution over arcs in the trellis structure of a hidden Markov
Jacob Eisenstein. Draft of November , .

.. CONTEXT-FREE LANGUAGES
model, but this is a special case of the more general problem for ﬁnite state automata.
Eisner () describes an expectation semiring, which enables the expected number of
transitions across each arc to be computed through a semiring shortest-path algorithm.
Alternative approaches for generative models include Markov Chain Monte Carlo (Chi-
ang et al., ) and spectral learning (Balle et al., ).
Further aﬁeld, we can take a perceptron-style approach, with each arc corresponding
to a feature. The classic perceptron update would update the weights by subtracting the
difference between the feature vector corresponding to the predicted path and the feature
vector corresponding to the correct path. Since the path is not observed, we resort to a
latent variable perceptron. The model is described formally in § ., but the basic idea
is to compute an update from the difference between the features from the predicted path
and the features for the best-scoring path that generates the correct output.
Context-free languages
Beyond the class of regular languages lie the context-free languages. An example of a
language that is context-free but not ﬁnite state is the set of arithmetic expressions with
balanced parentheses. Intuitively, to accept only strings in this language, an FSA would
have to “count” the number of left parentheses, and make sure that they are balanced
against the number of right parentheses. An arithmetic expression can be arbitrarily long,
yet by deﬁnition an FSA has a ﬁnite number of states. Thus, for any FSA, there will be
a string with too many parentheses to count. More formally, the pumping lemma is a
proof technique for showing that languages are not regular. It is typically demonstrated
for the simpler case anbn, the language of strings containing a sequence of a’s, and then
an equal-length sequence of b’s.
There are at least two arguments for the relevance of non-regular formal languages
to linguistics. First, there are natural language phenomena that are argued to be iso-
morphic to anbn. For English, the classic example is center embedding, shown in Fig-
ure .. The initial expression the dog speciﬁes a single dog. Embedding this expression
into the cat
chased speciﬁes a particular cat — the one chased by the dog. This cat can
then be embedded again to specify a goat, in the less felicitous but arguably grammatical
expression, the goat the cat the dog chased kissed, which refers to the goat who was kissed
by the cat which was chased by the dog. Chomsky () argues that to be grammatical,
a center-embedded construction must be balanced: if it contains n noun phrases (e.g., the
cat), they must be followed by exactly n −  verbs. An FSA that could recognize such ex-
pressions would also be capable of recognizing the language anbn. Because we can prove
that no FSA exists for anbn, no FSA can exist for center embedded constructions either. En-
Details of the proof can be found in an introductory computer science theory textbook (e.g., Sipser, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
the dog
the cat
the dog
chased
the goat
the cat
the dog
chased
kissed
Figure .: Three levels of center embedding
glish includes center embedding, and so the argument goes, English grammar as a whole
cannot be regular.
A more practical argument for moving beyond regular languages is modularity. Many
linguistic phenomena — especially in syntax — involve constraints that apply at long
distance. Consider the problem of determiner-noun number agreement in English: we
can say the coffee and these coffees, but not *these coffee. By itself, this is easy enough to model
in an FSA. However, fairly complex modifying expressions can be inserted between the
determiner and the noun:
a. the burnt coffee
b. the badly-ground coffee
c. the burnt and badly-ground Italian coffee
d. these burnt and badly-ground Italian coffees
e.
* these burnt and badly-ground Italian coffee
Again, an FSA can be designed to accept modifying expressions such as burnt and badly-
ground Italian. Let’s call this FSA FM. To reject the ﬁnal example, a ﬁnite state acceptor
must somehow “remember” that the determiner was plural when it reaches the noun cof-
fee at the end of the expression. The only way to do this is to make two identical copies
of FM: one for singular determiners, and one for plurals. While this is possible in the
ﬁnite state framework, it is inconvenient — especially in languages where more than one
attribute of the noun is marked by the determiner. Context-free languages facilitate mod-
ularity across such long-range dependencies.
Context-free grammars
Context-free languages are speciﬁed by context-free grammars (CFGs), which are tuples
(N, Σ, R, S) consisting of:
The claim that arbitrarily deep center-embedded expressions are grammatical has drawn skepticism.
Corpus evidence shows that embeddings of depth greater than two are exceedingly rare (Karlsson, ),
and that embeddings of depth greater than three are completely unattested. If center-embedding is capped
at some ﬁnite depth, then it is regular.
Jacob Eisenstein. Draft of November , .

.. CONTEXT-FREE LANGUAGES
S →S OP S | NUM
OP →+ | − | × | ÷
NUM →NUM DIGIT | DIGIT
DIGIT → |  |  | . . . |
Figure .: A context-free grammar for arithmetic expressions
a ﬁnite set of non-terminals N;
a ﬁnite alphabet Σ of terminal symbols;
a set of production rules R, each of the form A → β, where A ∈ N and β ∈ (Σ∪N)∗;
a designated start symbol S.
In the production rule A → β, the left-hand side (LHS) A must be a non-terminal;
the right-hand side (RHS) can be a sequence of terminals or non-terminals, {n, σ}∗, n ∈
N, σ ∈ Σ. A non-terminal can appear on the left-hand side of many production rules.
A non-terminal can appear on both the left-hand side and the right-hand side; this is a
recursive production, and is analogous to self-loops in ﬁnite state automata. The name
“context-free” is based on the property that the production rule depends only on the LHS,
and not on its ancestors or neighbors; this is analogous to Markov property of ﬁnite state
automata, in which the behavior at each step depends only on the current state, and not
on the path by which that state was reached.
A derivation τ is a sequence of steps from the start symbol S to a surface string w ∈ Σ∗,
which is the yield of the derivation. A string w is in a context-free language if there is
some derivation from S yielding w. Parsing is the problem of ﬁnding a derivation for a
string in a grammar. Algorithms for parsing are described in chapter .
Like regular expressions, context-free grammars deﬁne the language but not the com-
putation necessary to recognize it. The context-free analogues to ﬁnite state acceptors are
pushdown automata, a theoretical model of computation in which input symbols can be
pushed onto a stack with potentially inﬁnite depth. For more details, see Sipser ().
Example
Figure . shows a context-free grammar for arithmetic expressions such as  +  ÷  − .
In this grammar, the terminal symbols include the digits {, , ..., } and the op-
erators {+, −, ×, ÷}. The rules include the | symbol, a notational convenience that makes
it possible to specify multiple right-hand sides on a single line: the statement A → x | y
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
Num
Op
Op
Num
Digit
Num
Op
Op
Digit
Num
Digit
Num
Num
Num
Digit
Digit
Digit
Digit
Figure .: Some example derivations from the arithmetic grammar in Figure .
deﬁnes two productions, A → x and A → y. This grammar is recursive: the non-termals S
and NUM can produce themselves.
Derivations are typically shown as trees, with production rules applied from the top
to the bottom. The tree on the left in Figure . describes the derivation of a single digit,
through the sequence of productions S → NUM → DIGIT →  (these are all unary pro-
ductions, because the right-hand side contains a single element). The other two trees in
Figure . show alternative derivations of the string  +  − . The existence of multiple
derivations for a string indicates that the grammar is ambiguous.
Context-free derivations can also be written out according to the pre-order tree traver-
sal. For the two derivations of  +  -  in Figure ., the notation is:
(S (S (S (Num (Digit ))) (Op +) (S (Num (Digit )))) (Op - ) (S (Num (Digit ))))
(S (S (Num (Digit ))) (Op +) (S (Num (Digit )) (Op - ) (S (Num (Digit ))))).
Grammar equivalence and Chomsky Normal Form
A single context-free language can be expressed by more than one context-free grammar.
For example, the following two grammars both deﬁne the language anbn for n > .
S →aSb | ab
S →aSb | aabb | ab
Two grammars are weakly equivalent if they generate the same strings. Two grammars
are strongly equivalent if they generate the same strings via the same derivations. The
grammars above are only weakly equivalent.
This is a depth-ﬁrst left-to-right search that prints each node the ﬁrst time it is encountered (Cormen
et al., , chapter ).
Jacob Eisenstein. Draft of November , .

.. CONTEXT-FREE LANGUAGES
In Chomsky Normal Form (CNF), the right-hand side of every production includes
either two non-terminals, or a single terminal symbol:
A →BC
A →a
All CFGs can be converted into a CNF grammar that is weakly equivalent. To convert a
grammar into CNF, we ﬁrst address productions that have more than two non-terminals
on the RHS by creating new “dummy” non-terminals. For example, if we have the pro-
duction,
W → X Y Z,
it is replaced with two productions,
W →X W\X
W\X →Y Z.
In these productions, W\X is a new dummy non-terminal. This transformation binarizes
the grammar, which is critical for efﬁcient bottom-up parsing, as we will see in chapter .
Productions whose right-hand side contains a mix of terminal and non-terminal symbols
can be replaced in a similar fashion.
Unary non-terminal productions A → B are replaced as follows: for each production
B → α in the grammar, add a new production A → α. For example, in the grammar
described in Figure ., we would replace NUM → DIGIT with NUM →  |  | . . . | .
However, we keep the production NUM → NUM DIGIT, which is a valid binary produc-
tion.
Natural language syntax as a context-free language
Context-free grammars can be used to represent syntax, which is the set of rules that
determine whether an utterance is judged to be grammatical. If this representation were
perfectly faithful, then a natural language such as English could be transformed into a
formal language, consisting of exactly the (inﬁnite) set of strings that would be judged to
be grammatical by a ﬂuent English speaker. We could then build parsing software that
would automatically determine if a given utterance were grammatical.
Contemporary theories generally do not consider natural languages to be context-free
(see § .), yet context-free grammars are widely used in natural language parsing. The
reason is that context-free representations strike a good balance: they cover a broad range
of syntactic phenomena, and they can be parsed efﬁciently. This section therefore de-
scribes how to handle a core fragment of English syntax in context-free form, following
To move beyond this cursory treatment of syntax, consult the short introductory manuscript by Bender
(), or the longer text by Akmajian et al. ().
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
the conventions of the Penn Treebank (PTB; Marcus et al., ), a large-scale annotation
of English language syntax. The generalization to “mildly” context-sensitive languages is
discussed in § ..
The Penn Treebank annotation is a phrase-structure grammar of English. This means
that sentences are broken down into constituents, which are contiguous sequences of
words that function as coherent units for the purpose of linguistic analysis. Constituents
generally have a few key properties:
Movement. Constituents can often be moved around sentences as units.
a. Abigail gave (her brother) (a ﬁsh).
b. Abigail gave (a ﬁsh) to (her brother).
In contrast, gave her and brother a cannot easily be moved while preserving gram-
maticality.
Substitution. Constituents can be substituted by other phrases of the same type.
a. Max thanked (his older sister).
b. Max thanked (her).
In contrast, substitution is not possible for other contiguous units like Max thanked
and thanked his.
Coordination. Coordinators like and and or can conjoin constituents.
a. (Abigail) and (her younger brother) bought a ﬁsh.
b. Abigail (bought a ﬁsh) and (gave it to Max).
c. Abigail (bought) and (greedily ate) a ﬁsh.
Units like brother bought and bought a cannot easily be coordinated.
These examples argue for units such as her brother and bought a ﬁsh to be treated as con-
stituents. Other sequences of words in these examples, such as Abigail gave and brother
a ﬁsh, cannot be moved, substituted, and coordinated in these ways. In phrase-structure
grammar, constituents are nested, so that the senator from New Jersey contains the con-
stituent from New Jersey, which in turn contains New Jersey. The sentence itself is the max-
imal constituent; each word is a minimal constituent, derived from a unary production
from a part-of-speech tag. Between part-of-speech tags and sentences are phrases. In
phrase-structure grammar, phrases have a type that is usually determined by their head
word: for example, a noun phrase corresponds to a noun and the group of words that
Jacob Eisenstein. Draft of November , .

.. CONTEXT-FREE LANGUAGES
modify it, such as her younger brother; a verb phrase includes the verb and its modiﬁers,
such as bought a ﬁsh and greedily ate it.
In context-free grammars, each phrase type is a non-terminal, and each constituent is
the substring that the non-terminal yields. Grammar design involves choosing the right
set of non-terminals. Fine-grained non-terminals make it possible to represent more ﬁne-
grained linguistic phenomena. For example, by distinguishing singular and plural noun
phrases, it is possible to have a grammar of English that generates only sentences that
obey subject-verb agreement. However, enforcing subject-verb agreement is considerably
more complicated in languages like Spanish, where the verb must agree in both person
and number with subject. In general, grammar designers must trade off between over-
generation — a grammar that permits ungrammatical sentences — and undergeneration
— a grammar that fails to generate grammatical sentences. Furthermore, if the grammar is
to support manual annotation of syntactic structure, it must be simple enough to annotate
efﬁciently.
A phrase-structure grammar for English
To better understand how phrase-structure grammar works, let’s consider the speciﬁc
case of the Penn Treebank grammar of English. The main phrase categories in the Penn
Treebank (PTB) are based on the main part-of-speech classes: noun phrase (NP), verb
phrase (VP), prepositional phrase (PP), adjectival phrase (ADJP), and adverbial phrase
(ADVP). The top-level category is S, which conveniently stands in for both “sentence”
and the “start” symbol. Complement clauses (e.g., I take the good old fashioned ground that
the whale is a ﬁsh) are represented by the non-terminal SBAR. The terminal symbols in
the grammar are individual words, which are generated from unary productions from
part-of-speech tags (the PTB tagset is described in § .).
This section describes some of the most common productions from the major phrase-
level categories, explaining how to generate individual tag sequences. The production
rules are approached in a “theory-driven” manner: ﬁrst the syntactic properties of each
phrase type are described, and then some of the necessary production rules are listed. But
it is important to keep in mind that the Penn Treebank was produced in a “data-driven”
manner. After the set of non-terminals was speciﬁed, annotators were free to analyze each
sentence in whatever way seemed most linguistically accurate, subject to some high-level
guidelines. The grammar of the Penn Treebank is simply the set of productions that were
required to analyze the several million words of the corpus. By design, the grammar
overgenerates — it does not exclude ungrammatical sentences. Furthermore, while the
productions shown here cover some of the most common cases, they are only a small
fraction of the several thousand different types of productions in the Penn Treebank.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
Sentences
The most common production rule for sentences is,
S →NP VP
which accounts for simple sentences like Abigail ate the kimchi — as we will see, the direct
object the kimchi is part of the verb phrase. But there are more complex forms of sentences
as well:
S →ADVP NP VP
Unfortunately Abigail ate the kimchi.
S →S CC S
Abigail ate the kimchi and Max had a burger.
S →VP
Eat the kimchi.
where ADVP is an adverbial phrase (e.g., unfortunately, very unfortunately) and CC is a
coordinating conjunction (e.g., and, but).
Noun phrases
Noun phrases refer to entities, real or imaginary, physical or abstract: Asha, the steamed
dumpling, parts and labor, nobody, the whiteness of the whale, and the rise of revolutionary syn-
dicalism in the early twentieth century. Noun phrase productions include “bare” nouns,
which may optionally follow determiners, as well as pronouns:
NP →NN | NNS | NNP | PRP
NP →DET NN | DET NNS | DET NNP
The tags NN, NNS, and NNP refer to singular, plural, and proper nouns; PRP refers to
personal pronouns, and DET refers to determiners. The grammar also contains terminal
productions from each of these tags, e.g., PRP → I | you | we | . . . .
Noun phrases may be modiﬁed by adjectival phrases (ADJP; e.g., the small Russian dog)
and numbers (CD; e.g., the ﬁve pastries), each of which may optionally follow a determiner:
NP →ADJP NN | ADJP NNS | DET ADJP NN | DET ADJP NNS
NP →CD NNS | DET CD NNS | . . .
Some noun phrases include multiple nouns, such as the liberation movement and an
antelope horn, necessitating additional productions:
NP →NN NN | NN NNS | DET NN NN | . . .
Notice that the grammar does not include the recursive production S → ADVP S. It may be helpful to
think about why this production would cause the grammar to overgenerate.
Jacob Eisenstein. Draft of November , .

.. CONTEXT-FREE LANGUAGES
These multiple noun constructions can be combined with adjectival phrases and cardinal
numbers, leading to a large number of additional productions.
Recursive noun phrase productions include coordination, prepositional phrase attach-
ment, subordinate clauses, and verb phrase adjuncts:
NP →NP CC NP
e.g., the red and the black
NP →NP PP
e.g., the President of the Georgia Institute of Technology
NP →NP SBAR
e.g., a whale which he had wounded
NP →NP VP
e.g., a whale taken near Shetland
These recursive productions are a major source of ambiguity, because the VP and PP non-
terminals can also generate NP children. Thus, the the President of the Georgia Institute of
Technology can be derived in two ways, as can a whale taken near Shetland in October.
But aside from these few recursive productions, the noun phrase fragment of the Penn
Treebank grammar is relatively ﬂat, containing a large of number of productions that go
from NP directly to a sequence of parts-of-speech. If noun phrases had more internal
structure, the grammar would need fewer rules, which, as we will see, would make pars-
ing faster and machine learning easier. Vadas and Curran () propose to add additional
structure in the form of a new non-terminal called a nominal modiﬁer (NML), e.g.,
a. (NP (NN crude) (NN oil) (NNS prices))
(PTB analysis)
b. (NP (NML (NN crude) (NN oil)) (NNS prices))
(NML-style analysis).
Another proposal is to treat the determiner as the head of a determiner phrase (DP;
Abney, ). There are linguistic arguments for and against determiner phrases (e.g.,
Van Eynde, ). From the perspective of context-free grammar, DPs enable more struc-
tured analyses of some constituents, e.g.,
a. (NP (DT the) (JJ white) (NN whale))
(PTB analysis)
b. (DP (DT the) (NP (JJ white) (NN whale)))
(DP-style analysis).
Verb phrases
Verb phrases describe actions, events, and states of being. The PTB tagset distinguishes
several classes of verb inﬂections: base form (VB; she likes to snack), present-tense third-
person singular (VBZ; she snacks), present tense but not third-person singular (VBP; they
snack), past tense (VBD; they snacked), present participle (VBG; they are snacking), and past
participle (VBN; they had snacked). Each of these forms can constitute a verb phrase on its
This tagset is speciﬁc to English: for example, VBP is a meaningful category only because English mor-
phology distinguishes third-person singular from all person-number combinations.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
own:
VP → VB | VBZ | VBD | VBN | VBG | VBP
More complex verb phrases can be formed by a number of recursive productions,
including the use of coordination, modal verbs (MD; she should snack), and the inﬁnitival
to (TO):
VP → MD VP
She will snack
VP → VBD VP
She had snacked
VP → VBZ VP
She has been snacking
VP → VBN VP
She has been snacking
VP → TO VP
She wants to snack
VP → VP CC VP
She buys and eats many snacks
Each of these productions uses recursion, with the VP non-terminal appearing in both the
LHS and RHS. This enables the creation of complex verb phrases, such as She will have
wanted to have been snacking.
Transitive verbs take noun phrases as direct objects, and ditransitive verbs take two
direct objects:
VP → VBZ NP
She teaches algebra
VP → VBG NP
She has been teaching algebra
VP → VBD NP NP
She taught her brother algebra
These productions are not recursive, so a unique production is required for each verb
part-of-speech. They also do not distinguish transitive from intransitive verbs, so the
resulting grammar overgenerates examples like *She sleeps sushi and *She learns Boyang
algebra. Sentences can also be direct objects:
VP → VBZ S
Hunter wants to eat the kimchi
VP → VBZ SBAR
Hunter knows that Tristan ate the kimchi
The ﬁrst production overgenerates, licensing sentences like *Hunter sees Tristan eats the
kimchi. This problem could be addressed by designing a more speciﬁc set of sentence
non-terminals, indicating whether the main verb can be conjugated.
Verbs can also be modiﬁed by prepositional phrases and adverbial phrases:
VP → VBZ PP
She studies at night
VP → VBZ ADVP
She studies intensively
VP → ADVP VBG
She is not studying
Jacob Eisenstein. Draft of November , .

.. CONTEXT-FREE LANGUAGES
Again, because these productions are not recursive, the grammar must include produc-
tions for every verb part-of-speech.
A special set of verbs, known as copula, can take predicative adjectives as direct ob-
jects:
VP → VBZ ADJP
She is hungry
VP → VBP ADJP
Success seems increasingly unlikely
The PTB does not have a special non-terminal for copular verbs, so this production gen-
erates non-grammatical examples such as *She eats tall.
Particles (PRT as a phrase; RP as a part-of-speech) work to create phrasal verbs:
VP → VB PRT
She told them to fuck off
VP → VBD PRT NP
They gave up their ill-gotten gains
As the second production shows, particle productions are required for all conﬁgurations
of verb parts-of-speech and direct objects.
Other contituents
The remaining constituents require far fewer productions. Prepositional phrases almost
always consist of a preposition and a noun phrase,
PP → IN NP
the whiteness of the whale
PP → TO NP
What the white whale was to Ahab, has been hinted
Similarly, complement clauses consist of a complementizer (usually a preposition, pos-
sibly null) and a sentence,
SBAR → IN S
She said that it was spicy
SBAR → S
She said it was spicy
Adverbial phrases are usually bare adverbs (ADVP → RB), with a few exceptions:
ADVP → RB RBR
They went considerably further
ADVP → ADVP PP
They went considerably further than before
The tag RBR is a comparative adverb.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
Adjectival phrases extend beyond bare adjectives (ADJP → JJ) in a number of ways:
ADJP → RB JJ
very hungry
ADJP → RBR JJ
more hungry
ADJP → JJS JJ
best possible
ADJP → RB JJR
even bigger
ADJP → JJ CC JJ
high and mighty
ADJP → JJ JJ
West German
ADJP → RB VBN
previously reported
The tags JJR and JJS refer to comparative and superlative adjectives respectively.
All of these phrase types can be coordinated:
PP →PP CC PP
on time and under budget
ADVP →ADVP CC ADVP
now and two years ago
ADJP →ADJP CC ADJP
quaint and rather deceptive
SBAR →SBAR CC SBAR
whether they want control
or whether they want exports
Grammatical ambiguity
Context-free parsing is useful not only because it determines whether a sentence is gram-
matical, but mainly because the constituents and their relations can be applied to tasks
such as information extraction (chapter ) and sentence compression (Jing, ; Clarke
and Lapata, ). However, the ambiguity of wide-coverage natural language grammars
poses a serious problem for such potential applications. As an example, Figure . shows
two possible analyses for the simple sentence We eat sushi with chopsticks, depending on
whether the chopsticks modify eat or sushi. Realistic grammars can license thousands or
even millions of parses for individual sentences. Weighted context-free grammars solve
this problem by attaching weights to each production, and selecting the derivation with
the highest score. This is the focus of chapter .
*Mildly context-sensitive languages
Beyond context-free languages lie context-sensitive languages, in which the expansion
of a non-terminal depends on its neighbors.
In the general class of context-sensitive
languages, computation becomes much more challenging: the membership problem for
context-sensitive languages is PSPACE-complete. Since PSPACE contains the complexity
class NP (problems that can be solved in polynomial time on a non-deterministic Turing
Jacob Eisenstein. Draft of November , .

.. *MILDLY CONTEXT-SENSITIVE LANGUAGES
VP
NP
VP
NP
NP
We
VP
PP
We
NP
PP
eat
NP
NP
IN
sushi
NP
IN
chopsticks
sushi
with
eat
chopsticks
with
Figure .: Two derivations of the same sentence
machine), PSPACE-complete problems cannot be solved efﬁciently if P ̸= NP. Thus, de-
signing an efﬁcient parsing algorithm for the full class of context-sensitive languages is
probably hopeless.
However, Joshi () identiﬁes a set of properties that deﬁne mildly context-sensitive
languages, which are a strict subset of context-sensitive languages. Like context-free lan-
guages, mildly context-sensitive languages are parseable in polynomial time. However,
the mildly context-sensitive languages include non-context-free languages, such as the
“copy language” {ww | w ∈ Σ∗} and the language ambncmdn. Both are characterized by
cross-serial dependencies, linking symbols at long distance across the string. For exam-
ple, in the language anbmcndm, each a symbol is linked to exactly one c symbol, regardless
of the number of intervening b symbols.
Context-sensitive phenomena in natural language
Such phenomena are occasionally relevant to natural language. A classic example is found
in Swiss-German (Shieber, ), in which sentences such as we let the children help Hans
paint the house are realized by listing all nouns before all verbs, i.e., we the children Hans the
house let help paint. Furthermore, each noun’s determiner is dictated by the noun’s case
marking (the role it plays with respect to the verb). Using an argument that is analogous
to the earlier discussion of center-embedding (§ .), Shieber describes these case marking
constraints as a set of cross-serial dependencies, homomorphic to ambncmdn, and therefore
not context-free.
If PSPACE ̸= NP, then it contains problems that cannot be solved in polynomial time on a non-
deterministic Turing machine; equivalently, solutions to these problems cannot even be checked in poly-
nomial time (Arora and Barak, ).
A further condition of the set of mildly-context-sensitive languages is constant growth: if the strings in
the language are arranged by length, the gap in length between any pair of adjacent strings is bounded by
some language speciﬁc constant. This condition excludes languages such as {an | n ≥ }.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
Abigail
eats
the
kimchi
NP
(S\NP)/NP
(NP/N )
NP
S\NP
Figure .: A syntactic analysis in CCG involving forward and backward function appli-
cation
As with the move from regular to context-free languages, mildly context-sensitive
languages can also be motivated by expedience. While ﬁnite sequences of cross-serial
dependencies can in principle be handled in a context-free grammar, it is often more con-
venient to use a mildly context-sensitive formalism like tree-adjoining grammar (TAG)
and combinatory categorial grammar (CCG). TAG-inspired parsers have been shown to
be particularly effective in parsing the Penn Treebank (Collins, ; Carreras et al., ),
and CCG plays a leading role in current research on semantic parsing (Zettlemoyer and
Collins, ). These two formalisms are weakly equivalent: any language that can be
speciﬁed in TAG can also be speciﬁed in CCG, and vice versa (Joshi et al., ). The re-
mainder of the chapter gives a brief overview of CCG, but you are encouraged to consult
Joshi and Schabes () and Steedman and Baldridge () for more detail on TAG and
CCG respectively.
Combinatory categorial grammar
In combinatory categorial grammar, structural analyses are built up through a small set
of generic combinatorial operations, which apply to immediately adjacent sub-structures.
These operations act on the categories of the sub-structures, producing a new structure
with a new category. The basic categories include S (sentence), NP (noun phrase), VP
(verb phrase) and N (noun). The goal is to label the entire span of text as a sentence, S.
Complex categories, or types, are constructed from the basic categories, parentheses,
and forward and backward slashes: for example, S/NP is a complex type, indicating a
sentence that is lacking a noun phrase to its right; S\NP is a sentence lacking a noun
phrase to its left. Complex types act as functions, and the most basic combinatory oper-
ations are function application to either the right or left neighbor. For example, the type
of a verb phrase, such as eats, would be S\NP. Applying this function to a subject noun
phrase to its left results in an analysis of Abigail eats as category S, indicating a successful
parse.
Transitive verbs must ﬁrst be applied to the direct object, which in English appears to
the right of the verb, before the subject, which appears on the left. They therefore have the
more complex type (S\NP)/NP. Similarly, the application of a determiner to the noun at
Jacob Eisenstein. Draft of November , .

.. *MILDLY CONTEXT-SENSITIVE LANGUAGES
Abigail
might
learn
Swahili
NP
(S\NP)/VP
VP/NP
NP
>B
(S\NP)/NP
S\NP
Figure .: A syntactic analysis in CCG involving function composition (example modi-
ﬁed from Steedman and Baldridge, )
its right results in a noun phrase, so determiners have the type NP/N. Figure . pro-
vides an example involving a transitive verb and a determiner. A key point from this
example is that it can be trivially transformed into phrase-structure tree, by treating each
function application as a constituent phrase. Indeed, when CCG’s only combinatory op-
erators are forward and backward function application, it is equivalent to context-free
grammar. However, the location of the “effort” has changed. Rather than designing good
productions, the grammar designer must focus on the lexicon — choosing the right cate-
gories for each word. This makes it possible to parse a wide range of sentences using only
a few generic combinatory operators.
Things become more interesting with the introduction of two additional operators:
composition and type-raising. Function composition enables the combination of com-
plex types: X/Y ◦ Y/Z ⇒B X/Z (forward composition) and Y \Z ◦ X\Y ⇒B X\Z (back-
ward composition). Composition makes it possible to “look inside” complex types, and
combine two adjacent units if the “input” for one is the “output” for the other. Figure .
shows how function composition can be used to handle modal verbs. While this sen-
tence can be parsed using only function application, the composition-based analysis is
preferable because the unit might learn functions just like a transitive verb, as in the exam-
ple Abigail studies Swahili. This in turn makes it possible to analyze conjunctions such as
Abigail studies and might learn Swahili, attaching the direct object Swahili to the entire con-
joined verb phrase studies and might learn. The Penn Treebank grammar fragment from
§ .. would be unable to handle this case correctly: the direct object Swahili could attach
only to the second verb learn.
Type raising converts an element of type X to a more complex type: X ⇒T T/(T\X)
(forward type-raising to type T), and X ⇒T T\(T/X) (backward type-raising to type
T). Type-raising makes it possible to reverse the relationship between a function and its
argument — by transforming the argument into a function over functions over arguments!
An example may help. Figure . shows how to analyze an object relative clause, a story
that Abigail tells. The problem is that tells is a transitive verb, expecting a direct object to
its right. As a result, Abigail tells is not a valid constituent. The issue is resolved by raising
The subscript B follows notation from Curry and Feys ().
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
a story
that
Abigail
tells
NP
(NP\NP)/(S/NP)
NP
(S\NP)/NP
>T
S/(S\NP)
>B
S/NP
NP\NP
NP
Figure .: A syntactic analysis in CCG involving an object relative clause
Abigail from NP to the complex type (S/NP)\NP). This function can then be combined
with the transitive verb tells by forward composition, resulting in the type (S/NP), which
is a sentence lacking a direct object to its right. From here, we need only design the
lexical entry for the complementizer that to expect a right neighbor of type (S/NP), and
the remainder of the derivation can proceed by function application.
Composition and type-raising give CCG considerable power and ﬂexibility, but at a
price. The simple sentence Abigail tells Max can be parsed in two different ways: by func-
tion application (ﬁrst forming the verb phrase tells Max), and by type-raising and compo-
sition (ﬁrst forming the non-constituent Abigail tells). This derivational ambiguity does
not affect the resulting linguistic analysis, so it is sometimes known as spurious ambi-
guity. Hockenmaier and Steedman () present a translation algorithm for converting
the Penn Treebank into CCG derivations, using composition and type-raising only when
necessary.
Exercises
. Sketch out the state diagram for ﬁnite-state acceptors for the following languages
on the alphabet {a, b}.
a) Even-length strings. (Be sure to include  as an even number.)
b) Strings that contain aaa as a substring.
c) Strings containing an even number of a and an odd number of b symbols.
d) Strings in which the substring bbb must be terminal if it appears — the string
need not contain bbb, but if it does, nothing can come after it.
. Levenshtein edit distance is the number of insertions, substitutions, or deletions
required to convert one string to another.
The missing direct object would be analyzed as a trace in CFG-like approaches to syntax, including the
Penn Treebank.
Jacob Eisenstein. Draft of November , .

.. *MILDLY CONTEXT-SENSITIVE LANGUAGES
a) Deﬁne a ﬁnite-state acceptor that accepts all strings with edit distance  from
the target string, target.
b) Now think about how to generalize your design to accept all strings with edit
distance from the target string equal to d. If the target string has length ℓ, what
is the minimal number of states required?
. Construct an FSA in the style of Figure ., which handles the following examples:
nation/N, national/ADJ, nationalize/V, nationalizer/N
America/N, American/ADJ, Americanize/V, Americanizer/N
Be sure that your FSA does not accept any further derivations, such as *nationalizeral
and *Americanizern.
. Show how to construct a trigram language model in a weighted ﬁnite-state acceptor.
Make sure that you handle the edge cases at the beginning and end of the input.
. Extend the FST in Figure . to handle the other two parts of rule a of the Porter
stemmer: -sses → ss, and -ies → -i.
. § .. describes TO, a transducer that captures English orthography by transduc-
ing cook + ed → cooked and bake + ed → baked. Design an unweighted ﬁnite-state
transducer that captures this property of English orthography.
Next, augment the transducer to appropriately model the sufﬁx -s when applied to
words ending in s, e.g. kiss+s → kisses.
. Add parenthesization to the grammar in Figure . so that it is no longer ambigu-
ous.
. Construct three examples — a noun phrase, a verb phrase, and a sentence — which
can be derived from the Penn Treebank grammar fragment in § .., yet are not
grammatical. Avoid reusing examples from the text. Optionally, propose corrections
to the grammar to avoid generating these cases.
. Produce parses for the following sentences, using the Penn Treebank grammar frag-
ment from § ...
This aggression will not stand.
I can get you a toe.
Sometimes you eat the bar and sometimes the bar eats you.
Then produce parses for three short sentences from a news article from this week.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . FORMAL LANGUAGE THEORY
. * One advantage of CCG is its ﬂexibility in handling coordination:
a. Hunter and Tristan speak Hawaiian
b. Hunter speaks and Tristan understands Hawaiian
Deﬁne the lexical entry for and as
and := (X/X)\X,
where X can refer to any type. Using this lexical entry, show how to parse the two
examples above. In the second example, Swahili should be combined with the coor-
dination Abigail speaks and Max understands, and not just with the verb understands.
Jacob Eisenstein. Draft of November , .

Chapter
Context-free parsing
Parsing is the task of determining whether a string can be derived from a given context-
free grammar, and if so, how. A parser’s output is a tree, like the ones shown in Fig-
ure .. Such trees can answer basic questions of who-did-what-to-whom, and have ap-
plications in downstream tasks like semantic analysis (chapter  and ) and information
extraction (chapter ).
For a given input and grammar, how many parse trees are there? Consider a minimal
context-free grammar with only one non-terminal, X, and the following productions:
X →X X
X →aardvark | abacus | . . . | zyther
The second line indicates unary productions to every nonterminal in Σ. In this gram-
mar, the number of possible derivations for a string w is equal to the number of binary
bracketings, e.g.,
((((w w) w) w) w),
(((w (w w)) w) w),
((w (w(w w))) w),
. . . .
The number of such bracketings is a Catalan number, which grows super-exponentially
in the length of the sentence, Cn =
(n)!
(n+)!n!. As with sequence labeling, it is only possible to
exhaustively search the space of parses by resorting to locality assumptions, which make it
possible to search efﬁciently by reusing shared substructures with dynamic programming.
This chapter focuses on a bottom-up dynamic programming algorithm, which enables
exhaustive search of the space of possible parses, but imposes strict limitations on the
form of scoring function. These limitations can be relaxed by abandoning exhaustive
search. Non-exact search methods will be brieﬂy discussed at the end of this chapter, and
one of them — transition-based parsing — will be the focus of chapter .
CHAPTER . CONTEXT-FREE PARSING
→ NP VP
NP
→ NP PP | we | sushi | chopsticks
PP
→ IN NP
IN
→ with
VP
→ V NP | VP PP
→ eat
Table .: A toy example context-free grammar
Deterministic bottom-up parsing
The CKY algorithm is a bottom-up approach to parsing in a context-free grammar. It
efﬁciently tests whether a string is in a language, without enumerating all possible parses.
The algorithm ﬁrst forms small constituents, and then tries to merge them into larger
constituents.
To understand the algorithm, consider the input, We eat sushi with chopsticks. Accord-
ing to the toy grammar in Table ., each terminal symbol can be generated by exactly
one unary production, resulting in the sequence NP V NP IN NP. In real examples, there
may be many unary productions for each individual token. In any case, the next step
is to try to apply binary productions to merge adjacent symbols into larger constituents:
for example, V NP can be merged into a verb phrase (VP), and IN NP can be merged
into a prepositional phrase (PP). Bottom-up parsing searches for a series of mergers that
ultimately results in the start symbol S covering the entire input.
The CKY algorithm systematizes this search by incrementally constructing a table t in
which each cell t[i, j] contains the set of nonterminals that can derive the span wi+:j. The
algorithm ﬁlls in the upper right triangle of the table; it begins with the diagonal, which
corresponds to substrings of length , and then computes derivations for progressively
larger substrings, until reaching the upper right corner t[, M], which corresponds to the
entire input, w:M. If the start symbol S is in t[, M], then the string w is in the language
deﬁned by the grammar. This process is detailed in Algorithm , and the resulting data
structure is shown in Figure .. Informally, here’s how it works:
Begin by ﬁlling in the diagonal: the cells t[m − , m] for all m ∈ {, , . . . , M}. These
cells are ﬁlled with terminal productions that yield the individual tokens; for the
word w = sushi, we ﬁll in t[, ] = {NP}, and so on.
Then ﬁll in the next diagonal, in which each cell corresponds to a subsequence of
length two: t[, ], t[, ], . . . , t[M − , M]. These cells are ﬁlled in by looking for
The name is for Cocke-Kasami-Younger, the inventors of the algorithm. It is a special case of chart
parsing, because its stores reusable computations in a chart-like data structure.
Jacob Eisenstein. Draft of November , .

.. DETERMINISTIC BOTTOM-UP PARSING
binary productions capable of producing at least one entry in each of the cells corre-
sponding to left and right children. For example, VP can be placed in the cell t[, ]
because the grammar includes the production VP → V NP, and because the chart
contains V ∈ t[, ] and NP ∈ t[, ].
At the next diagonal, the entries correspond to spans of length three. At this level,
there is an additional decision at each cell: where to split the left and right children.
The cell t[i, j] corresponds to the subsequence wi+:j, and we must choose some
split point i < k < j, so that the span wi+:k is the left child, and the span wk+:j
is the right child. We consider all possible k, looking for productions that generate
elements in t[i, k] and t[k, j]; the left-hand side of all such productions can be added
to t[i, j]. When it is time to compute t[i, j], the cells t[i, k] and t[k, j] are guaranteed
to be complete, since these cells correspond to shorter sub-strings of the input.
The process continues until we reach t[, M].
Figure . shows the chart that arises from parsing the sentence We eat sushi with chop-
sticks using the grammar deﬁned above.
Recovering the parse tree
As with the Viterbi algorithm, it is possible to identify a successful parse by storing and
traversing an additional table of back-pointers. If we add an entry X to cell t[i, j] by using
the production X → Y Z and the split point k, then we store the back-pointer b[i, j, X] =
(Y, Z, k). Once the table is complete, we can recover a parse by tracing this pointers,
starting at b[, M, S], and stopping when they ground out at terminal productions.
For ambiguous sentences, there will be multiple paths to reach S ∈ t[, M]. For exam-
ple, in Figure ., the goal state S ∈ t[, M] is reached through the state VP ∈ t[, ], and
there are two different ways to generate this constituent: one with (eat sushi) and (with
chopsticks) as children, and another with (eat) and (sushi with chopsticks) as children. The
presence of multiple paths indicates that the input can be generated by the grammar in
more than one way. In Algorithm , one of these derivations is selected arbitrarily. As
discussed in § ., weighted context-free grammars compute a score for all permissible
derivations, and a minor modiﬁcation of CKY allows it to identify the single derivation
with the maximum score.
Non-binary productions
As presented above, the CKY algorithm assumes that all productions with non-terminals
on the right-hand side (RHS) are binary. In real grammars, such as the one considered in
chapter , there are other types of productions: some have more than two elements on the
right-hand side, and others produce a single non-terminal.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
Algorithm  The CKY algorithm for parsing a sequence w ∈ Σ∗ in a context-free
grammar G = (N, Σ, R, S), with non-terminals N, production rules R, and start sym-
bol S. The grammar is assumed to be in Chomsky normal form (§ ..). The function
PICKFROM(b[i, j, X]) selects an element of the set b[i, j, X] arbitrarily. All values of t and
b are initialized to ∅.
: procedure CKY(w, G = (N, Σ, R, S))
for m ∈ { . . . M} do
t[m − , m] ← {X : (X → wm) ∈ R}
for ℓ ∈ {, , . . . , M} do
▷ Iterate over constituent lengths
for m ∈ {, , . . . M − ℓ} do
▷ Iterate over left endpoints
for k ∈ {m + , m + , . . . , m + ℓ − } do
▷ Iterate over split points
for (X → Y Z) ∈ R do
▷ Iterate over rules
if Y ∈ t[m, k] ∧ Z ∈ t[k, m + ℓ] then
t[m, m + ℓ] ← t[m, m + ℓ] ∪ X
▷ Add non-terminal to table
b[m, m + ℓ, X] ← b[m, m + ℓ, X] ∪ (Y, Z, k)
▷ Add back-pointers
if S ∈ t[, M] then
return TRACEBACK(S, , M, b)
else
return ∅
: procedure TRACEBACK(X, i, j, b)
if j = i +  then
return X
else
(Y, Z, k) ← PICKFROM(b[i, j, X])
return X → (TRACEBACK(Y, i, k, b), TRACEBACK(Z, k, j, b))
Productions with more than two elements on the right-hand side can be binarized
by creating additional non-terminals, as described in § ... For example, the pro-
duction VP → V NP NP (for ditransitive verbs) can be converted to VP → VPditrans/NP NP,
by adding the non-terminal VPditrans/NP and the production VPditrans/NP → V NP.
What about unary productions like VP → V? While such productions are not a
part of Chomsky Normal Form — and can therefore be eliminated in preprocessing
the grammar — in practice, a more typical solution is to modify the CKY algorithm.
The algorithm makes a second pass on each diagonal in the table, augmenting each
cell t[i, j] with all possible unary productions capable of generating each item al-
ready in the cell: formally, t[i, j] is extended to its unary closure. Suppose the ex-
ample grammar in Table . were extended to include the production VP → V,
enabling sentences with intransitive verb phrases, like we eat. Then the cell t[, ]
— corresponding to the word eat — would ﬁrst include the set {V}, and would be
augmented to the set {V, VP} during this second pass.
Jacob Eisenstein. Draft of November , .

.. AMBIGUITY
We
eat
sushi
with
chopsticks
We
NP
eat
VP
VP
sushi
NP
NP
with
PP
chopsticks
NP
Figure .: An example completed CKY chart. The solid and dashed lines show the back
pointers resulting from the two different derivations of VP in position t[, ].
Complexity
For an input of length M and a grammar with R productions and N non-terminals, the
space complexity of the CKY algorithm is O(MN): the number of cells in the chart is
O(M), and each cell must hold O(N) elements. The time complexity is O(MR): each
cell is computed by searching over O(M) split points, with R possible productions for
each split point. Both the time and space complexity are considerably worse than the
Viterbi algorithm, which is linear in the length of the input.
Ambiguity
In natural language, there is rarely a single parse for a given sentence. The main culprit is
ambiguity, which is endemic to natural language syntax. Here are a few broad categories:
Attachment ambiguity: e.g., We eat sushi with chopsticks, I shot an elephant in my
pajamas. In these examples, the prepositions (with, in) can attach to either the verb
or the direct object.
Modiﬁer scope: e.g., southern food store, plastic cup holder. In these examples, the ﬁrst
word could be modifying the subsequent adjective, or the ﬁnal noun.
Particle versus preposition: e.g., The puppy tore up the staircase. Phrasal verbs like
tore up often include particles which could also act as prepositions. This has struc-
tural implications: if up is a preposition, then up the staircase is a prepositional
phrase; if up is a particle, then the staircase is the direct object to the verb.
Complement structure: e.g., The students complained to the professor that they didn’t
understand. This is another form of attachment ambiguity, where the complement
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
that they didn’t understand could attach to the main verb (complained), or to the indi-
rect object (the professor).
Coordination scope: e.g., “I see,” said the blind man, as he picked up the hammer and
saw. In this example, the lexical ambiguity for saw enables it to be coordinated either
with the noun hammer or the verb picked up.
These forms of ambiguity can combine, so that seemingly simple headlines like Fed
raises interest rates have dozens of possible analyses even in a minimal grammar. In a
broad coverage grammar, typical sentences can have millions of parses. While careful
grammar design can chip away at this ambiguity, a better strategy is combine broad cov-
erage parsers with data-driven strategies for identifying the correct analysis.
Parser evaluation
Before continuing to parsing algorithms that are able to handle ambiguity, let us stop
to consider how to measure parsing performance. Suppose we have a set of reference
parses — the ground truth — and a set of system parses that we would like to score. A
simple solution would be per-sentence accuracy: the parser is scored by the proportion of
sentences on which the system and reference parses exactly match. But as any student
knows, it always nice to get partial credit, which we can assign to analyses that correctly
match parts of the reference parse. The PARSEval metrics (Grishman et al., ) score
each system parse via:
Precision: the fraction of constituents in the system parse that match a constituent in the
reference parse.
Recall: the fraction of constituents in the reference parse that match a constituent in the
system parse.
In labeled precision and recall, the system must also match the phrase type for each
constituent; in unlabeled precision and recall, it is only required to match the constituent
structure. As described in chapter , the precision and recall can be combined into an
F -MEASURE by their harmonic mean.
Suppose that the left tree of Figure . is the system parse, and that the right tree is
the reference parse. Then:
S → w: is true positive, because it appears in both trees.
Most parsing papers do not report results on this metric, but Suzuki et al. () ﬁnd that a strong parser
recovers the exact parse in roughly % of all sentences. Performance on short sentences is generally much
higher.
Jacob Eisenstein. Draft of November , .

.. AMBIGUITY
VP
NP
NP
VP
We
NP
VP
NP
PP
PP
eat
We
sushi
NP
NP
NP
IN
IN
chopsticks
chopsticks
sushi
with
with
eat
(a) system output
(b) reference
Figure .: Two possible analyses from the grammar in Table .
VP → w: is true positive as well.
NP → w: is false positive, because it appears only in the system output.
PP → w: is true positive, because it appears in both trees.
VP → w: is false negative, because it appears only in the reference.
The labeled and unlabeled precision of this parse is
= ., and the recall is
= ., for
an F-measure of .. For an example in which precision and recall are not equal, suppose
the reference parse instead included the production VP → V NP PP. In this parse, the
reference does not contain the constituent w:, so the recall would be .
Local solutions
Some ambiguity can be resolved locally. Consider the following examples,
a. We met the President on Monday.
b. We met the President of Mexico.
Each case ends with a prepositional phrase, which can be attached to the verb met or the
noun phrase the president. If given a labeled corpus, we can compare the likelihood of the
observing the preposition alongside each candidate attachment point,
p(on | met) ≷ p(on | President)
p(of | met) ≷ p(of | President).
While the grammar must be binarized before applying the CKY algorithm, evaluation is performed on
the original parses. It is therefore necessary to “unbinarize” the output of a CKY-based parser, converting it
back to the original grammar.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
A comparison of these probabilities would successfully resolve this case (Hindle and
Rooth, ). Other cases, such as the example we eat sushi with chopsticks, require con-
sidering the object of the preposition: consider the alternative we eat sushi with soy sauce.
With sufﬁcient labeled data, some instances of attachment ambiguity can be solved by
supervised classiﬁcation (Ratnaparkhi et al., ).
However, there are inherent limitations to local solutions. While toy examples may
have just a few ambiguities to resolve, realistic sentences have thousands or millions of
possible parses. Furthermore, attachment decisions are interdependent, as shown in the
garden path example:
Cats scratch people with claws with knives.
We may want to attach with claws to scratch, as would be correct in the shorter sentence
in cats scratch people with claws. But this leaves nowhere to attach with knives. The cor-
rect interpretation can be identiﬁed only be considering the attachment decisions jointly.
The huge number of potential parses may seem to make exhaustive search impossible.
But as with sequence labeling, locality assumptions make it possible to search this space
efﬁciently.
Weighted Context-Free Grammars
Let us deﬁne a derivation τ as a set of anchored productions,
τ = {X → α, (i, j, k)},
with X corresponding to the left-hand side non-terminal and α corresponding to the right-
hand side. For grammars in Chomsky normal formal, α is either a pair of non-terminals or
a terminal symbol. The indices i, j, k anchor the production in the input, with X deriving
the span wi+:j. For binary productions, wi+:k indicates the span of the left child, and
wk+:j indicates the span of the right child; for unary productions, k is ignored. For an
input w, the optimal parse is,
ˆτ = argmax
τ∈T (w)
Ψ(τ),
where T (w) is the set of derivations that yield the input w.
Deﬁne a scoring function Ψ that decomposes across anchored productions,
(X→α,(i,j,k))∈τ
ψ(X → α, (i, j, k)).
Ψ(τ) =
This is a locality assumption, akin to the assumption in Viterbi sequence labeling. In this
case, the assumption states that the overall score is a sum over scores of productions,
Jacob Eisenstein. Draft of November , .

.. WEIGHTED CONTEXT-FREE GRAMMARS
ψ()
exp ψ()
→ NP VP
NP
→ NP PP
→ we
→ sushi
→ chopsticks
PP
→ IN NP
IN
→ with
VP
→ V NP
→ VP PP
→ MD V
→ eat
Table .: An example weighted context-free grammar (WCFG). The weights are chosen
so that exp ψ() sums to one over right-hand sides for each non-terminal; this is required
by probabilistic context-free grammars, but not by WCFGs in general.
which are computed independently. In a weighted context-free grammar (WCFG), the
score of each anchored production X → (α, (i, j, k)) is simply ψ(X → α), ignoring the
anchor (i, j, k). In other parsing models, the anchors can be used to access features of the
input, while still permitting efﬁcient bottom-up parsing.
Example
Consider the weighted grammar shown in Table ., and the analysis in Fig-
ure .b.
Ψ(τ) =ψ(S → NP VP) + ψ(VP → VP PP) + ψ(VP → V NP) + ψ(PP → IN NP)
+ ψ(NP → We) + ψ(V → eat) + ψ(NP → sushi) + ψ(IN → with) + ψ(NP → chopsticks)
= −  −  +  −  +  −  +  −  = −.
In the alternative parse in Figure .a, the production VP → VP PP (with score −) is
replaced with the production NP → NP PP (with score −); all other productions are the
same. As a result, the score for this parse is −. This example hints at a problem with
WCFG parsing on non-terminals such as NP, VP, and PP: a WCFG will always prefer
either VP or NP attachment, regardless of what is being attached! Solutions to this issue
are discussed in § ..
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
Algorithm  CKY algorithm for parsing a string w ∈ Σ∗ in a weighted context-free
grammar (N, Σ, R, S), where N is the set of non-terminals and R is the set of weighted
productions. The grammar is assumed to be in Chomsky normal form (§ ..). The
function TRACEBACK is deﬁned in Algorithm .
procedure WCKY(w, G = (N, Σ, R, S))
for all i, j, X do
▷ Initialization
t[i, j, X] ←
b[i, j, X] ← ∅
for m ∈ {, , . . . , M} do
for all X ∈ N do
t[m, m + , X] ← ψ(X → wm, (m, m + , m))
for ℓ ∈ {, , . . . M} do
for m ∈ {, , . . . , M − ℓ} do
for k ∈ {m + , m + , . . . , m + ℓ − } do
t[m, m + ℓ, X] ← max
k,Y,Z ψ(X → Y Z, (m, m + ℓ, k)) + t[m, k, Y ] + t[k, m + ℓ, Z]
b[m, m + ℓ, X] ← argmax
k,Y,Z
ψ(X → Y Z, (m + ℓ, k)) + t[m, k, Y ] + t[k, m + ℓ, Z]
return TRACEBACK(S, , M, b)
Parsing with weighted context-free grammars
The optimization problem in Equation . can be solved by modifying the CKY algo-
rithm. In the deterministic CKY algorithm, each cell t[i, j] stored a set of non-terminals
capable of deriving the span wi+:j. We now augment the table so that the cell t[i, j, X]
is the score of the best derivation of wi+:j from non-terminal X. This score is computed
recursively: for the anchored binary production (X → Y Z, (i, j, k)), we compute:
the score of the anchored production, ψ(X → Y Z, (i, j, k));
the score of the best derivation of the left child, t[i, k, Y ];
the score of the best derivation of the right child, t[k, j, Z].
These scores are combined by addition. As in the unweighted CKY algorithm, the table
is constructed by considering spans of increasing length, so the scores for spans t[i, k, Y ]
and t[k, j, Z] are guaranteed to be available at the time we compute the score t[i, j, X]. The
value t[, M, S] is the score of the best derivation of w from the grammar. Algorithm
formalizes this procedure.
As in unweighted CKY, the parse is recovered from the table of back pointers b, where
each b[i, j, X] stores the argmax split point k and production X → Y Z in the derivation of
wi+:j from X. The top scoring parse can be obtained by tracing these pointers backwards
from b[, M, S], all the way to the terminal symbols. This is analogous to the computation
Jacob Eisenstein. Draft of November , .

.. WEIGHTED CONTEXT-FREE GRAMMARS
of the best sequence of labels in the Viterbi algorithm by tracing pointers backwards from
the end of the trellis. Note that we need only store back-pointers for the best path to
t[i, j, X]; this follows from the locality assumption that the global score for a parse is a
combination of the local scores of each production in the parse.
Example
Let’s revisit the parsing table in Figure .. In a weighted CFG, each cell
would include a score for each non-terminal; non-terminals that cannot be generated are
assumed to have a score of −∞. The ﬁrst diagonal contains the scores of unary produc-
tions: t[, , NP] = −, t[, , V] = , and so on. The next diagonal contains the scores for
spans of length : t[, , VP] = − +  −  = −, t[, , PP] =  +  −  = −, and so on.
Things get interesting when we reach the cell t[, , VP], which contains the score for the
derivation of the span w: from the non-terminal VP. This score is computed as a max
over two alternatives,
t[, , VP] = max(ψ(VP → VP PP, (, , )) + t[, , VP] + t[, , PP],
ψ(VP → V NP, (, , )) + t[, , V] + t[, , NP])
= max( −  −  − , − +  − ) = −.
Since the second case is the argmax, we set the back-pointer b[, , VP] = (V, NP, ), en-
abling the optimal derivation to be recovered.
Probabilistic context-free grammars
Probabilistic context-free grammars (PCFGs) are a special case of weighted context-
free grammars that arises when the weights correspond to probabilities. Speciﬁcally, the
weight ψ(X → α, (i, j, k)) = log p(α | X), where the probability of the right-hand side α is
conditioned on the non-terminal X, and the anchor (i, j, k) is ignored. These probabilities
must be normalized over all possible right-hand sides, so that P
α p(α | X) = , for all X.
For a given parse τ, the product of the probabilities of the productions is equal to p(τ),
under the generative model τ ∼ DRAWSUBTREE(S), where the function DRAWSUBTREE
is deﬁned in Algorithm .
The conditional probability of a parse given a string is,
p(τ | w) =
p(τ)
τ ′∈T (w) p(τ ′) =
exp Ψ(τ)
τ ′∈T (w) exp Ψ(τ ′),
where Ψ(τ) = P
X→α,(i,j,k)∈τ ψ(X → α, (i, j, k)). Because the probability is monotonic
in the score Ψ(τ), the maximum likelihood parse can be identiﬁed by the CKY algorithm
without modiﬁcation. If a normalized probability p(τ | w) is required, the denominator
of Equation . can be computed by the inside recurrence, described below.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
Algorithm  Generative model for derivations from probabilistic context-free grammars
in Chomsky Normal Form (CNF).
procedure DRAWSUBTREE(X)
sample (X → α) ∼ p(α | X)
if α = (Y Z) then
return DRAWSUBTREE(Y ) ∪ DRAWSUBTREE(Z)
else
return (X → α)
▷ In CNF, all unary productions yield terminal symbols
Example
The WCFG in Table . is designed so that the weights are log-probabilities,
satisfying the constraint P
α exp ψ(X → α) = . As noted earlier, there are two parses in
T (we eat sushi with chopsticks), with scores Ψ(τ) = log p(τ) = − and Ψ(τ) = log p(τ) =
−. Therefore, the conditional probability p(τ | w) is equal to,
p(τ) + p(τ) =
exp Ψ(τ)
exp Ψ(τ) + exp Ψ(τ) =
− + − =
p(τ | w) =
p(τ)
The inside recurrence
The denominator of Equation . can be viewed as a language
model, summing over all valid derivations of the string w,
τ ′:yield(τ ′)=w
p(τ ′).
p(w) =
Just as the CKY algorithm makes it possible to maximize over all such analyses, with
a few modiﬁcations it can also compute their sum. Each cell t[i, j, X] must store the log
probability of deriving wi+:j from non-terminal X. To compute this, we replace the max-
imization over split points k and productions X → Y Z with a “log-sum-exp” operation,
which exponentiates the log probabilities of the production and the children, sums them
in probability space, and then converts back to the log domain:
k,Y,Z
exp (ψ(X → Y Z) + t[i, k, Y ] + t[k, j, Z])
t[i, j, X] = log
k,Y,Z
exp (log p(Y Z | X) + log p(Y → wi+:k) + log p(Z → wk+:j))
= log
k,Y,Z
p(Y Z | X) × p(Y → wi+:k) × p(Z → wk+:j)
= log
k,Y,Z
p(Y Z, wi+:k, wk+:j | X)
= log
= log p(X ⇝ wi+:j),
Jacob Eisenstein. Draft of November , .

.. WEIGHTED CONTEXT-FREE GRAMMARS
with X ⇝ wi+:j indicating the event that non-terminal X yields the span wi+, wi+, . . . , wj.
The recursive computation of t[i, j, X] is called the inside recurrence, because it computes
the probability of each subtree as a combination of the probabilities of the smaller subtrees
that are inside of it. The name implies a corresponding outside recurrence, which com-
putes the probability of a non-terminal X spanning wi+:j, joint with the outside context
(w:i, wj+:M). This recurrence is described in § ... The inside and outside recurrences
are analogous to the forward and backward recurrences in probabilistic sequence label-
ing (see § ..). They can be used to compute the marginal probabilities of individual
anchored productions, p(X → α, (i, j, k) | w), summing over all possible derivations of
w.
*Semiring weighted context-free grammars
The weighted and unweighted CKY algorithms can be uniﬁed with the inside recurrence
using the same semiring notation described in § ... The generalized recurrence is:
k,Y,Z
ψ(X → Y Z, (i, j, k)) ⊗ t[i, k, Y ] ⊗ t[k, j, Z].
t[i, j, X] =
This recurrence subsumes all of the algorithms that have been discussed in this chapter to
this point.
Unweighted CKY. When ψ(X → α, (i, j, k)) is a Boolean truth value {⊤, ⊥}, ⊗ is logical
conjunction, and L is logical disjunction, then we derive CKY recurrence for un-
weighted context-free grammars, discussed in § . and Algorithm .
Weighted CKY. When ψ(X → α, (i, j, k)) is a scalar score, ⊗ is addition, and L is maxi-
mization, then we derive the CKY recurrence for weighted context-free grammars,
discussed in § . and Algorithm . When ψ(X → α, (i, j, k)) = log p(α | X),
this same setting derives the CKY recurrence for ﬁnding the maximum likelihood
derivation in a probabilistic context-free grammar.
Inside recurrence. When ψ(X → α, (i, j, k)) is a log probability, ⊗ is addition, and L =
log P exp, then we derive the inside recurrence for probabilistic context-free gram-
mars, discussed in § ... It is also possible to set ψ(X → α, (i, j, k)) directly equal
to the probability p(α | X). In this case, ⊗ is multiplication, and L is addition.
While this may seem more intuitive than working with log probabilities, there is the
risk of underﬂow on long inputs.
Regardless of how the scores are combined, the key point is the locality assumption:
the score for a derivation is the combination of the independent scores for each anchored
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
production, and these scores do not depend on any other part of the derivation. For exam-
ple, if two non-terminals are siblings, the scores of productions from these non-terminals
are computed independently. This locality assumption is analogous to the ﬁrst-order
Markov assumption in sequence labeling, where the score for transitions between tags
depends only on the previous tag and current tag, and not on the history. As with se-
quence labeling, this assumption makes it possible to ﬁnd the optimal parse efﬁciently; its
linguistic limitations are discussed in § ..
Learning weighted context-free grammars
Like sequence labeling, context-free parsing is a form of structure prediction. As a result,
WCFGs can be learned using the same set of algorithms: generative probabilistic models,
structured perceptron, maximum conditional likelihood, and maximum margin learning.
In all cases, learning requires a treebank, which is a dataset of sentences labeled with
context-free parses. Parsing research was catalyzed by the Penn Treebank (Marcus et al.,
), the ﬁrst large-scale dataset of this type (see § ..). Phrase structure treebanks exist
for roughly two dozen other languages, with coverage mainly restricted to European and
East Asian languages, plus Arabic and Urdu.
Probabilistic context-free grammars
Probabilistic context-free grammars are similar to hidden Markov models, in that they are
generative models of text. In this case, the parameters of interest correspond to probabil-
ities of productions, conditional on the left-hand side. As with hidden Markov models,
these parameters can be estimated by relative frequency:
ψ(X → α) = log p(X → α)
ˆp(X → α) =count(X → α)
count(X)
For example, the probability of the production NP → DET NN is the corpus count of
this production, divided by the count of the non-terminal NP. This estimator applies
to terminal productions as well: the probability of NN → whale is the count of how often
whale appears in the corpus as generated from an NN tag, divided by the total count of the
NN tag. Even with the largest treebanks — currently on the order of one million tokens
— it is difﬁcult to accurately compute probabilities of even moderately rare events, such
as NN → whale. Therefore, smoothing is critical for making PCFGs effective.
Jacob Eisenstein. Draft of November , .

.. LEARNING WEIGHTED CONTEXT-FREE GRAMMARS
Feature-based parsing
The scores for each production can be computed as an inner product of weights and fea-
tures,
ψ(X → α, (i, j, k)) = θ  f(X, α, (i, j, k), w),
where the feature vector f is a function of the left-hand side X, the right-hand side α, the
anchor indices (i, j, k), and the input w.
The basic feature f(X, α, (i, j, k)) = {(X, α)} encodes only the identity of the produc-
tion itself. This gives rise to a discriminatively-trained model with the same expressive-
ness as a PCFG. Features on anchored productions can include the words that border the
span wi, wj+, the word at the split point wk+, the presence of a verb or noun in the left
child span wi+:k, and so on (Durrett and Klein, ). Scores on anchored productions
can be incorporated into CKY parsing without any modiﬁcation to the algorithm, because
it is still possible to compute each element of the table t[i, j, X] recursively from its imme-
diate children.
Other features can be obtained by grouping elements on either the left-hand or right-
hand side: for example it can be particularly beneﬁcial to compute additional features
by clustering terminal symbols, with features corresponding to groups of words with
similar syntactic properties. The clustering can be obtained from unlabeled datasets that
are much larger than any treebank, improving coverage. Such methods are described in
chapter .
Feature-based parsing models can be estimated using the usual array of discrimina-
tive learning techniques. For example, a structure perceptron update can be computed
as (Carreras et al., ),
(X→α,(i,j,k))∈τ
f(X, α, (i, j, k), w(i))
f(τ, w(i)) =
ˆτ = argmax
τ∈T (w)
θ  f(τ, w(i))
θ ←f(τ (i), w(i)) − f(ˆτ, w(i)).
A margin-based objective can be optimized by selecting ˆτ through cost-augmented decod-
ing (§ ..), enforcing a margin of ∆(ˆτ, τ) between the hypothesis and the reference parse,
where ∆ is a non-negative cost function, such as the Hamming loss (Stern et al., ). It
is also possible to train feature-based parsing models by conditional log-likelihood, as
described in the next section.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
wk+ . . . wi
wj+ . . . wk
wi+ . . . wj
wi+ . . . wj
Figure .: The two cases faced by the outside recurrence in the computation of β(i, j, X)
*Conditional random ﬁeld parsing
The score of a derivation Ψ(τ) can be converted into a probability by normalizing over all
possible derivations,
p(τ | w) =
exp Ψ(τ)
τ ′∈T (w) exp Ψ(τ ′).
Using this probability, a WCFG can be trained by maximizing the conditional log-likelihood
of a labeled corpus.
Just as in logistic regression and the conditional random ﬁeld over sequences, the
gradient of the conditional log-likelihood is the difference between the observed and ex-
pected counts of each feature. The expectation Eτ|w[f(τ, w(i)); θ] requires summing over
all possible parses, and computing the marginal probabilities of anchored productions,
p(X → α, (i, j, k) | w). In CRF sequence labeling, marginal probabilities over tag bigrams
are computed by the two-pass forward-backward algorithm (§ ..). The analogue for
context-free grammars is the inside-outside algorithm, in which marginal probabilities
are computed from terms generated by an upward and downward pass over the parsing
chart:
The upward pass is performed by the inside recurrence, which is described in § ...
Each inside variable α(i, j, X) is the score of deriving wi+:j from the non-terminal
X. In a PCFG, this corresponds to the log-probability log p(wi+:j | X). This is
computed by the recurrence,
k=i+
exp (ψ(X → Y Z, (i, j, k)) + α(i, k, Y ) + α(k, j, Z)) .
(X→Y Z)
α(i, j, X) ≜ log
The initial condition of this recurrence is α(m − , m, X) = ψ(X → wm). The de-
nominator P
τ∈T (w) exp Ψ(τ) is equal to exp α(, M, S).
The downward pass is performed by the outside recurrence, which recursively pop-
ulates the same table structure, starting at the root of the tree. Each outside variable
Jacob Eisenstein. Draft of November , .

.. LEARNING WEIGHTED CONTEXT-FREE GRAMMARS
β(i, j, X) is the score of having a phrase of type X covering the span (i +  : j), joint
with the exterior context w:i and wj+:M. In a PCFG, this corresponds to the log
probability log p((X, i + , j), w:i, wj+:M). Each outside variable is computed by
the recurrence,
k=j+
exp [ψ(Y → X Z, (i, k, j)) + α(j, k, Z) + β(i, k, Y )]
(Y →X Z)
exp β(i, j, X) ≜
k=
exp [ψ(Y → Z X, (k, i, j)) + α(k, i, Z) + β(k, j, Y )] .
(Y →Z X)
i−
The ﬁrst line of Equation . is the score under the condition that X is a left child
of its parent, which spans wi+:k, with k > j; the second line is the score under the
condition that X is a right child of its parent Y , which spans wk+:j, with k < i.
The two cases are shown in Figure .. In each case, we sum over all possible
productions with X on the right-hand side. The parent Y is bounded on one side
by either i or j, depending on whether X is a left or right child of Y ; we must sum
over all possible values for the other boundary. The initial conditions for the outside
recurrence are β(, M, S) =  and β(, M, X ̸= S) = −∞.
The marginal probability of a non-terminal X over span wi+:j is written p(X ⇝ wi+:j | w).
This probability can be computed from the inside and outside scores,
p(w)
p(X ⇝ wi+:j | w) =p(X ⇝ wi+:j, w)
=p(wi+:j | X) × p(X, w:i, xj+:M)
p(w)
=exp (α(i, j, X) + β(i, j, X))
exp α(, M, S)
Marginal probabilities of individual productions can be computed similarly (see exercise
). These marginal probabilities can be used for training a conditional random ﬁeld parser,
and also for the task of unsupervised grammar induction, in which a PCFG is estimated
from a dataset of unlabeled text (Lari and Young, ; Pereira and Schabes, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
Neural context-free grammars
Neural networks and can be applied to parsing by representing each span with a dense
numerical vector (Socher et al., ; Durrett and Klein, ; Cross and Huang, ).
For example, the anchor (i, j, k) and sentence w can be associated with a ﬁxed-length
column vector,
v(i,j,k) = [uwi−; uwi; uwj−; uwj; uwk−; uwk],
where uwi is a word embedding associated with the word wi. The vector vi,j,k can then be
passed through a feedforward neural network, and used to compute the score of the an-
chored production. For example, this score can be computed as a bilinear product (Durrett
and Klein, ),
˜v(i,j,k) =FeedForward(v(i,j,k))
ψ(X → α, (i, j, k)) =˜v⊤
(i,j,k)Θf(X → α),
where f(X → α) is a vector of features of the production, and Θ is a parameter ma-
trix. The matrix Θ and the parameters of the feedforward network can be learned by
backpropagating from an objective such as the margin loss or the negative conditional
log-likelihood.
Grammar reﬁnement
The locality assumptions underlying CFG parsing depend on the granularity of the non-
terminals. For the Penn Treebank non-terminals, there are several reasons to believe that
these assumptions are too strong (Johnson, ):
The context-free assumption is too strict: for example, the probability of the produc-
tion NP → NP PP is much higher (in the PTB) if the parent of the noun phrase is a
verb phrase (indicating that the NP is a direct object) than if the parent is a sentence
(indicating that the NP is the subject of the sentence).
The Penn Treebank non-terminals are too coarse: there are many kinds of noun
phrases and verb phrases, and accurate parsing sometimes requires knowing the
difference.
As we have already seen, when faced with prepositional phrase at-
tachment ambiguity, a weighted CFG will either always choose NP attachment (if
ψ(NP → NP PP) > ψ(VP → VP PP)), or it will always choose VP attachment. To
get more nuanced behavior, more ﬁne-grained non-terminals are needed.
More generally, accurate parsing requires some amount of semantics — understand-
ing the meaning of the text to be parsed. Consider the example cats scratch people
Earlier work on neural constituent parsing used transition-based parsing algorithms (§ ..) rather
than CKY-style chart parsing (Henderson, ; Titov and Henderson, ).
Jacob Eisenstein. Draft of November , .

.. GRAMMAR REFINEMENT
VP
VP
NP
NP
NP
NP
PRP
PRP
NN
likes
likes
NP
PP
she
she
CC
NP
NNP
NP
wine
and
PP
NN
Italy
from
NP
CC
NP
wine
NP
NNP
and
NNP
from
NNP
Italy
France
France
Figure .: The left parse is preferable because of the conjunction of phrases headed by
France and Italy, but these parses cannot be distinguished by a WCFG.
with claws: knowledge of about cats, claws, and scratching is necessary to correctly
resolve the attachment ambiguity.
An extreme example is shown in Figure .. The analysis on the left is preferred
because of the conjunction of similar entities France and Italy. But given the non-terminals
shown in the analyses, there is no way to differentiate these two parses, since they include
exactly the same productions. What is needed seems to be more precise non-terminals.
One possibility would be to rethink the linguistics behind the Penn Treebank, and ask
the annotators to try again. But the original annotation effort took ﬁve years, and there
is a little appetite for another annotation effort of this scope. Researchers have therefore
turned to automated techniques.
Parent annotations and other tree transformations
The key assumption underlying context-free parsing is that productions depend only on
the identity of the non-terminal on the left-hand side, and not on its ancestors or neigh-
bors. The validity of this assumption is an empirical question, and it depends on the
non-terminals themselves: ideally, every noun phrase (and verb phrase, etc) would be
distributionally identical, so the assumption would hold. But in the Penn Treebank, the
observed probability of productions often depends on the parent of the left-hand side.
For example, noun phrases are more likely to be modiﬁed by prepositional phrases when
they are in the object position (e.g., they amused the students from Georgia) than in the subject
position (e.g., the students from Georgia amused them). This means that the NP → NP PP
production is more likely if the entire constituent is the child of a VP than if it is the child
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
VP
VP-S
NP
NP-S
NP
NP-VP
she
she
VP-VP
NN
NN-NP
DT
DT-NP
heard
heard
bear
bear
the
the
Figure .: Parent annotation in a CFG derivation
of S. The observed statistics are (Johnson, ):
Pr(NP → NP PP) =%
Pr(NP under S → NP PP) =%
Pr(NP under VP → NP PP) =%.
This phenomenon can be captured by parent annotation (Johnson, ), in which each
non-terminal is augmented with the identity of its parent, as shown in Figure .). This is
sometimes called vertical Markovization, since a Markov dependency is introduced be-
tween each node and its parent (Klein and Manning, ). It is analogous to moving from
a bigram to a trigram context in a hidden Markov model. In principle, parent annotation
squares the size of the set of non-terminals, which could make parsing considerably less
efﬁcient. But in practice, the increase in the number of non-terminals that actually appear
in the data is relatively modest (Johnson, ).
Parent annotation weakens the WCFG locality assumptions. This improves accuracy
by enabling the parser to make more ﬁne-grained distinctions, which better capture real
linguistic phenomena. However, each production is more rare, and so careful smoothing
or regularization is required to control the variance over production scores.
Lexicalized context-free grammars
The examples in § .. demonstrate the importance of individual words in resolving
parsing ambiguity: the preposition on is more likely to attach to met, while the preposition
of is more likely to attachment to President. But of all word pairs, which are relevant to
attachment decisions? Consider the following variants on the original examples:
a. We met the President of Mexico.
b. We met the ﬁrst female President of Mexico.
c. They had supposedly met the President on Monday.
The underlined words are the head words of their respective phrases: met heads the verb
phrase, and President heads the direct object noun phrase. These heads provide useful
Jacob Eisenstein. Draft of November , .

.. GRAMMAR REFINEMENT
VP(meet)
VP(meet)
PP(on)
NP(President)
NP(President)
VB
VB
PP(of)
NP
meet
DT
NN
NP(President)
meet
NN
on
the
NP
NN
President
DT
NN
Monday
President
of
the
Mexico
(a) Lexicalization and attachment ambiguity
NP(Italy)
NP(wine)
PP(from)
NP(Italy)
NP(wine)
CC
NP(wine)
NP(Italy)
IN
NNS
NN
and
PP(from)
NP(wine)
Italy
NP(Italy)
wine
CC
from
NP(France)
NP(France)
NN
IN
NNS
and
NNP
NNP
wine
from
Italy
France
France
(b) Lexicalization and coordination scope ambiguity
Figure .: Examples of lexicalization
semantic information. But they break the context-free assumption, which states that the
score for a production depends only on the parent and its immediate children, and not
the substructure under each child.
The incorporation of head words into context-free parsing is known as lexicalization,
and is implemented in rules of the form,
NP(President) →NP(President) PP(of)
NP(President) →NP(President) PP(on).
Lexicalization was a major step towards accurate PCFG parsing in the s and early
s. It requires solving three problems: identifying the heads of all constituents in a
treebank; parsing efﬁciently while keeping track of the heads; and estimating the scores
for lexicalized productions.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
Non-terminal
Direction
Priority
right
VP SBAR ADJP UCP NP
VP
left
VBD VBN MD VBZ TO VB VP VBG VBP ADJP NP
NP
right
N* EX $ CD QP PRP . . .
PP
left
IN TO FW
Table .: A fragment of head percolation rules for English (Magerman, ; Collins,
Identifying head words
The head of a constituent is the word that is the most useful for determining how that
constituent is integrated into the rest of the sentence. The head word of a constituent is
determined recursively: for any non-terminal production, the head of the left-hand side
must be the head of one of the children. The head is typically selected according to a set of
deterministic rules, sometimes called head percolation rules. In many cases, these rules
are straightforward: the head of a noun phrase in a NP → DET NN production is the head
of the noun; the head of a sentence in a S → NP VP production is the head of the verb
phrase.
Table . shows a fragment of the head percolation rules used in many English pars-
ing systems. The meaning of the ﬁrst rule is that to ﬁnd the head of an S constituent, ﬁrst
look for the rightmost VP child; if you don’t ﬁnd one, then look for the rightmost SBAR
child, and so on down the list. Verb phrases are headed by left verbs (the head of can plan
on walking is planned, since the modal verb can is tagged MD); noun phrases are headed by
the rightmost noun-like non-terminal (so the head of the red cat is cat), and prepositional
phrases are headed by the preposition (the head of at Georgia Tech is at). Some of these
rules are somewhat arbitrary — there’s no particular reason why the head of cats and dogs
should be dogs — but the point here is just to get some lexical information that can support
parsing, not to make deep claims about syntax. Figure . shows the application of these
rules to two of the running examples.
Parsing lexicalized context-free grammars
A na¨ıve application of lexicalization would simply increase the set of non-terminals by
taking the cross-product with the set of terminal symbols, so that the non-terminals now
This is a pragmatic deﬁnition, beﬁtting our goal of using head words to improve parsing; for a more
formal deﬁnition, see (Bender, , chapter ).
The noun phrase non-terminal is sometimes treated as a special case. Collins () uses a heuristic that
looks for the rightmost child which is a noun-like part-of-speech (e.g., NN, NNP), a possessive marker, or a
superlative adjective (e.g., the greatest). If no such child is found, the heuristic then looks for the leftmost NP.
If there is no child with tag NP, the heuristic then applies another priority list, this time from right to left.
Jacob Eisenstein. Draft of November , .

.. GRAMMAR REFINEMENT
include symbols like NP(President) and VP(meet). Under this approach, the CKY parsing
algorithm could be applied directly to the lexicalized production rules. However, the
complexity would be cubic in the size of the vocabulary of terminal symbols, which would
clearly be intractable.
Another approach is to augment the CKY table with an additional index, keeping track
of the head of each constituent. The cell t[i, j, h, X] stores the score of the best derivation in
which non-terminal X spans wi+:j with head word h, where i < h ≤ j. To compute such
a table recursively, we must consider the possibility that each phrase gets its head from
either its left or right child. The scores of the best derivations in which the head comes
from the left and right child are denoted tℓ and tr respectively, leading to the following
recurrence:
tℓ[i, j, h, X] =
max
(X→Y Z) max
k>h max
k<h′≤j t[i, k, h, Y ] + t[k, j, h′, Z] + ψ(X(h) → Y (h)Z(h′))
tr[i, j, h, X] =
max
(X→Y Z) max
k<h max
i<h′≤k t[i, k, h′, Y ] + t[k, j, h, Z] + (ψ(X(h) → Y (h′)Z(h)))
t[i, j, h, X] = max (tℓ[i, j, h, X], tr[i, j, h, X]) .
To compute tℓ, we maximize over all split points k > h, since the head word must be in
the left child. We then maximize again over possible head words h′ for the right child. An
analogous computation is performed for tr. The size of the table is now O(MN), where
M is the length of the input and N is the number of non-terminals. Furthermore, each
cell is computed by performing O(M) operations, since we maximize over both the split
point k and the head h′. The time complexity of the algorithm is therefore O(RMN),
where R is the number of rules in the grammar. Fortunately, more efﬁcient solutions are
possible. In general, the complexity of parsing can be reduced to O(M) in the length of
the input; for a broad class of lexicalized CFGs, the complexity can be made cubic in the
length of the input, just as in unlexicalized CFGs (Eisner, ).
Estimating lexicalized context-free grammars
The ﬁnal problem for lexicalized parsing is how to estimate weights for lexicalized pro-
ductions X(i) → Y (j) Z(k). These productions are said to be bilexical, because they
involve scores over pairs of words: in the example meet the President of Mexico, we hope
to choose the correct attachment point by modeling the bilexical afﬁnities of (meet, of) and
(President, of). The number of such word pairs is quadratic in the size of the vocabulary,
making it difﬁcult to estimate the weights of lexicalized production rules directly from
data. This is especially true for probabilistic context-free grammars, in which the weights
are obtained from smoothed relative frequency. In a treebank with a million tokens, a
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
vanishingly small fraction of the possible lexicalized productions will be observed more
than once. The Charniak () and Collins () parsers therefore focus on approxi-
mating the probabilities of lexicalized productions, using various smoothing techniques
and independence assumptions.
In discriminatively-trained weighted context-free grammars, the scores for each pro-
duction can be computed from a set of features, which can be made progressively more
ﬁne-grained (Finkel et al., ). For example, the score of the lexicalized production
NP(President) → NP(President) PP(of) can be computed from the following features:
f(NP(President) → NP(President) PP(of)) = {NP(*) → NP(*) PP(*),
NP(President) → NP(President) PP(*),
NP(*) → NP(*) PP(of),
NP(President) → NP(President) PP(of)}
The ﬁrst feature scores the unlexicalized production NP → NP PP; the next two features
lexicalize only one element of the production, thereby scoring the appropriateness of NP
attachment for the individual words President and of; the ﬁnal feature scores the speciﬁc
bilexical afﬁnity of President and of. For bilexical pairs that are encountered frequently in
the treebank, this bilexical feature can play an important role in parsing; for pairs that are
absent or rare, regularization will drive its weight to zero, forcing the parser to rely on the
more coarse-grained features.
In chapter , we will encounter techniques for clustering words based on their distri-
butional properties — the contexts in which they appear. Such a clustering would group
rare and common words, such as whale, shark, beluga, Leviathan. Word clusters can be used
as features in discriminative lexicalized parsing, striking a middle ground between full
lexicalization and non-terminals (Finkel et al., ). In this way, labeled examples con-
taining relatively common words like whale can help to improve parsing for rare words
like beluga, as long as those two words are clustered together.
*Reﬁnement grammars
Lexicalization improves on context-free parsing by adding detailed information in the
form of lexical heads. However, estimating the scores of lexicalized productions is dif-
ﬁcult. Klein and Manning () argue that the right level of linguistic detail is some-
where between treebank categories and individual words. Some parts-of-speech and non-
terminals are truly substitutable: for example, cat/N and dog/N. But others are not: for
example, the preposition of exclusively attaches to nouns, while the preposition as is more
The real situation is even more difﬁcult, because non-binary context-free grammars can involve trilexical
or higher-order dependencies, between the head of the constituent and multiple of its children (Carreras et al.,
Jacob Eisenstein. Draft of November , .

.. BEYOND CONTEXT-FREE PARSING
likely to modify verb phrases. Klein and Manning () obtained a % improvement in
F -MEASURE on a parent-annotated PCFG parser by making a single change: splitting the
preposition category into six subtypes. They propose a series of linguistically-motivated
reﬁnements to the Penn Treebank annotations, which in total yielded a % error reduc-
tion.
Non-terminal reﬁnement process can be automated by treating the reﬁned categories
as latent variables.
For example, we might split the noun phrase non-terminal into
NP, NP, NP, . . . , without deﬁning in advance what each reﬁned non-terminal cor-
responds to. This can be treated as partially supervised learning, similar to the multi-
component document classiﬁcation model described in § ... A latent variable PCFG
can be estimated by expectation maximization (Matsuzaki et al., ):
In the E-step, estimate a marginal distribution q over the reﬁnement type of each
non-terminal in each derivation. These marginals are constrained by the original
annotation: an NP can be reannotated as NP, but not as VP. Marginal probabil-
ities over reﬁned productions can be computed from the inside-outside algorithm,
as described in § .., where the E-step enforces the constraints imposed by the
original annotations.
In the M-step, recompute the parameters of the grammar, by summing over the
probabilities of anchored productions that were computed in the E-step:
E[count(X → Y Z)] =
i=
j=i
k=i
p(X → Y Z, (i, j, k) | w).
As usual, this process can be iterated to convergence. To determine the number of re-
ﬁnement types for each tag, Petrov et al. () apply a split-merge heuristic; Liang et al.
() and Finkel et al. () apply Bayesian nonparametrics (Cohen, ).
Some examples of reﬁned non-terminals are shown in Table .. The proper nouns
differentiate months, ﬁrst names, middle initials, last names, ﬁrst names of places, and
second names of places; each of these will tend to appear in different parts of grammatical
productions. The personal pronouns differentiate grammatical role, with PRP- appear-
ing in subject position at the beginning of the sentence (note the capitalization), PRP-
appearing in subject position but not at the beginning of the sentence, and PRP- appear-
ing in object position.
Beyond context-free parsing
In the context-free setting, the score for a parse is a combination of the scores of individual
productions. As we have seen, these models can be improved by using ﬁner-grained non-
Spectral learning, described in § .., has also been applied to reﬁnement grammars (Cohen et al., ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
Proper nouns
NNP-
Oct.
Nov.
Sept.
NNP-
John
Robert
James
NNP-
J.
E.
L.
NNP-
Bush
Noriega
Peters
NNP-
New
San
Wall
NNP-
York
Francisco
Street
Personal Pronouns
PRP-
It
He
PRP-
it
he
they
PRP-
it
them
him
Table .: Examples of automatically reﬁned non-terminals and some of the words that
they generate (Petrov et al., ).
terminals, via parent-annotation, lexicalization, and automated reﬁnement. However, the
inherent limitations to the expressiveness of context-free parsing motivate the consider-
ation of other search strategies. These strategies abandon the optimality guaranteed by
bottom-up parsing, in exchange for the freedom to consider arbitrary properties of the
proposed parses.
Reranking
A simple way to relax the restrictions of context-free parsing is to perform a two-stage pro-
cess, in which a context-free parser generates a k-best list of candidates, and a reranker
then selects the best parse from this list (Charniak and Johnson, ; Collins and Koo,
). The reranker can be trained from an objective that is similar to multi-class classi-
ﬁcation: the goal is to learn weights that assign a high score to the reference parse, or to
the parse on the k-best list that has the lowest error. In either case, the reranker need only
evaluate the K best parses, and so no context-free assumptions are necessary. This opens
the door to more expressive scoring functions:
It is possible to incorporate arbitrary non-local features, such as the structural par-
allelism and right-branching orientation of the parse (Charniak and Johnson, ).
Reranking enables the use of recursive neural networks, in which each constituent
span wi+:j receives a vector ui,j which is computed from the vector representa-
tions of its children, using a composition function that is linked to the production
Jacob Eisenstein. Draft of November , .

.. BEYOND CONTEXT-FREE PARSING
rule (Socher et al., ), e.g.,

ui,j = f

ΘX→Y Z
ui,k
uk,j
The overall score of the parse can then be computed from the ﬁnal vector, Ψ(τ) =
θu,M.
Reranking can yield substantial improvements in accuracy. The main limitation is that it
can only ﬁnd the best parse among the K-best offered by the generator, so it is inherently
limited by the ability of the bottom-up parser to ﬁnd high-quality candidates.
Transition-based parsing
Structure prediction can be viewed as a form of search. An alternative to bottom-up pars-
ing is to read the input from left-to-right, gradually building up a parse structure through
a series of transitions. Transition-based parsing is described in more detail in the next
chapter, in the context of dependency parsing. However, it can also be applied to CFG
parsing, as brieﬂy described here.
For any context-free grammar, there is an equivalent pushdown automaton, a model
of computation that accepts exactly those strings that can be derived from the grammar.
This computational model consumes the input from left to right, while pushing and pop-
ping elements on a stack. This architecture provides a natural transition-based parsing
framework for context-free grammars, known as shift-reduce parsing.
Shift-reduce parsing is a type of transition-based parsing, in which the parser can take
the following actions:
shift the next terminal symbol onto the stack;
unary-reduce the top item on the stack, using a unary production rule in the gram-
mar;
binary-reduce the top two items onto the stack, using a binary production rule in the
grammar.
The set of available actions is constrained by the situation: the parser can only shift if
there are remaining terminal symbols in the input, and it can only reduce if an applicable
production rule exists in the grammar. If the parser arrives at a state where the input
has been completely consumed, and the stack contains only the element S, then the input
is accepted. If the parser arrives at a non-accepting state where there are no possible
actions, the input is rejected. A parse error occurs if there is some action sequence that
would accept an input, but the parser does not ﬁnd it.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
Example
Consider the input we eat sushi and the grammar in Table .. The input can
be parsed through the following sequence of actions:
. Shift the ﬁrst token we onto the stack.
. Reduce the top item on the stack to NP, using the production NP → we.
. Shift the next token eat onto the stack, and reduce it to V with the production V →
eat.
. Shift the ﬁnal token sushi onto the stack, and reduce it to NP. The input has been
completely consumed, and the stack contains [NP, V, NP].
. Reduce the top two items using the production VP → V NP. The stack now con-
tains [VP, NP].
. Reduce the top two items using the production S → NP VP. The stack now contains
[S]. Since the input is empty, this is an accepting state.
One thing to notice from this example is that the number of shift actions is equal to the
length of the input. The number of reduce actions is equal to the number of non-terminals
in the analysis, which grows linearly in the length of the input. Thus, the overall time
complexity of shift-reduce parsing is linear in the length of the input (assuming the com-
plexity of each individual classiﬁcation decision is constant in the length of the input).
This is far better than the cubic time complexity required by CKY parsing.
Transition-based parsing as inference
In general, it is not possible to guarantee that
a transition-based parser will ﬁnd the optimal parse, argmaxτ Ψ(τ; w), even under the
usual CFG independence assumptions. We could assign a score to each anchored parsing
action in each context, with ψ(a, c) indicating the score of performing action a in context c.
One might imagine that transition-based parsing could efﬁciently ﬁnd the derivation that
maximizes the sum of such scores. But this too would require backtracking and searching
over an exponentially large number of possible action sequences: if a bad decision is
made at the beginning of the derivation, then it may be impossible to recover the optimal
action sequence without backtracking to that early mistake. This is known as a search
error. Transition-based parsers can incorporate arbitrary features, without the restrictive
independence assumptions required by chart parsing; search errors are the price that must
be paid for this ﬂexibility.
Learning transition-based parsing
Transition-based parsing can be combined with ma-
chine learning by training a classiﬁer to select the correct action in each situation. This
classiﬁer is free to choose any feature of the input, the state of the parser, and the parse
history. However, there is no optimality guarantee: the parser may choose a suboptimal
parse, due to a mistake at the beginning of the analysis. Nonetheless, some of the strongest
Jacob Eisenstein. Draft of November , .

.. BEYOND CONTEXT-FREE PARSING
CFG parsers are based on the shift-reduce architecture, rather than CKY. A recent gener-
ation of models links shift-reduce parsing with recurrent neural networks, updating a
hidden state vector while consuming the input (e.g., Cross and Huang, ; Dyer et al.,
). Learning algorithms for transition-based parsing are discussed in more detail in
§ ..
Exercises
. Design a grammar that handles English subject-verb agreement. Speciﬁcally, your
grammar should handle the examples below correctly:
a. She sings.
b. We sing.
a. *She sing.
b. *We sings.
. Extend your grammar from the previous problem to include the auxiliary verb can,
so that the following cases are handled:
a. She can sing.
b. We can sing.
a. *She can sings.
b. *We can sings.
. French requires subjects and verbs to agree in person and number, and it requires
determiners and nouns to agree in gender and number. Verbs and their objects need
not agree. Assuming that French has two genders (feminine and masculine), three
persons (ﬁrst [me], second [you], third [her]), and two numbers (singular and plural),
how many productions are required to extend the following simple grammar to
handle agreement?
NP VP
VP
V | V NP | V NP NP
NP
DET NN
. Consider the grammar:
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . CONTEXT-FREE PARSING
NP VP
VP
V NP
NP
JJ NP
NP
ﬁsh (the animal)
ﬁsh (the action of ﬁshing)
JJ
ﬁsh (a modiﬁer, as in ﬁsh sauce or ﬁsh stew)
Apply the CKY algorithm and identify all possible parses for the sentence ﬁsh ﬁsh
ﬁsh ﬁsh.
. Choose one of the possible parses for the previous problem, and show how it can be
derived by a series of shift-reduce actions.
. To handle VP coordination, a grammar includes the production VP → VP CC VP.
To handle adverbs, it also includes the production VP → VP ADV. Assume all verbs
are generated from a sequence of unary productions, e.g., VP → V → eat.
a) Show how to binarize the production VP → VP CC VP.
b) Use your binarized grammar to parse the sentence They eat and drink together,
treating together as an adverb.
c) Prove that a weighted CFG cannot distinguish the two possible derivations of
this sentence. Your explanation should focus on the productions in the original,
non-binary grammar.
d) Explain what condition must hold for a parent-annotated WCFG to prefer the
derivation in which together modiﬁes the coordination eat and drink.
. Consider the following PCFG:
p(X → X X) =
p(X → Y ) =
p(Y → σ) =
|Σ|, ∀σ ∈ Σ
a) Compute the probability p(ˆτ) of the maximum probability parse for a string
w ∈ ΣM.
b) Compute the conditional probability p(ˆτ | w).
. Context-free grammars can be used to parse the internal structure of words. Us-
ing the weighted CKY algorithm and the following weighted context-free grammar,
identify the best parse for the sequence of morphological segments in+ﬂame+able.
Jacob Eisenstein. Draft of November , .

.. BEYOND CONTEXT-FREE PARSING
VPref N
N JSuff
V JSuff
NegPref J
VPref
in+
NegPref
in+
ﬂame
JSuff
+able
. Use the inside and outside scores to compute the marginal probability p(Xi+:j → Yi+:k Zk+:j | w),
indicating that Y spans wi+:k, Z spans wk+:j, and X is the parent of Y and Z, span-
ning wi+:j.
. Suppose that the potentials Ψ(X → α) are log-probabilities, so that P
α exp Ψ(X → α) =
for all X. Verify that the semiring inside recurrence from Equation . generates
the log-probability log p(w) = log P
τ:yield(τ)=w p(τ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Chapter
Dependency parsing
The previous chapter discussed algorithms for analyzing sentences in terms of nested con-
stituents, such as noun phrases and verb phrases. However, many of the key sources of
ambiguity in phrase-structure analysis relate to questions of attachment: where to attach a
prepositional phrase or complement clause, how to scope a coordinating conjunction, and
so on. These attachment decisions can be represented with a more lightweight structure:
a directed graph over the words in the sentence, known as a dependency parse. Syn-
tactic annotation has shifted its focus to such dependency structures: at the time of this
writing, the Universal Dependencies project offers more than  dependency treebanks
for more than  languages. This chapter will describe the linguistic ideas underlying
dependency grammar, and then discuss exact and transition-based parsing algorithms.
The chapter will also discuss recent research on learning to search in transition-based
structure prediction.
Dependency grammar
While dependency grammar has a rich history of its own (Tesni`ere, ; K¨ubler et al.,
), it can be motivated by extension from the lexicalized context-free grammars that
we encountered in previous chapter (§ ..). Recall that lexicalization augments each
non-terminal with a head word. The head of a constituent is identiﬁed recursively, using
a set of head rules, as shown in Table .. An example of a lexicalized context-free parse
is shown in Figure .a. In this sentence, the head of the S constituent is the main verb,
scratch; this non-terminal then produces the noun phrase the cats, whose head word is
cats, and from which we ﬁnally derive the word the. Thus, the word scratch occupies the
central position for the sentence, with the word cats playing a supporting role. In turn, cats
universaldependencies.org
CHAPTER . DEPENDENCY PARSING
S(scratch)
VP(scratch)
NP(cats)
PP(with)
NNS
NP(people)
DT
VB
NP(claws)
NNS
IN
The
scratch
cats
NNS
with
people
The cats scratch people with claws
claws
(a) lexicalized constituency parse
(b) unlabeled dependency tree
Figure .: Dependency grammar is closely linked to lexicalized context free grammars:
each lexical head has a dependency path to every other word in the constituent. (This
example is based on the lexicalization rules from § .., which make the preposition
the head of a prepositional phrase. In the more contemporary Universal Dependencies
annotations, the head of with claws would be claws, so there would be an edge scratch →
claws.)
occupies the central position for the noun phrase, with the word the playing a supporting
role.
The relationships between words in a sentence can be formalized in a directed graph,
based on the lexicalized phrase-structure parse: create an edge (i, j) iff word i is the head
of a phrase whose child is a phrase headed by word j. Thus, in our example, we would
have scratch → cats and cats → the. We would not have the edge scratch → the, because
although S(scratch) dominates DET(the) in the phrase-structure parse tree, it is not its im-
mediate parent. These edges describe syntactic dependencies, a bilexical relationship
between a head and a dependent, which is at the heart of dependency grammar.
Continuing to build out this dependency graph, we will eventually reach every word
in the sentence, as shown in Figure .b. In this graph — and in all graphs constructed
in this way — every word has exactly one incoming edge, except for the root word, which
is indicated by a special incoming arrow from above. Furthermore, the graph is weakly
connected: if the directed edges were replaced with undirected edges, there would be a
path between all pairs of nodes. From these properties, it can be shown that there are no
cycles in the graph (or else at least one node would have to have more than one incoming
edge), and therefore, the graph is a tree. Because the graph includes all vertices, it is a
spanning tree.
Heads and dependents
A dependency edge implies an asymmetric syntactic relationship between the head and
dependent words, sometimes called modiﬁers. For a pair like the cats or cats scratch, how
Jacob Eisenstein. Draft of November , .

.. DEPENDENCY GRAMMAR
do we decide which is the head? Here are some possible criteria:
The head sets the syntactic category of the construction: for example, nouns are the
heads of noun phrases, and verbs are the heads of verb phrases.
The modiﬁer may be optional while the head is mandatory: for example, in the
sentence cats scratch people with claws, the subtrees cats scratch and cats scratch people
are grammatical sentences, but with claws is not.
The head determines the morphological form of the modiﬁer: for example, in lan-
guages that require gender agreement, the gender of the noun determines the gen-
der of the adjectives and determiners.
Edges should ﬁrst connect content words, and then connect function words.
These guidelines are not universally accepted, and they sometimes conﬂict. The Uni-
versal Dependencies (UD) project has attempted to identify a set of principles that can be
applied to dozens of different languages (Nivre et al., ). These guidelines are based
on the universal part-of-speech tags from chapter . They differ somewhat from the head
rules described in § ..: for example, on the principle that dependencies should relate
content words, the prepositional phrase with claws would be headed by claws, resulting in
an edge scratch → claws, and another edge claws → with.
One objection to dependency grammar is that not all syntactic relations are asymmet-
ric. One such relation is coordination (Popel et al., ): in the sentence, Abigail and Max
like kimchi (Figure .), which word is the head of the coordinated noun phrase Abigail
and Max? Choosing either Abigail or Max seems arbitrary; fairness argues for making and
the head, but this seems like the least important word in the noun phrase, and selecting
it would violate the principle of linking content words ﬁrst. The Universal Dependencies
annotation system arbitrarily chooses the left-most item as the head — in this case, Abigail
— and includes edges from this head to both Max and the coordinating conjunction and.
These edges are distinguished by the labels CONJ (for the thing begin conjoined) and CC
(for the coordinating conjunction). The labeling system is discussed next.
Labeled dependencies
Edges may be labeled to indicate the nature of the syntactic relation that holds between
the two elements. For example, in Figure ., the label NSUBJ on the edge from like to
Abigail indicates that the subtree headed by Abigail is the noun subject of the verb like;
similarly, the label OBJ on the edge from like to kimchi indicates that the subtree headed by
The
latest
and
most
speciﬁc
guidelines
are
available
at
universaldependencies.org/
guidelines.html
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
root
nsubj
conj
conj
cc
obj
cc
advmod
Abigail and Max like kimchi but not jook
Figure .: In the Universal Dependencies annotation system, the left-most item of a
coordination is the head.
punct
conj
cc
root
obj
nsubj
cop
nsubj
compound
compound
advmod
know
New
York
pizza
and
this
is
not
it
Figure .: A labeled dependency parse from the English UD Treebank (reviews--
kimchi is the object. The negation not is treated as an adverbial modiﬁer (ADVMOD) on
the noun jook.
A slightly more complex example is shown in Figure .. The multiword expression
New York pizza is treated as a “ﬂat” unit of text, with the elements linked by the COM-
POUND relation. The sentence includes two clauses that are conjoined in the same way
that noun phrases are conjoined in Figure .. The second clause contains a copula verb
(see § ..). For such clauses, we treat the “object” of the verb as the root — in this case,
it — and label the verb as a dependent, with the COP relation. This example also shows
how punctuations are treated, with label PUNCT.
Dependency subtrees and constituents
Dependency trees hide information that would be present in a CFG parse. Often what
is hidden is in fact irrelevant: for example, Figure . shows three different ways of
Earlier work distinguished direct and indirect objects (De Marneffe and Manning, ), but this has
been dropped in version . of the Universal Dependencies annotation system.
Jacob Eisenstein. Draft of November , .

.. DEPENDENCY GRAMMAR
VP
VP
PP
VP
PP
with a fork
PP
PP
NP
VP
on the table
NP
with a fork
on the table
dinner
ate
(a) Flat
dinner
ate
(b) Chomsky adjunction
VP
PP
PP
VP
with a fork
on the table
NP
ate dinner on the table with a fork
dinner
ate
(c) Two-level (PTB-style)
(d) Dependency representation
Figure .: The three different CFG analyses of this verb phrase all correspond to a single
dependency structure.
representing prepositional phrase adjuncts to the verb ate. Because there is apparently no
meaningful difference between these analyses, the Penn Treebank decides by convention
to use the two-level representation (see Johnson, , for a discussion). As shown in
Figure .d, these three cases all look the same in a dependency parse.
But dependency grammar imposes its own set of annotation decisions, such as the
identiﬁcation of the head of a coordination (§ ..); without lexicalization, context-free
grammar does not require either element in a coordination to be privileged in this way.
Dependency parses can be disappointingly ﬂat: for example, in the sentence Yesterday,
Abigail was reluctantly giving Max kimchi, the root giving is the head of every dependency!
The constituent parse arguably offers a more useful structural analysis for such cases.
Projectivity
Thus far, we have deﬁned dependency trees as spanning trees over a graph
in which each word is a vertex. As we have seen, one way to construct such trees is by
connecting the heads in a lexicalized constituent parse. However, there are spanning trees
that cannot be constructed in this way. Syntactic constituents are contiguous spans. In a
spanning tree constructed from a lexicalized constituent parse, the head h of any con-
stituent that spans the nodes from i to j must have a path to every node in this span. This
is property is known as projectivity, and projective dependency parses are a restricted
class of spanning trees. Informally, projectivity means that “crossing edges” are prohib-
ited. The formal deﬁnition follows:
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
% non-projective edges
% non-projective sentences
Czech
English
German
Table .: Frequency of non-projective dependencies in three languages (Kuhlmann and
Nivre, )
acl:relcl
root
obl:tmod
obj
nsubj
nsubj
det
cop
Lucia ate a pizza yesterday which was vegetarian
Figure .: An example of a non-projective dependency parse. The “crossing edge” arises
from the relative clause which was vegetarian and the oblique temporal modiﬁer yesterday.
Deﬁnition  (Projectivity). An edge from i to j is projective iff all k between i and j are descen-
dants of i. A dependency parse is projective iff all its edges are projective.
Figure . gives an example of a non-projective dependency graph in English. This
dependency graph does not correspond to any constituent parse. As shown in Table .,
non-projectivity is more common in languages such as Czech and German. Even though
relatively few dependencies are non-projective in these languages, many sentences have
at least one such dependency. As we will soon see, projectivity has important algorithmic
consequences.
Graph-based dependency parsing
Let y = {(i r−→ j)} represent a dependency graph, in which each edge is a relation r from
head word i ∈ {, , . . . , M, ROOT} to modiﬁer j ∈ {, , . . . , M}. The special node ROOT
indicates the root of the graph, and M is the length of the input |w|. Given a scoring
function Ψ(y, w; θ), the optimal parse is,
ˆy = argmax
y∈Y(w)
Ψ(y, w; θ),
where Y(w) is the set of valid dependency parses on the input w. As usual, the number
of possible labels |Y(w)| is exponential in the length of the input (Wu and Chao, ).
Jacob Eisenstein. Draft of November , .

.. GRAPH-BASED DEPENDENCY PARSING
First order
Second order
Third order
Figure .: Feature templates for higher-order dependency parsing
Algorithms that search over this space of possible graphs are known as graph-based de-
pendency parsers.
In sequence labeling and constituent parsing, it was possible to search efﬁciently over
an exponential space by choosing a feature function that decomposes into a sum of local
feature vectors. A similar approach is possible for dependency parsing, by requiring the
scoring function to decompose across dependency arcs:
ψ(i r−→ j, w; θ).
Ψ(y, w; θ) =
r−→j∈y
Dependency parsers that operate under this assumption are known as arc-factored, since
the score of a graph is the product of the scores of all arcs.
Higher-order dependency parsing
The arc-factored decomposition can be relaxed to al-
low higher-order dependencies. In second-order dependency parsing, the scoring func-
tion may include grandparents and siblings, as shown by the templates in Figure ..
The scoring function is,
ψparent(i r−→ j, w; θ)
Ψ(y, w; θ) =
r−→j∈y
ψgrandparent(i r−→ j, k, r′, w; θ)
r′−→i∈y
ψsibling(i r−→ j, s, r′, w; θ).
r′−→s∈y
s̸=j
The top line scores computes a scoring function that includes the grandparent k; the
bottom line computes a scoring function for each sibling s. For projective dependency
graphs, there are efﬁcient algorithms for second-order and third-order dependency pars-
ing (Eisner, ; McDonald and Pereira, ; Koo and Collins, ); for non-projective
dependency graphs, second-order dependency parsing is NP-hard (McDonald and Pereira,
). The speciﬁc algorithms are discussed in the next section.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
Graph-based parsing algorithms
The distinction between projective and non-projective dependency trees (§ ..) plays
a key role in the choice of algorithms. Because projective dependency trees are closely
related to (and can be derived from) lexicalized constituent trees, lexicalized parsing al-
gorithms can be applied directly. For the more general problem of parsing to arbitrary
spanning trees, a different class of algorithms is required. In both cases, arc-factored de-
pendency parsing relies on precomputing the scores ψ(i
r−→ j, w; θ) for each potential
edge. There are O(MR) such scores, where M is the length of the input and R is the
number of dependency relation types, and this is a lower bound on the time and space
complexity of any exact algorithm for arc-factored dependency parsing.
Projective dependency parsing
Any lexicalized constituency tree can be converted into a projective dependency tree by
creating arcs between the heads of constituents and their parents, so any algorithm for
lexicalized constituent parsing can be converted into an algorithm for projective depen-
dency parsing, by converting arc scores into scores for lexicalized productions. As noted
in § .., there are cubic time algorithms for lexicalized constituent parsing, which are
extensions of the CKY algorithm. Therefore, arc-factored projective dependency parsing
can be performed in cubic time in the length of the input.
Second-order projective dependency parsing can also be performed in cubic time, with
minimal modiﬁcations to the lexicalized parsing algorithm (Eisner, ). It is possible to
go even further, to third-order dependency parsing, in which the scoring function may
consider great-grandparents, grand-siblings, and “tri-siblings”, as shown in Figure ..
Third-order dependency parsing can be performed in O(M) time, which can be made
practical through the use of pruning to eliminate unlikely edges (Koo and Collins, ).
Non-projective dependency parsing
In non-projective dependency parsing, the goal is to identify the highest-scoring span-
ning tree over the words in the sentence. The arc-factored assumption ensures that the
score for each spanning tree will be computed as a sum over scores for the edges, which
are precomputed. Based on these scores, we build a weighted connected graph. Arc-
factored non-projective dependency parsing is then equivalent to ﬁnding the spanning
tree that achieves the maximum total score, Ψ(y, w) = P
r−→j∈y ψ(i
r−→ j, w). The Chu-
Liu-Edmonds algorithm (Chu and Liu, ; Edmonds, ) computes this maximum
directed spanning tree efﬁciently. It does this by ﬁrst identifying the best incoming edge
r−→ j for each vertex j. If the resulting graph does not contain cycles, it is the maxi-
mum spanning tree. If there is a cycle, it is collapsed into a super-vertex, whose incoming
and outgoing edges are based on the edges to the vertices in the cycle. The algorithm is
Jacob Eisenstein. Draft of November , .

.. GRAPH-BASED DEPENDENCY PARSING
then applied recursively to the resulting graph, and process repeats until a graph without
cycles is obtained.
The time complexity of identifying the best incoming edge for each vertex is O(MR),
where M is the length of the input and R is the number of relations; in the worst case, the
number of cycles is O(M). Therefore, the complexity of the Chu-Liu-Edmonds algorithm
is O(MR). This complexity can be reduced to O(MN) by storing the edge scores in a
Fibonnaci heap (Gabow et al., ). For more detail on graph-based parsing algorithms,
see Eisner () and K¨ubler et al. ().
Higher-order non-projective dependency parsing
Given the tractability of higher-order
projective dependency parsing, you may be surprised to learn that non-projective second-
order dependency parsing is NP-Hard. This can be proved by reduction from the vertex
cover problem (Neuhaus and Br¨oker, ). A heuristic solution is to do projective pars-
ing ﬁrst, and then post-process the projective dependency parse to add non-projective
edges (Nivre and Nilsson, ). More recent work has applied techniques for approxi-
mate inference in graphical models, including belief propagation (Smith and Eisner, ),
integer linear programming (Martins et al., ), variational inference (Martins et al.,
), and Markov Chain Monte Carlo (Zhang et al., ).
Computing scores for dependency arcs
The arc-factored scoring function ψ(i r−→ j, w; θ) can be deﬁned in several ways:
Linear
ψ(i r−→ j, w; θ) = θ  f(i r−→ j, w)
Neural
ψ(i r−→ j, w; θ) = Feedforward([uwi; uwj]; θ)
Generative
ψ(i r−→ j, w; θ) = log p(wj, r | wi).
Linear feature-based arc scores
Linear models for dependency parsing incorporate many of the same features used in
sequence labeling and discriminative constituent parsing. These include:
the length and direction of the arc;
the words wi and wj linked by the dependency relation;
the preﬁxes, sufﬁxes, and parts-of-speech of these words;
the neighbors of the dependency arc, wi−, wi+, wj−, wj+;
the preﬁxes, sufﬁxes, and part-of-speech of these neighbor words.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
Each of these features can be conjoined with the dependency edge label r. Note that
features in an arc-factored parser can refer to words other than wi and wj. The restriction
is that the features consider only a single arc.
Bilexical features (e.g., sushi → chopsticks) are powerful but rare, so it is useful to aug-
ment them with coarse-grained alternatives, by “backing off” to the part-of-speech or
afﬁx. For example, the following features are created by backing off to part-of-speech tags
in an unlabeled dependency parser:
f( −→ , we eat sushi with chopsticks) = ⟨sushi → chopsticks,
sushi → NNS,
NN → chopsticks,
NNS → NN⟩.
Regularized discriminative learning algorithms can then trade off between features at
varying levels of detail. McDonald et al. () take this approach as far as tetralexical
features (e.g., (wi, wi+, wj−, wj)). Such features help to avoid choosing arcs that are un-
likely due to the intervening words: for example, there is unlikely to be an edge between
two nouns if the intervening span contains a verb. A large list of ﬁrst and second-order
features is provided by Bohnet (), who uses a hashing function to store these features
efﬁciently.
Neural arc scores
Given vector representations xi for each word wi in the input, a set of arc scores can be
computed from a feedforward neural network:
ψ(i r−→ j, w; θ) =FeedForward([xi; xj]; θr),
where unique weights θr are available for each arc type (Pei et al., ; Kiperwasser and
Goldberg, ). Kiperwasser and Goldberg () use a feedforward network with a
single hidden layer,
z =g(Θr[xi; xj] + b(z)
r )
ψ(i r−→ j) =βrz + b(y)
r ,
where Θr is a matrix, βr is a vector, each br is a scalar, and the function g is an elementwise
tanh activation function.
The vector xi can be set equal to the word embedding, which may be pre-trained or
learned by backpropagation (Pei et al., ). Alternatively, contextual information can
be incorporated by applying a bidirectional recurrent neural network across the input, as
Jacob Eisenstein. Draft of November , .

.. GRAPH-BASED DEPENDENCY PARSING
described in § .. The RNN hidden states at each word can be used as inputs to the arc
scoring function (Kiperwasser and Goldberg, ).
Feature-based arc scores are computationally expensive, due to the costs of storing
and searching a huge table of weights. Neural arc scores can be viewed as a compact
solution to this problem. Rather than working in the space of tuples of lexical features,
the hidden layers of a feedforward network can be viewed as implicitly computing fea-
ture combinations, with each layer of the network evaluating progressively more words.
An early paper on neural dependency parsing showed substantial speed improvements
at test time, while also providing higher accuracy than feature-based models (Chen and
Manning, ).
Probabilistic arc scores
If each arc score is equal to the log probability log p(wj, r | wi), then the sum of scores
gives the log probability of the sentence and arc labels, by the chain rule. For example,
consider the unlabeled parse of we eat sushi with rice,
y ={(ROOT, ), (, ), (, ), (, ), (, )}
(i→j)∈y
log p(wj | wi)
log p(w | y) =
= log p(eat | ROOT) + log p(we | eat) + log p(sushi | eat)
+ log p(rice | sushi) + log p(with | rice).
Probabilistic generative models are used in combination with expectation-maximization
(chapter ) for unsupervised dependency parsing (Klein and Manning, ).
Learning
Having formulated graph-based dependency parsing as a structure prediction problem,
we can apply similar learning algorithms to those used in sequence labeling. Given a loss
function ℓ(θ; w(i), y(i)), we can compute gradient-based updates to the parameters. For a
model with feature-based arc scores and a perceptron loss, we obtain the usual structured
perceptron update,
ˆy = argmax
y′∈Y(w)
θ  f(w, y′)
θ =θ + f(w, y) − f(w, ˆy)
In this case, the argmax requires a maximization over all dependency trees for the sen-
tence, which can be computed using the algorithms described in § ... We can apply
all the usual tricks from § .: weight averaging, a large margin objective, and regular-
ization. McDonald et al. () were the ﬁrst to treat dependency parsing as a structure
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
prediction problem, using MIRA, an online margin-based learning algorithm. Neural arc
scores can be learned in the same way, backpropagating from a margin loss to updates on
the feedforward network that computes the score for each edge.
A conditional random ﬁeld for arc-factored dependency parsing is built on the proba-
bility model,
r−→j∈y ψ(i r−→ j, w; θ)
p(y | w) =
exp P
r−→j∈y′ ψ(i r−→ j, w; θ)
y′∈Y(w) exp P
Such a model is trained to minimize the negative log conditional-likelihood. Just as in
CRF sequence models (§ ..) and the logistic regression classiﬁer (§ .), the gradients
involve marginal probabilities p(i
r−→ j | w; θ), which in this case are probabilities over
individual dependencies. In arc-factored models, these probabilities can be computed
in polynomial time. For projective dependency trees, the marginal probabilities can be
computed in cubic time, using a variant of the inside-outside algorithm (Lari and Young,
). For non-projective dependency parsing, marginals can also be computed in cubic
time, using the matrix-tree theorem (Koo et al., ; McDonald et al., ; Smith and
Smith, ). Details of these methods are described by K¨ubler et al. ().
Transition-based dependency parsing
Graph-based dependency parsing offers exact inference, meaning that it is possible to re-
cover the best-scoring parse for any given model. But this comes at a price: the scoring
function is required to decompose into local parts — in the case of non-projective parsing,
these parts are restricted to individual arcs. These limitations are felt more keenly in de-
pendency parsing than in sequence labeling, because second-order dependency features
are critical to correctly identify some types of attachments. For example, prepositional
phrase attachment depends on the attachment point, the object of the preposition, and
the preposition itself; arc-factored scores cannot account for all three of these features si-
multaneously. Graph-based dependency parsing may also be criticized on the basis of
intuitions about human language processing: people read and listen to sentences sequen-
tially, incrementally building mental models of the sentence structure and meaning before
getting to the end (Jurafsky, ). This seems hard to reconcile with graph-based algo-
rithms, which perform bottom-up operations on the entire sentence, requiring the parser
to keep every word in memory. Finally, from a practical perspective, graph-based depen-
dency parsing is relatively slow, running in cubic time in the length of the input.
Transition-based algorithms address all three of these objections. They work by mov-
ing through the sentence sequentially, while performing actions that incrementally up-
date a stored representation of what has been read thus far. As with the shift-reduce
Jacob Eisenstein. Draft of November , .

.. TRANSITION-BASED DEPENDENCY PARSING
parser from § .., this representation consists of a stack, onto which parsing substruc-
tures can be pushed and popped. In shift-reduce, these substructures were constituents;
in the transition systems that follow, they will be projective dependency trees over partial
spans of the input. Parsing is complete when the input is consumed and there is only
a single structure on the stack. The sequence of actions that led to the parse is known as
the derivation. One problem with transition-based systems is that there may be multiple
derivations for a single parse structure — a phenomenon known as spurious ambiguity.
Transition systems for dependency parsing
A transition system consists of a representation for describing conﬁgurations of the parser,
and a set of transition actions, which manipulate the conﬁguration. There are two main
transition systems for dependency parsing: arc-standard, which is closely related to shift-
reduce, and arc-eager, which adds an additional action that can simplify derivations (Ab-
ney and Johnson, ). In both cases, transitions are between conﬁgurations that are
represented as triples, C = (σ, β, A), where σ is the stack, β is the input buffer, and A is
the list of arcs that have been created (Nivre, ). In the initial conﬁguration,
Cinitial = ([ROOT], w, ∅),
indicating that the stack contains only the special node ROOT, the entire input is on the
buffer, and the set of arcs is empty. An accepting conﬁguration is,
Caccept = ([ROOT], ∅, A),
where the stack contains only ROOT, the buffer is empty, and the arcs A deﬁne a spanning
tree over the input. The arc-standard and arc-eager systems deﬁne a set of transitions
between conﬁgurations, which are capable of transforming an initial conﬁguration into
an accepting conﬁguration. In both of these systems, the number of actions required to
parse an input grows linearly in the length of the input, making transition-based parsing
considerably more efﬁcient than graph-based methods.
Arc-standard
The arc-standard transition system is closely related to shift-reduce, and to the LR algo-
rithm that is used to parse programming languages (Aho et al., ). It includes the
following classes of actions:
SHIFT: move the ﬁrst item from the input buffer on to the top of the stack,
(σ, i|β, A) ⇒ (σ|i, β, A),
Transition systems also exist for non-projective dependency parsing (e.g., Nivre, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
where we write i|β to indicate that i is the leftmost item in the input buffer, and σ|i
to indicate the result of pushing i on to stack σ.
ARC-LEFT: create a new left-facing arc of type r between the item on the top of the
stack and the ﬁrst item in the input buffer. The head of this arc is j, which remains
at the front of the input buffer. The arc j
r−→ i is added to A. Formally,
(σ|i, j|β, A) ⇒ (σ, j|β, A ⊕ j
r−→ i),
where r is the label of the dependency arc, and ⊕ concatenates the new arc j
r−→ i to
the list A.
ARC-RIGHT: creates a new right-facing arc of type r between the item on the top of
the stack and the ﬁrst item in the input buffer. The head of this arc is i, which is
“popped” from the stack and pushed to the front of the input buffer. The arc i r−→ j
is added to A. Formally,
(σ|i, j|β, A) ⇒ (σ, i|β, A ⊕ i r−→ j),
where again r is the label of the dependency arc.
Each action has preconditions. The SHIFT action can be performed only when the buffer
has at least one element. The ARC-LEFT action cannot be performed when the root node
ROOT is on top of the stack, since this node must be the root of the entire tree. The ARC-
LEFT and ARC-RIGHT remove the modiﬁer words from the stack (in the case of ARC-LEFT)
and from the buffer (in the case of ARC-RIGHT), so it is impossible for any word to have
more than one parent. Furthermore, the end state can only be reached when every word is
removed from the buffer and stack, so the set of arcs is guaranteed to constitute a spanning
tree. An example arc-standard derivation is shown in Table ..
Arc-eager dependency parsing
In the arc-standard transition system, a word is completely removed from the parse once
it has been made the modiﬁer in a dependency arc. At this time, any dependents of
this word must have already been identiﬁed. Right-branching structures are common in
English (and many other languages), with words often modiﬁed by units such as prepo-
sitional phrases to their right. In the arc-standard system, this means that we must ﬁrst
shift all the units of the input onto the stack, and then work backwards, creating a series of
arcs, as occurs in Table .. Note that the decision to shift bagels onto the stack guarantees
that the prepositional phrase with lox will attach to the noun phrase, and that this decision
must be made before the prepositional phrase is itself parsed. This has been argued to be
cognitively implausible (Abney and Johnson, ); from a computational perspective, it
means that a parser may need to look several steps ahead to make the correct decision.
Jacob Eisenstein. Draft of November , .

.. TRANSITION-BASED DEPENDENCY PARSING
action
arc added to A
[ROOT]
they like bagels with lox
SHIFT
[ROOT, they]
like bagels with lox
ARC-LEFT
(they ← like)
[ROOT]
like bagels with lox
SHIFT
[ROOT, like]
bagels with lox
SHIFT
[ROOT, like, bagels]
with lox
SHIFT
[ROOT, like, bagels, with]
lox
ARC-LEFT
(with ← lox)
[ROOT, like, bagels]
lox
ARC-RIGHT
(bagels → lox)
[ROOT, like]
bagels
ARC-RIGHT
(like → bagels)
[ROOT]
like
ARC-RIGHT
(ROOT → like)
[ROOT]
DONE
Table .: Arc-standard derivation of the unlabeled dependency parse for the input they
like bagels with lox.
Arc-eager dependency parsing changes the ARC-RIGHT action so that right depen-
dents can be attached before all of their dependents have been found. Rather than re-
moving the modiﬁer from both the buffer and stack, the ARC-RIGHT action pushes the
modiﬁer on to the stack, on top of the head. Because the stack can now contain elements
that already have parents in the partial dependency graph, two additional changes are
necessary:
A precondition is required to ensure that the ARC-LEFT action cannot be applied
when the top element on the stack already has a parent in A.
A new REDUCE action is introduced, which can remove elements from the stack if
they already have a parent in A:
(σ|i, β, A) ⇒ (σ, β, A).
As a result of these changes, it is now possible to create the arc like → bagels before parsing
the prepositional phrase with lox. Furthermore, this action does not imply a decision about
whether the prepositional phrase will attach to the noun or verb. Noun attachment is
chosen in the parse in Table ., but verb attachment could be achieved by applying the
REDUCE action at step  or .
Projectivity
The arc-standard and arc-eager transition systems are guaranteed to produce projective
dependency trees, because all arcs are between the word at the top of the stack and the
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
action
arc added to A
[ROOT]
they like bagels with lox
SHIFT
[ROOT, they]
like bagels with lox
ARC-LEFT
(they ← like)
[ROOT]
like bagels with lox
ARC-RIGHT
(ROOT → like)
[ROOT, like]
bagels with lox
ARC-RIGHT
(like → bagels)
[ROOT, like, bagels]
with lox
SHIFT
[ROOT, like, bagels, with]
lox
ARC-LEFT
(with ← lox)
[ROOT, like, bagels]
lox
ARC-RIGHT
(bagels → lox)
[ROOT, like, bagels, lox]
REDUCE
[ROOT, like, bagels]
REDUCE
[ROOT, like]
REDUCE
[ROOT]
DONE
Table .: Arc-eager derivation of the unlabeled dependency parse for the input they like
bagels with lox.
left-most edge of the buffer (Nivre, ). Non-projective transition systems can be con-
structed by adding actions that create arcs with words that are second or third in the
stack (Attardi, ), or by adopting an alternative conﬁguration structure, which main-
tains a list of all words that do not yet have heads (Covington, ). In pseudo-projective
dependency parsing, a projective dependency parse is generated ﬁrst, and then a set of
graph transformation techniques are applied, producing non-projective edges (Nivre and
Nilsson, ).
Beam search
In “greedy” transition-based parsing, the parser tries to make the best decision at each
conﬁguration. This can lead to search errors, when an early decision locks the parser into
a poor derivation. For example, in Table ., if ARC-RIGHT were chosen at step , then
the parser would later be forced to attach the prepositional phrase with lox to the verb
likes. Note that the likes → bagels arc is indeed part of the correct dependency parse, but
the arc-standard transition system requires it to be created later in the derivation.
Beam search is a general technique for ameliorating search errors in incremental de-
coding. While searching, the algorithm maintains a set of partially-complete hypotheses,
called a beam. At step t of the derivation, there is a set of k hypotheses, each of which
Beam search is used throughout natural language processing, and beyond. In this text, it appears again
in coreference resolution (§ ..) and machine translation (§ .).
Jacob Eisenstein. Draft of November , .

.. TRANSITION-BASED DEPENDENCY PARSING
t =
t =
t =
t =
t =
Shift
Arc-Right
Arc-Right
Arc-Right

[Root]
they can ﬁsh

[Root, they]
can ﬁsh

[Root, they]
ﬁsh

[Root, can]

[Root]

Arc-Left
Arc-Left
Arc-Right
[Root, can]
ﬁsh

[Root, ﬁsh]

[Root]

Figure .: Beam search for unlabeled dependency parsing, with beam size K = . The
arc lists for each conﬁguration are not shown, but can be computed from the transitions.
includes a score s(k)
and a set of dependency arcs A(k)
t :
h(k)
= (s(k)
t , A(k)
t )
Each hypothesis is then “expanded” by considering the set of all valid actions from the
current conﬁguration c(k)
t , written A(c(k)
t ). This yields a large set of new hypotheses. For
each action a ∈ A(c(k)
t ), we score the new hypothesis A(k)
⊕ a. The top k hypotheses
by this scoring metric are kept, and parsing proceeds to the next step (Zhang and Clark,
). Note that beam search requires a scoring function for action sequences, rather than
individual actions. This issue will be revisited in the next section.
Figure . shows the application of beam search to dependency parsing, with a beam
size of K = . For the ﬁrst transition, the only valid action is SHIFT, so there is only
one possible conﬁguration at t = . From this conﬁguration, there are three possible
actions. The two best scoring actions are ARC-RIGHT and ARC-LEFT, and so the resulting
hypotheses from these actions are on the beam at t = . From these conﬁgurations, there
are three possible actions each, but the best two are expansions of the bottom hypothesis
at t = . Parsing continues until t = , at which point both hypotheses reach an accepting
state. The best-scoring hypothesis is then selected as the parse.
Scoring functions for transition-based parsers
Transition-based parsing requires selecting a series of actions. In greedy transition-based
parsing, this can be done by training a classiﬁer,
ˆa = argmax
a∈A(c)
Ψ(a, c, w; θ),
where A(c) is the set of admissible actions in the current conﬁguration c, w is the input,
and Ψ is a scoring function with parameters θ (Yamada and Matsumoto, ).
A feature-based score can be computed, Ψ(a, c, w) = θ  f(a, c, w), using features that
may consider any aspect of the current conﬁguration and input sequence. Typical features
for transition-based dependency parsing include: the word and part-of-speech of the top
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
element on the stack; the word and part-of-speech of the ﬁrst, second, and third elements
on the input buffer; pairs and triples of words and parts-of-speech from the top of the
stack and the front of the buffer; the distance (in tokens) between the element on the top
of the stack and the element in the front of the input buffer; the number of modiﬁers of
each of these elements; and higher-order dependency features as described above in the
section on graph-based dependency parsing (see, e.g., Zhang and Nivre, ).
Parse actions can also be scored by neural networks. For example, Chen and Manning
() build a feedforward network in which the input layer consists of the concatenation
of embeddings of several words and tags:
the top three words on the stack, and the ﬁrst three words on the buffer;
the ﬁrst and second leftmost and rightmost children (dependents) of the top two
words on the stack;
the leftmost and right most grandchildren of the top two words on the stack;
embeddings of the part-of-speech tags of these words.
Let us call this base layer x(c, w), deﬁned as,
c =(σ, β, A)
x(c, w) =[vwσ, vtσvwσ, vtσ, vwσ, vtσ, vwβ, vtβ, vwβ, vtβ, . . .],
where vwσ is the embedding of the ﬁrst word on the stack, vtβ is the embedding of the
part-of-speech tag of the second word on the buffer, and so on. Given this base encoding
of the parser state, the score for the set of possible actions is computed through a feedfor-
ward network,
z =g(Θ(x→z)x(c, w))
ψ(a, c, w; θ) =Θ(z→y)
z,
where the vector z plays the same role as the features f(a, c, w), but is a learned represen-
tation. Chen and Manning () use a cubic elementwise activation function, g(x) = x,
so that the hidden layer models products across all triples of input features. The learning
algorithm updates the embeddings as well as the parameters of the feedforward network.
Learning to parse
Transition-based dependency parsing suffers from a mismatch between the supervision,
which comes in the form of dependency trees, and the classiﬁer’s prediction space, which
is a set of parsing actions. One solution is to create new training data by converting parse
trees into action sequences; another is to derive supervision directly from the parser’s
performance.
Jacob Eisenstein. Draft of November , .

.. TRANSITION-BASED DEPENDENCY PARSING
Oracle-based training
A transition system can be viewed as a function from action sequences (derivations) to
parse trees. The inverse of this function is a mapping from parse trees to derivations,
which is called an oracle. For the arc-standard and arc-eager parsing system, an oracle can
be computed in linear time in the length of the derivation (K¨ubler et al., , page ).
Both the arc-standard and arc-eager transition systems suffer from spurious ambiguity:
there exist dependency parses for which multiple derivations are possible, such as  ←
→ .The oracle must choose between these different derivations. For example, the
algorithm described by K¨ubler et al. () would ﬁrst create the left arc ( ← ), and then
create the right arc, ( ← ) → ; another oracle might begin by shifting twice, resulting
in the derivation  ← ( → ).
Given such an oracle, a dependency treebank can be converted into a set of oracle ac-
tion sequences {A(i)}N
i=. The parser can be trained by stepping through the oracle action
sequences, and optimizing on an classiﬁcation-based objective that rewards selecting the
oracle action. For transition-based dependency parsing, maximum conditional likelihood
is a typical choice (Chen and Manning, ; Dyer et al., ):
p(a | c, w) =
exp Ψ(a, c, w; θ)
a′∈A(c) exp Ψ(a′, c, w; θ)
ˆθ = argmax
t=
log p(a(i)
| c(i)
t , w),
i=
|A(i)|
where |A(i)| is the length of the action sequence A(i).
Recall that beam search requires a scoring function for action sequences. Such a score
can be obtained by adding the log-likelihoods (or hinge losses) across all actions in the
sequence (Chen and Manning, ).
Global objectives
The objective in Equation . is locally-normalized: it is the product of normalized
probabilities over individual actions. A similar characterization could be made of non-
probabilistic algorithms in which hinge-loss objectives are summed over individual ac-
tions. In either case, training on individual actions can be sub-optimal with respect to
global performance, due to the label bias problem (Lafferty et al., ; Andor et al.,
As a stylized example, suppose that a given conﬁguration appears  times in the
training data, with action a as the oracle action in  cases, and a as the oracle action in
the other  cases. However, in cases where a is correct, choosing a results in a cascade
of subsequent errors, while in cases where a is correct, choosing a results in only a single
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
error. A classiﬁer that is trained on a local objective function will learn to always choose
a, but choosing a would minimize the overall number of errors.
This observation motivates a global objective, such as the globally-normalized condi-
tional likelihood,
p(A(i) | w; θ) =
exp P|A(i)|
t= Ψ(a(i)
t , c(i)
t , w)
A′∈A(w) exp P|A′|
t= Ψ(a′
t, c′
t, w)
where the denominator sums over the set of all possible action sequences, A(w). In the
conditional random ﬁeld model for sequence labeling (§ ..), it was possible to compute
this sum explicitly, using dynamic programming. In transition-based parsing, this is not
possible. However, the sum can be approximated using beam search,
t=
Ψ(a′
t, c′
t, w) ≈
t=
Ψ(a(k)
t , c(k)
t , w),
k=
exp
A′∈A(w)
exp
|A′|
|A(k)|
where A(k) is an action sequence on a beam of size K. This gives rise to the following loss
function,
L(θ) = −
t=
Ψ(a(k)
t , c(k)
t , w).
t=
Ψ(a(i)
t , c(i)
t , w) + log
k=
exp
|A(k)|
|A(i)|
The derivatives of this loss involve expectations with respect to a probability distribution
over action sequences on the beam.
*Early update and the incremental perceptron
When learning in the context of beam search, the goal is to learn a decision function so that
the gold dependency parse is always reachable from at least one of the partial derivations
on the beam. (The combination of a transition system (such as beam search) and a scoring
function for actions is known as a policy.) To achieve this, we can make an early update
as soon as the oracle action sequence “falls off” the beam, even before a complete analysis
is available (Collins and Roark, ; Daum´e III and Marcu, ). The loss can be based
on the best-scoring hypothesis on the beam, or the sum of all hypotheses (Huang et al.,
For example, consider the beam search in Figure .. In the correct parse, ﬁsh is the
head of dependency arcs to both of the other two words. In the arc-standard system,
Andor et al. () prove that the set of globally-normalized conditional distributions is a strict superset
of the set of locally-normalized conditional distributions, and that globally-normalized conditional models
are therefore strictly more expressive.
Jacob Eisenstein. Draft of November , .

.. APPLICATIONS
this can be achieved only by using SHIFT for the ﬁrst two actions. At t = , the oracle
action sequence has fallen off the beam. The parser should therefore stop, and update the
parameters by the gradient ∂
∂θL(A(i)
:, {A(k)
:}; θ), where A(i)
: is the ﬁrst three actions of the
oracle sequence, and {A(k)
:} is the beam.
This integration of incremental search and learning was ﬁrst developed in the incre-
mental perceptron (Collins and Roark, ). This method updates the parameters with
respect to a hinge loss, which compares the top-scoring hypothesis and the gold action
sequence, up to the current point t. Several improvements to this basic protocol are pos-
sible:
As noted earlier, the gold dependency parse can be derived by multiple action se-
quences. Rather than checking for the presence of a single oracle action sequence on
the beam, we can check if the gold dependency parse is reachable from the current
beam, using a dynamic oracle (Goldberg and Nivre, ).
By maximizing the score of the gold action sequence, we are training a decision
function to ﬁnd the correct action given the gold context. But in reality, the parser
will make errors, and the parser is not trained to ﬁnd the best action given a context
that may not itself be optimal. This issue is addressed by various generalizations of
incremental perceptron, known as learning to search (Daum´e III et al., ). Some
of these methods are discussed in chapter .
Applications
Dependency parsing is used in many real-world applications: any time you want to know
about pairs of words which might not be adjacent, you can use dependency arcs instead
of regular expression search patterns. For example, you may want to match strings like
delicious pastries, delicious French pastries, and the pastries are delicious.
It is possible to search the Google n-grams corpus by dependency edges, ﬁnding the
trend in how often a dependency edge appears over time. For example, we might be inter-
ested in knowing when people started talking about writing code, but we also want write
some code, write good code, write all the code, etc. The result of a search on the dependency
edge write → code is shown in Figure .. This capability has been applied to research
in digital humanities, such as the analysis of gender in Shakespeare Muralidharan and
Hearst ().
A classic application of dependency parsing is relation extraction, which is described
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
Figure .: Google n-grams results for the bigram write code and the dependency arc write
=> code (and their morphological variants)
in chapter . The goal of relation extraction is to identify entity pairs, such as
(MELVILLE, MOBY-DICK)
(TOLSTOY, WAR AND PEACE)
(MARQU´EZ,  YEARS OF SOLITUDE)
(SHAKESPEARE, A MIDSUMMER NIGHT’S DREAM),
which stand in some relation to each other (in this case, the relation is authorship). Such
entity pairs are often referenced via consistent chains of dependency relations. Therefore,
dependency paths are often a useful feature in supervised systems which learn to detect
new instances of a relation, based on labeled examples of other instances of the same
relation type (Culotta and Sorensen, ; Fundel et al., ; Mintz et al., ).
Cui et al. () show how dependency parsing can improve automated question an-
swering. Suppose you receive the following query:
What percentage of the nation’s cheese does Wisconsin produce?
The corpus contains this sentence:
In Wisconsin, where farmers produce % of the nation’s cheese, ...
The location of Wisconsin in the surface form of this string makes it a poor match for the
query. However, in the dependency graph, there is an edge from produce to Wisconsin in
both the question and the potential answer, raising the likelihood that this span of text is
relevant to the question.
A ﬁnal example comes from sentiment analysis. As discussed in chapter , the polarity
of a sentence can be reversed by negation, e.g.
Jacob Eisenstein. Draft of November , .

.. APPLICATIONS
There is no reason at all to believe the polluters will suddenly become reasonable.
By tracking the sentiment polarity through the dependency parse, we can better iden-
tify the overall polarity of the sentence, determining when key sentiment words are re-
versed (Wilson et al., ; Nakagawa et al., ).
Additional resources
More details on dependency grammar and parsing algorithms can be found in the manuscript
by K¨ubler et al. (). For a comprehensive but whimsical overview of graph-based de-
pendency parsing algorithms, see Eisner (). Jurafsky and Martin () describe an
agenda-based version of beam search, in which the beam contains hypotheses of varying
lengths. New hypotheses are added to the beam only if their score is better than the worst
item currently on the beam. Another search algorithm for transition-based parsing is
easy-ﬁrst, which abandons the left-to-right traversal order, and adds the highest-scoring
edges ﬁrst, regardless of where they appear (Goldberg and Elhadad, ). Goldberg et al.
() note that although transition-based methods can be implemented in linear time in
the length of the input, na¨ıve implementations of beam search will require quadratic time,
due to the cost of copying each hypothesis when it is expanded on the beam. This issue
can be addressed by using a more efﬁcient data structure for the stack.
Exercises
. The dependency structure  ←  → , with  as the root, can be obtained from more
than one set of actions in arc-standard parsing. List both sets of actions that can
obtain this parse. Don’t forget about the edge ROOT → .
. This problem develops the relationship between dependency parsing and lexical-
ized context-free parsing. Suppose you have a set of unlabeled arc scores {ψ(i →
j)}M
i,j= ∪ {ψ(ROOT → j)}M
j=.
a) Assuming each word type occurs no more than once in the input ((i ̸= j) ⇒
(wi ̸= wj)), how would you construct a weighted lexicalized context-free gram-
mar so that the score of any projective dependency tree is equal to the score of
some equivalent derivation in the lexicalized context-free grammar?
b) Verify that your method works for the example They ﬁsh.
c) Does your method require the restriction that each word type occur no more
than once in the input? If so, why?
d) *If your method required that each word type occur only once in the input,
show how to generalize it.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DEPENDENCY PARSING
. In arc-factored dependency parsing of an input of length M, the score of a parse
is the sum of M scores, one for each arc. In second order dependency parsing, the
total score is the sum over many more terms. How many terms are the score of the
parse for Figure ., using a second-order dependency parser with grandparent
and sibling features? Assume that a child of ROOT has no grandparent score, and
that a node with no siblings has no sibling scores.
a) In the worst case, how many terms can be involved in the score of an input of
length M, assuming second-order dependency parsing? Describe the structure
of the worst-case parse. As in the previous problem, assume that there is only
one child of ROOT, and that it does not have any grandparent scores.
b) What about third-order dependency parsing?
. Provide the UD-style unlabeled dependency parse for the sentence Xi-Lan eats shoots
and leaves, assuming shoots is a noun and leaves is a verb. Provide arc-standard and
arc-eager derivations for this dependency parse.
. Compute an upper bound on the number of successful derivations in arc-standard
shift-reduce parsing for unlabeled dependencies, as a function of the length of the
input, M. Hint: a lower bound is the number of projective decision trees,
(a−b)!b!.
M+
 M−
M−
(Zhang,
), where
 a
a!
. The label bias problem arises when a decision is locally correct, yet leads to a cas-
cade of errors in some situations (§ ..). Design a scenario in which this occurs.
Speciﬁcally:
Assume an arc-standard dependency parser, whose action classiﬁer considers
only the words at the top of the stack and at the front of the input buffer.
Design two examples, which both involve a decision with identical features.
– In one example, shift is the correct decision; in the other example, arc-left
or arc-right is the correct decision.
– In one of the two examples, a mistake should lead to at least two attach-
ment errors.
– In the other example, a mistake should lead only to a single attachment
error.
For the following exercises, run a dependency parser, such as Stanford’s CoreNLP
parser, on a large corpus of text (at least  tokens), such as nltk.corpus.webtext.
. The dependency relation NMOD:POSS indicates possession. Compute the top ten
words most frequently possessed by each of the following pronouns: his, her, our,
my, your, and their (inspired by Muralidharan and Hearst, ).
Jacob Eisenstein. Draft of November , .

.. APPLICATIONS
. Count all pairs of words grouped by the CONJ relation. Select all pairs of words (i, j)
for which i and j each participate in CONJ relations at least ﬁve times. Compute and
sort by the pointwise mutual information, which is deﬁned in § . as,
PMI(i, j) = log p(i, j)
p(i)p(j).
Here, p(i) is the fraction of CONJ relations containing word i (in either position), and
p(i, j) is the fraction of such relations linking i and j (in any order).
. In § ., we encountered lexical semantic relationships such as synonymy (same
meaning), antonymy (opposite meaning), and hypernymy (i is a special case of
j). Another relevant relation is co-hypernymy, which means that i and j share a
hypernym. Of the top  pairs identiﬁed by PMI in the previous problem, how many
participate in synsets that are linked by one of these four relations? Use WORDNET
to check for these relations, and count a pair of words if any of their synsets are
linked.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Part III
Meaning
Chapter
Logical semantics
The previous few chapters have focused on building systems that reconstruct the syntax
of natural language — its structural organization — through tagging and parsing. But
some of the most exciting and promising potential applications of language technology
involve going beyond syntax to semantics — the underlying meaning of the text:
Answering questions, such as where is the nearest coffeeshop? or what is the middle name
of the mother of the th President of the United States?.
Building a robot that can follow natural language instructions to execute tasks.
Translating a sentence from one language into another, while preserving the under-
lying meaning.
Fact-checking an article by searching the web for contradictory evidence.
Logic-checking an argument by identifying contradictions, ambiguity, and unsup-
ported assertions.
Semantic analysis involves converting natural language into a meaning representa-
tion. To be useful, a meaning representation must meet several criteria:
c: it should be unambiguous: unlike natural language, there should be exactly one
meaning per statement;
c: it should provide a way to link language to external knowledge, observations,
and actions;
c: it should support computational inference, so that meanings can be combined
to derive additional knowledge;
c: it should be expressive enough to cover the full range of things that people talk
about in natural language.
CHAPTER . LOGICAL SEMANTICS
Much more than this can be said about the question of how best to represent knowledge
for computation (e.g., Sowa, ), but this chapter will focus on these four criteria.
Meaning and denotation
The ﬁrst criterion for a meaning representation is that statements in the representation
should be unambiguous — they should have only one possible interpretation. Natural
language does not have this property: as we saw in chapter , sentences like cats scratch
people with claws have multiple interpretations.
But what does it mean for a statement to be unambiguous? Programming languages
provide a useful example: the output of a program is completely speciﬁed by the rules of
the language and the properties of the environment in which the program is run. For ex-
ample, the python code  +  will have the output , as will the codes (*)-(*)+
and (()). This output is known as the denotation of the program, and can be written
as,
J+K = J(*)-(*)+K = J(())K = .
The denotations of these arithmetic expressions are determined by the meaning of the
constants (e.g., , ) and the relations (e.g., +, *, (, )). Now let’s consider another snippet
of python code, double(). The denotation of this code could be, Jdouble()K = , or
it could be Jdouble()K =  — it depends on the meaning of double. This meaning
is deﬁned in a world model M as an inﬁnite set of pairs. We write the denotation with
respect to model M as JKM, e.g., JdoubleKM = {(,), (,), (,), . . .}. The world
model would also deﬁne the (inﬁnite) list of constants, e.g., {,,,...}. As long as the
denotation of string φ in model M can be computed unambiguously, the language can be
said to be unambiguous.
This approach to meaning is known as model-theoretic semantics, and it addresses
not only criterion c (no ambiguity), but also c (connecting language to external knowl-
edge, observations, and actions). For example, we can connect a representation of the
meaning of a statement like the capital of Georgia with a world model that includes knowl-
edge base of geographical facts, obtaining the denotation Atlanta. We might populate a
world model by detecting and analyzing the objects in an image, and then use this world
model to evaluate propositions like a man is riding a moose. Another desirable property of
model-theoretic semantics is that when the facts change, the denotations change too: the
meaning representation of President of the USA would have a different denotation in the
model M as it would in M.
Jacob Eisenstein. Draft of November , .

.. LOGICAL REPRESENTATIONS OF MEANING
Logical representations of meaning
Criterion c requires that the meaning representation support inference — for example,
automatically deducing new facts from known premises. While many representations
have been proposed that meet these criteria, the most mature is the language of ﬁrst-order
logic.
Propositional logic
The bare bones of logical meaning representation are Boolean operations on propositions:
Propositional symbols. Greek symbols like φ and ψ will be used to represent proposi-
tions, which are statements that are either true or false. For example, φ may corre-
spond to the proposition, bagels are delicious.
Boolean operators. We can build up more complex propositional formulas from Boolean
operators. These include:
Negation ¬φ, which is true if φ is false.
Conjunction, φ ∧ ψ, which is true if both φ and ψ are true.
Disjunction, φ ∨ ψ, which is true if at least one of φ and ψ is true
Implication, φ ⇒ ψ, which is true unless φ is true and ψ is false. Implication
has identical truth conditions to ¬φ ∨ ψ.
Equivalence, φ ⇔ ψ, which is true if φ and ψ are both true or both false. Equiv-
alence has identical truth conditions to (φ ⇒ ψ) ∧ (ψ ⇒ φ).
It is not strictly necessary to have all ﬁve Boolean operators: readers familiar with
Boolean logic will know that it is possible to construct all other operators from either the
NAND (not-and) or NOR (not-or) operators. Nonetheless, it is clearest to use all ﬁve
operators. From the truth conditions for these operators, it is possible to deﬁne a number
of “laws” for these Boolean operators, such as,
Commutativity: φ ∧ ψ = ψ ∧ φ,
φ ∨ ψ = ψ ∨ φ
Associativity: φ ∧ (ψ ∧ χ) = (φ ∧ ψ) ∧ χ,
φ ∨ (ψ ∨ χ) = (φ ∨ ψ) ∨ χ
Complementation: φ ∧ ¬φ = ⊥,
φ ∨ ¬φ = ⊤, where ⊤ indicates a true proposition
and ⊥ indicates a false proposition.
Alternatives include the “variable-free” representation used in semantic parsing of geographical
queries (Zelle and Mooney, ) and robotic control (Ge and Mooney, ), and dependency-based com-
positional semantics (Liang et al., ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
These laws can be combined to derive further equivalences, which can support logical
inferences. For example, suppose φ = The music is loud and ψ = Max can’t sleep. Then if
we are given,
φ ⇒ ψ
If the music is loud, Max can’t sleep.
The music is loud.
we can derive ψ (Max can’t sleep) by application of modus ponens, which is one of a
set of inference rules that can be derived from more basic laws and used to manipulate
propositional formulas. Automated theorem provers are capable of applying inference
rules to a set of premises to derive desired propositions (Loveland, ).
First-order logic
Propositional logic is so named because it treats propositions as its base units. However,
the criterion c states that our meaning representation should be sufﬁciently expressive.
Now consider the sentence pair,
If anyone is making noise, then Max can’t sleep.
Abigail is making noise.
People are capable of making inferences from this sentence pair, but such inferences re-
quire formal tools that are beyond propositional logic. To understand the relationship
between the statement anyone is making noise and the statement Abigail is making noise, our
meaning representation requires the additional machinery of ﬁrst-order logic (FOL).
In FOL, logical propositions can be constructed from relationships between entities.
Speciﬁcally, FOL extends propositional logic with the following classes of terms:
Constants. These are elements that name individual entities in the model, such as MAX
and ABIGAIL. The denotation of each constant in a model M is an element in the
model, e.g., JMAXK = m and JABIGAILK = a.
Relations. Relations can be thought of as sets of entities, or sets of tuples. For example,
the relation CAN-SLEEP is deﬁned as the set of entities who can sleep, and has the
denotation JCAN-SLEEPK = {a, m, . . .}. To test the truth value of the proposition
CAN-SLEEP(MAX), we ask whether JMAXK ∈ JCAN-SLEEPK. Logical relations that are
deﬁned over sets of entities are sometimes called properties.
Jacob Eisenstein. Draft of November , .
Relations may also be ordered tuples of entities. For example BROTHER(MAX,ABIGAIL)
expresses the proposition that MAX is the brother of ABIGAIL. The denotation of
such relations is a set of tuples, JBROTHERK = {(m,a), (x,y), . . .}. To test the
truth value of the proposition BROTHER(MAX,ABIGAIL), we ask whether the tuple
(JMAXK, JABIGAILK) is in the denotation JBROTHERK.

.. LOGICAL REPRESENTATIONS OF MEANING
Using constants and relations, it is possible to express statements like Max can’t sleep
and Max is Abigail’s brother:
¬CAN-SLEEP(MAX)
BROTHER(MAX,ABIGAIL).
These statements can also be combined using Boolean operators, such as,
(BROTHER(MAX,ABIGAIL) ∨ BROTHER(MAX,STEVE)) ⇒ ¬CAN-SLEEP(MAX).
This fragment of ﬁrst-order logic permits only statements about speciﬁc entities. To
support inferences about statements like If anyone is making noise, then Max can’t sleep,
two more elements must be added to the meaning representation:
Variables. Variables are mechanisms for referring to entities that are not locally speciﬁed.
We can then write CAN-SLEEP(x) or BROTHER(x, ABIGAIL). In these cases, x is a free
variable, meaning that we have not committed to any particular assignment.
Quantiﬁers. Variables are bound by quantiﬁers. There are two quantiﬁers in ﬁrst-order
logic.
The existential quantiﬁer ∃, which indicates that there must be at least one en-
tity to which the variable can bind. For example, the statement ∃xMAKES-NOISE(X)
indicates that there is at least one entity for which MAKES-NOISE is true.
The universal quantiﬁer ∀, which indicates that the variable must be able to
bind to any entity in the model. For example, the statement,
MAKES-NOISE(ABIGAIL) ⇒ (∀x¬CAN-SLEEP(x))
asserts that if Abigail makes noise, no one can sleep.
The expressions ∃x and ∀x make x into a bound variable. A formula that contains
no free variables is a sentence.
Functions. Functions map from entities to entities, e.g., JCAPITAL-OF(GEORGIA)K = JATLANTAK.
With functions, it is convenient to add an equality operator, supporting statements
like,
∀x∃yMOTHER-OF(x) = DAUGHTER-OF(y).
In ﬁrst-order logic, it is possible to quantify only over entities. In second-order logic, it is possible to
quantify over properties. This makes it possible to represent statements like Butch has every property that a
good boxer has (example from Blackburn and Bos, ),
∀P∀x((GOOD-BOXER(x) ⇒ P(x)) ⇒ P(BUTCH)).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
Note that MOTHER-OF is a functional analogue of the relation MOTHER, so that
MOTHER-OF(x) = y if MOTHER(x, y). Any logical formula that uses functions can be
rewritten using only relations and quantiﬁcation. For example,
MAKES-NOISE(MOTHER-OF(ABIGAIL))
can be rewritten as ∃xMAKES-NOISE(x) ∧ MOTHER(x, ABIGAIL).
An important property of quantiﬁers is that the order can matter. Unfortunately, natu-
ral language is rarely clear about this! The issue is demonstrated by examples like everyone
speaks a language, which has the following interpretations:
∀x∃y SPEAKS(x, y)
∃y∀x SPEAKS(x, y).
In the ﬁrst case, y may refer to several different languages, while in the second case, there
is a single y that is spoken by everyone.
Truth-conditional semantics
One way to look at the meaning of an FOL sentence φ is as a set of truth conditions,
or models under which φ is satisﬁed. But how to determine whether a sentence is true
or false in a given model? We will approach this inductively, starting with a predicate
applied to a tuple of constants. The truth of such a sentence depends on whether the
tuple of denotations of the constants is in the denotation of the predicate. For example,
CAPITAL(GEORGIA,ATLANTA) is true in model M iff,
(JGEORGIAKM, JATLANTAKM) ∈ JCAPITALKM.
The Boolean operators ∧, ∨, . . . provide ways to construct more complicated sentences,
and the truth of such statements can be assessed based on the truth tables associated with
these operators. The statement ∃xφ is true if there is some assignment of the variable x
to an entity in the model such that φ is true; the statement ∀xφ is true if φ is true under
all possible assignments of x. More formally, we would say that φ is satisﬁed under M,
written as M |= φ.
Truth conditional semantics allows us to deﬁne several other properties of sentences
and pairs of sentences. Suppose that in every M under which φ is satisﬁed, another
formula ψ is also satisﬁed; then φ entails ψ, which is also written as φ |= ψ. For example,
CAPITAL(GEORGIA,ATLANTA) |= ∃xCAPITAL(GEORGIA, x).
A statement that is satisﬁed under any model, such as φ ∨ ¬φ, is valid, written |= (φ ∨
¬φ). A statement that is not satisﬁed under any model, such as φ ∧ ¬φ, is unsatisﬁable,
Jacob Eisenstein. Draft of November , .

.. SEMANTIC PARSING AND THE LAMBDA CALCULUS
or inconsistent. A model checker is a program that determines whether a sentence φ
is satisﬁed in M. A model builder is a program that constructs a model in which φ
is satisﬁed. The problems of checking for consistency and validity in ﬁrst-order logic
are undecidable, meaning that there is no algorithm that can automatically determine
whether an FOL formula is valid or inconsistent.
Inference in ﬁrst-order logic
Our original goal was to support inferences that combine general statements If anyone is
making noise, then Max can’t sleep with speciﬁc statements like Abigail is making noise. We
can now represent such statements in ﬁrst-order logic, but how are we to perform the
inference that Max can’t sleep? One approach is to use “generalized” versions of propo-
sitional inference rules like modus ponens, which can be applied to FOL formulas. By
repeatedly applying such inference rules to a knowledge base of facts, it is possible to
produce proofs of desired propositions. To ﬁnd the right sequence of inferences to derive
a desired theorem, classical artiﬁcial intelligence search algorithms like backward chain-
ing can be applied. Such algorithms are implemented in interpreters for the prolog logic
programming language (Pereira and Shieber, ).
Semantic parsing and the lambda calculus
The previous section laid out a lot of formal machinery; the remainder of this chapter
links these formalisms back to natural language. Given an English sentence like Alex likes
Brit, how can we obtain the desired ﬁrst-order logical representation, LIKES(ALEX,BRIT)?
This is the task of semantic parsing. Just as a syntactic parser is a function from a natu-
ral language sentence to a syntactic structure such as a phrase structure tree, a semantic
parser is a function from natural language to logical formulas.
As in syntactic analysis, semantic parsing is difﬁcult because the space of inputs and
outputs is very large, and their interaction is complex. Our best hope is that, like syntactic
parsing, semantic parsing can somehow be decomposed into simpler sub-problems. This
idea, usually attributed to the German philosopher Gottlob Frege, is called the principle
of compositionality: the meaning of a complex expression is a function of the meanings of
that expression’s constituent parts. We will deﬁne these “constituent parts” as syntactic
constituents: noun phrases and verb phrases. These constituents are combined using
function application: if the syntactic parse contains the production x → y z, then the
semantics of x, written x.sem, will be computed as a function of the semantics of the
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
S : likes(alex, brit)
NP : alex
VP : ?
Alex
NP : brit
V : ?
Brit
likes
Figure .: The principle of compositionality requires that we identify meanings for the
constituents likes and likes Brit that will make it possible to compute the meaning for the
entire sentence.
constituents, y.sem and z.sem.
The lambda calculus
Let’s see how this works for a simple sentence like Alex likes Brit, whose syntactic structure
is shown in Figure .. Our goal is the formula, LIKES(ALEX,BRIT), and it is clear that the
meaning of the constituents Alex and Brit should be ALEX and BRIT. That leaves two more
constituents: the verb likes, and the verb phrase likes Brit. The meanings of these units
must be deﬁned in a way that makes it possible to recover the desired meaning for the
entire sentence by function application. If the meanings of Alex and Brit are constants,
then the meanings of likes and likes Brit must be functional expressions, which can be
applied to their siblings to produce the desired analyses.
Modeling these partial analyses requires extending the ﬁrst-order logic meaning rep-
resentation. We do this by adding lambda expressions, which are descriptions of anony-
mous functions, e.g.,
λx.LIKES(x, BRIT).
This functional expression is the meaning of the verb phrase likes Brit; it takes a single
argument, and returns the result of substituting that argument for x in the expression
§ .. brieﬂy discusses Combinatory Categorial Grammar (CCG) as an alternative to a phrase-structure
analysis of syntax. CCG is argued to be particularly well-suited to semantic parsing (Hockenmaier and
Steedman, ), and is used in much of the contemporary work on machine learning for semantic parsing,
summarized in § ..
The approach of algorithmically building up meaning representations from a series of operations on the
syntactic structure of a sentence is generally attributed to the philosopher Richard Montague, who published
a series of inﬂuential papers on the topic in the early s (e.g., Montague, ).
Formally, all ﬁrst-order logic formulas are lambda expressions; in addition, if φ is a lambda expression,
then λx.φ is also a lambda expression. Readers who are familiar with functional programming will recognize
lambda expressions from their use in programming languages such as Lisp and Python.
Jacob Eisenstein. Draft of November , .

.. SEMANTIC PARSING AND THE LAMBDA CALCULUS
LIKES(x, BRIT). We write this substitution as,
(λx.LIKES(x, BRIT))@ALEX = LIKES(ALEX,BRIT),
with the symbol “@” indicating function application. Function application in the lambda
calculus is sometimes called β-reduction or β-conversion. The expression φ@ψ indicates
a function application to be performed by β-reduction, and φ(ψ) indicates a function or
predicate in the ﬁnal logical form.
Equation . shows how to obtain the desired semantics for the sentence Alex likes
Brit: by applying the lambda expression λx.LIKES(x, BRIT) to the logical constant ALEX.
This rule of composition can be speciﬁed in a syntactic-semantic grammar, in which
syntactic productions are paired with semantic operations. For the syntactic production
S → NP VP, we have the semantic rule VP.sem@NP.sem.
The meaning of the transitive verb phrase likes Brit can also be obtained by function
application on its syntactic constituents. For the syntactic production VP → V NP, we
apply the semantic rule,
VP.sem =(V.sem)@NP.sem
=(λy.λx.LIKES(x, y))@(BRIT)
=λx.LIKES(x, BRIT).
Thus, the meaning of the transitive verb likes is a lambda expression whose output is
another lambda expression: it takes y as an argument to ﬁll in one of the slots in the LIKES
relation, and returns a lambda expression that is ready to take an argument to ﬁll in the
other slot.
Table . shows a minimal syntactic-semantic grammar fragment, G. The complete
derivation of Alex likes Brit in G is shown in Figure .. In addition to the transitive
verb likes, the grammar also includes the intransitive verb sleeps; it should be clear how
to derive the meaning of sentences like Alex sleeps. For verbs that can be either transitive
or intransitive, such as eats, we would have two terminal productions, one for each sense
(terminal productions are also called the lexical entries). Indeed, most of the grammar is
in the lexicon (the terminal productions), since these productions select the basic units of
the semantic interpretation.
Quantiﬁcation
Things get more complicated when we move from sentences about named entities to sen-
tences that involve more general noun phrases. Let’s consider the example, A dog sleeps,
This can be written in a few different ways. The notation λy, x.LIKES(x, y) is a somewhat informal way to
indicate a lambda expression that takes two arguments; this would be acceptable in functional programming.
Logicians (e.g., Carpenter, ) often prefer the more formal notation λy.λx.LIKES(x)(y), indicating that each
lambda expression takes exactly one argument.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
S : likes(alex, brit)
VP : λx.likes(x, brit)
NP : alex
Alex
NP : brit
Vt : λy.λx.likes(x, y)
Brit
likes
Figure .: Derivation of the semantic representation for Alex likes Brit in the grammar
G.
→ NP VP
VP.sem@NP.sem
VP
→ Vt NP
Vt.sem@NP.sem
VP
→ Vi
Vi.sem
Vt
→ likes
λy.λx.LIKES(x, y)
Vi
→ sleeps
λx.SLEEPS(x)
NP
→ Alex
ALEX
NP
→ Brit
BRIT
Table .: G, a minimal syntactic-semantic context-free grammar
which has the meaning ∃xDOG(x) ∧ SLEEPS(x). Clearly, the DOG relation will be intro-
duced by the word dog, and the SLEEP relation will be introduced by the word sleeps.
The existential quantiﬁer ∃ must be introduced by the lexical entry for the determiner a.
However, this seems problematic for the compositional approach taken in the grammar
G: if the semantics of the noun phrase a dog is an existentially quantiﬁed expression, how
can it be the argument to the semantics of the verb sleeps, which expects an entity? And
where does the logical conjunction come from?
There are a few different approaches to handling these issues. We will begin by re-
versing the semantic relationship between subject NPs and VPs, so that the production
S → NP VP has the semantics NP.sem@VP.sem: the meaning of the sentence is now the
semantics of the noun phrase applied to the verb phrase. The implications of this change
are best illustrated by exploring the derivation of the example, shown in Figure .. Let’s
Conversely, the sentence Every dog sleeps would involve a universal quantiﬁer, ∀xDOG(x) ⇒ SLEEPS(x).
The deﬁnite article the requires more consideration, since the dog must refer to some dog which is uniquely
identiﬁable, perhaps from contextual information external to the sentence. Carpenter (, pp. -)
summarizes recent approaches to handling deﬁnite descriptions.
Carpenter () offers an alternative treatment based on combinatory categorial grammar.
Jacob Eisenstein. Draft of November , .

.. SEMANTIC PARSING AND THE LAMBDA CALCULUS
S : ∃xdog(x) ∧ sleeps(x)
VP : λx.sleeps(x)
NP : λP.∃xP(x) ∧ dog(x)
NN : dog
Vi : λx.sleeps(x)
DT : λQ.λP.∃x.P(x) ∧ Q(x)
sleeps
dog
Figure .: Derivation of the semantic representation for A dog sleeps, in grammar G
start with the indeﬁnite article a, to which we assign the rather intimidating semantics,
λP.λQ.∃xP(x) ∧ Q(x).
This is a lambda expression that takes two relations as arguments, P and Q. The relation
P is scoped to the outer lambda expression, so it will be provided by the immediately
adjacent noun, which in this case is DOG. Thus, the noun phrase a dog has the semantics,
NP.sem =DET.sem@NN.sem
=(λP.λQ.∃xP(x) ∧ Q(x))@(DOG)
=λQ.∃xDOG(x) ∧ Q(x).
This is a lambda expression that is expecting another relation, Q, which will be provided
by the verb phrase, SLEEPS. This gives the desired analysis, ∃xDOG(x) ∧ SLEEPS(x).
If noun phrases like a dog are interpreted as lambda expressions, then proper nouns
like Alex must be treated in the same way. This is achieved by type-raising from con-
stants to lambda expressions, x ⇒ λP.P(x). After type-raising, the semantics of Alex is
λP.P(ALEX) — a lambda expression that expects a relation to tell us something about
ALEX. Again, make sure you see how the analysis in Figure . can be applied to the
sentence Alex sleeps.
When applying β-reduction to arguments that are themselves lambda expressions, be sure to use unique
variable names to avoid confusion. For example, it is important to distinguish the x in the semantics for a
from the x in the semantics for likes. Variable names are abstractions, and can always be changed — this is
known as α-conversion. For example, λx.P(x) can be converted to λy.P(y), etc.
Compositional semantic analysis is often supported by type systems, which make it possible to check
whether a given function application is valid. The base types are entities e and truth values t. A property,
such as DOG, is a function from entities to truth values, so its type is written ⟨e, t⟩. A transitive verb has type
⟨e, ⟨e, t⟩⟩: after receiving the ﬁrst entity (the direct object), it returns a function from entities to truth values,
which will be applied to the subject of the sentence. The type-raising operation x ⇒ λP.P(x) corresponds
to a change in type from e to ⟨⟨e, t⟩, t⟩: it expects a function from entities to truth values, and returns a truth
value.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
S : ∃xdog(x) ∧ likes(x, alex)
VP : λx.likes(x, alex)
NP : λQ.∃xdog(x) ∧ Q(x)
NP : λP.P(alex)
NN : dog
Vt : λP.λx.P(λy.likes(x, y))
DT : λP.λQ.∃xP(x) ∧ Q(x)
NNP : alex
likes
dog
Alex
Figure .: Derivation of the semantic representation for A dog likes Alex.
Direct objects are handled by applying the same type-raising operation to transitive
verbs: the meaning of verbs such as likes is raised to,
λP.λx.P(λy.LIKES(x, y))
As a result, we can keep the verb phrase production VP.sem = V.sem@NP.sem, knowing
that the direct object will provide the function P in Equation .. To see how this works,
let’s analyze the verb phrase likes a dog. After uniquely relabeling each lambda variable,
VP.sem =V.sem@NP.sem
=(λP.λx.P(λy.LIKES(x, y)))@(λQ.∃zDOG(z) ∧ Q(z))
=λx.(λQ.∃zDOG(z) ∧ Q(z))@(λy.LIKES(x, y))
=λx.∃zDOG(z) ∧ (λy.LIKES(x, y))@z
=λx.∃zDOG(z) ∧ LIKES(x, z).
These changes are summarized in the revised grammar G, shown in Table .. Fig-
ure . shows a derivation that involves a transitive verb, an indeﬁnite noun phrase, and
a proper noun.
Learning semantic parsers
As with syntactic parsing, any syntactic-semantic grammar with sufﬁcient coverage risks
producing many possible analyses for any given sentence. Machine learning is the dom-
inant approach to selecting a single analysis. We will focus on algorithms that learn to
score logical forms by attaching weights to features of their derivations (Zettlemoyer
and Collins, ). Alternative approaches include transition-based parsing (Zelle and
Mooney, ; Misra and Artzi, ) and methods inspired by machine translation (Wong
and Mooney, ). Methods also differ in the form of supervision used for learning,
which can range from complete derivations to much more limited training signals. We
will begin with the case of complete supervision, and then consider how learning is still
possible even when seemingly key information is missing.
Jacob Eisenstein. Draft of November , .

.. LEARNING SEMANTIC PARSERS
→ NP VP
NP.sem@VP.sem
VP
→ Vt NP
Vt.sem@NP.sem
VP
→ Vi
Vi.sem
NP
→ DET NN
DET.sem@NN.sem
NP
→ NNP
λP.P(NNP.sem)
DET
→ a
λP.λQ.∃xP(x) ∧ Q(x)
DET
→ every
λP.λQ.∀x(P(x) ⇒ Q(x))
Vt
→ likes
λP.λx.P(λy.LIKES(x, y))
Vi
→ sleeps
λx.SLEEPS(x)
NN
→ dog
DOG
NNP
→ Alex
ALEX
NNP
→ Brit
BRIT
Table .: G, a syntactic-semantic context-free grammar fragment, which supports
quantiﬁed noun phrases
Datasets
Early work on semantic parsing focused on natural language expressions of
geographical database queries, such as What states border Texas. The GeoQuery dataset
of Zelle and Mooney () was originally coded in prolog, but has subsequently been
expanded and converted into the SQL database query language by Popescu et al. ()
and into ﬁrst-order logic with lambda calculus by Zettlemoyer and Collins (), pro-
viding logical forms like λx.STATE(x) ∧ BORDERS(x, TEXAS). Another early dataset con-
sists of instructions for RoboCup robot soccer teams (Kate et al., ). More recent work
has focused on broader domains, such as the Freebase database (Bollacker et al., ),
for which queries have been annotated by Krishnamurthy and Mitchell () and Cai
and Yates (). Other recent datasets include child-directed speech (Kwiatkowski et al.,
) and elementary school science exams (Krishnamurthy, ).
Learning from derivations
Let w(i) indicate a sequence of text, and let y(i) indicate the desired logical form. For
example:
w(i) =Alex eats shoots and leaves
y(i) =EATS(ALEX,SHOOTS) ∧ EATS(ALEX,LEAVES)
In the standard supervised learning paradigm that was introduced in § ., we ﬁrst de-
ﬁne a feature function, f(w, y), and then learn weights on these features, so that y(i) =
argmaxy θ  f(w, y). The weight vector θ is learned by comparing the features of the true
label f(w(i), y(i)) against either the features of the predicted label f(w(i), ˆy) (perceptron,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
S : eats(alex, shoots) ∧ eats(alex, leavesn)
NP : λP.P(alex)
VP : λx.eats(x, shoots) ∧ eats(x, leavesn)
Alex
Vt : λP.λx.P(λy.eats(x, y))
NP : λP.P(shoots) ∧ P(leavesn)
eats
NP : λP.P(shoots)
NP : λP.P(leavesn)
CC : λP.λQ.λx.P(x) ∧ Q(x)
leaves
and
shoots
Figure .: Derivation for gold semantic analysis of Alex eats shoots and leaves
support vector machine) or the expected feature vector Ey|w[f(w(i), y)] (logistic regres-
sion).
While this basic framework seems similar to discriminative syntactic parsing, there is
a crucial difference. In (context-free) syntactic parsing, the annotation y(i) contains all of
the syntactic productions; indeed, the task of identifying the correct set of productions
is identical to the task of identifying the syntactic structure. In semantic parsing, this is
not the case: the logical form EATS(ALEX,SHOOTS) ∧ EATS(ALEX,LEAVES) does not reveal
the syntactic-semantic productions that were used to obtain it. Indeed, there may be spu-
rious ambiguity, so that a single logical form can be reached by multiple derivations.
(We previously encountered spurious ambiguity in transition-based dependency parsing,
§ ...)
These ideas can be formalized by introducing an additional variable z, representing
the derivation of the logical form y from the text w. Assume that the feature function de-
composes across the productions in the derivation, f(w, z, y) = PT
t= f(w, zt, y), where
zt indicates a single syntactic-semantic production. For example, we might have a feature
for the production S → NP VP : NP.sem@VP.sem, as well as for terminal productions
like NNP → Alex : ALEX. Under this decomposition, it is possible to compute scores
for each semantically-annotated subtree in the analysis of w, so that bottom-up parsing
algorithms like CKY (§ .) can be applied to ﬁnd the best-scoring semantic analysis.
Figure . shows a derivation of the correct semantic analysis of the sentence Alex
eats shoots and leaves, in a simpliﬁed grammar in which the plural noun phrases shoots
and leaves are interpreted as logical constants SHOOTS and LEAVESn. Figure . shows a
derivation of an incorrect analysis. Assuming one feature per production, the perceptron
update is shown in Table .. From this update, the parser would learn to prefer the
noun interpretation of leaves over the verb interpretation. It would also learn to prefer
noun phrase coordination over verb phrase coordination.
While the update is explained in terms of the perceptron, it would be easy to replace
the perceptron with a conditional random ﬁeld. In this case, the online updates would be
Jacob Eisenstein. Draft of November , .

.. LEARNING SEMANTIC PARSERS
S : eats(alex, shoots) ∧ leavesv(alex)
NP : λP.P(alex)
VP : λx.eats(x, shoots) ∧ leavesv(x)
Alex
VP : λx.eats(x, shoots)
VP : λx.leavesv(x)
CC : λP.λQ.λx.P(x) ∧ Q(x)
and
NP : λP.P(shoots)
Vi : λx.leavesv(x)
Vt : λP.λx.P(λy.eats(x, y))
leaves
shoots
eats
Figure .: Derivation for incorrect semantic analysis of Alex eats shoots and leaves
NP → NP CC NP
(CC.sem@(NP.sem))@(NP.sem)
VP → VP CC VP
(CC.sem@(VP.sem))@(VP.sem)
NP → leaves
LEAVESn
VP → Vi
Vi.sem
Vi → leaves
λx.LEAVESv
Table .: Perceptron update for analysis in Figure . (gold) and Figure . (predicted)
based on feature expectations, which can be computed using the inside-outside algorithm
(§ .).
Learning from logical forms
Complete derivations are expensive to annotate, and are rarely available. One solution
is to focus on learning from logical forms directly, while treating the derivations as la-
tent variables (Zettlemoyer and Collins, ). In a conditional probabilistic model over
logical forms y and derivations z, we have,
p(y, z | w) =
exp(θ  f(w, z, y))
y′,z′ exp(θ  f(w, z′, y′)),
which is the standard log-linear model, applied to the logical form y and the derivation
z.
Since the derivation z unambiguously determines the logical form y, it may seem silly
to model the joint probability over y and z. However, since z is unknown, it can be
marginalized out,
p(y, z | w).
p(y | w) =
An exception is the work of Ge and Mooney (), who annotate the meaning of each syntactic con-
stituents for several hundred sentences.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
The semantic parser can then select the logical form with the maximum log marginal
probability,
log
p(y, z | w) = log
exp(θ  f(w, z, y))
P y′, z′ exp(θ  f(w, z′, y′))
exp(θ  f(w, z′, y′))
∝ log
≥ max
θ  f(w, z, y).
It is impossible to push the log term inside the sum over z, so our usual linear scoring
function does not apply. We can recover this scoring function only in approximation, by
taking the max (rather than the sum) over derivations z, which provides a lower bound.
Learning can be performed by maximizing the log marginal likelihood,
ℓ(θ) =
i=
log p(y(i) | w(i); θ)
p(y(i), z(i) | w(i); θ).
i=
log
This log-likelihood is not convex in θ, unlike the log-likelihood of a fully-observed condi-
tional random ﬁeld. This means that learning can give different results depending on the
initialization.
The derivative of Equation . is,
y′,z′
p(y′, z′ | w; θ)f(w, z′, y′)
∂ℓi
∂θ =
p(z | y, w; θ)f(w, z, y) −
=Ez|y,wf(w, z, y) − Ey,z|wf(w, z, y)
Both expectations can be computed via bottom-up algorithms like inside-outside. Al-
ternatively, we can again maximize rather than marginalize over derivations for an ap-
proximate solution. In either case, the ﬁrst term of the gradient requires us to identify
derivations z that are compatible with the logical form y. This can be done in a bottom-
up dynamic programming algorithm, by having each cell in the table t[i, j, X] include the
set of all possible logical forms for X ⇝ wi+:j. The resulting table may therefore be much
larger than in syntactic parsing. This can be controlled by using pruning to eliminate in-
termediate analyses that are incompatible with the ﬁnal logical form y (Zettlemoyer and
Collins, ), or by using beam search and restricting the size of each cell to some ﬁxed
constant (Liang et al., ).
If we replace each expectation in Equation . with argmax and then apply stochastic
gradient descent to learn the weights, we obtain the latent variable perceptron, a simple
Jacob Eisenstein. Draft of November , .

.. LEARNING SEMANTIC PARSERS
Algorithm  Latent variable perceptron
: procedure LATENTVARIABLEPERCEPTRON(w(:N), y(:N))
θ ←
repeat
Select an instance i
z(i) ← argmaxz θ  f(w(i), z, y(i))
ˆy, ˆz ← argmaxy′,z′ θ  f(w(i), z′, y′)
θ ← θ + f(w(i), z(i), y(i)) − f(w(i), ˆz, ˆy)
until tired
return θ
and general algorithm for learning with missing data. The algorithm is shown in its most
basic form in Algorithm , but the usual tricks such as averaging and margin loss can
be applied (Yu and Joachims, ). Aside from semantic parsing, the latent variable
perceptron has been used in tasks such as machine translation (Liang et al., ) and
named entity recognition (Sun et al., ). In latent conditional random ﬁelds, we use
the full expectations rather than maximizing over the hidden variable. This model has
also been employed in a range of problems beyond semantic parsing, including parse
reranking (Koo and Collins, ) and gesture recognition (Quattoni et al., ).
Learning from denotations
Logical forms are easier to obtain than complete derivations, but the annotation of logical
forms still requires considerable expertise. However, it is relatively easy to obtain deno-
tations for many natural language sentences. For example, in the geography domain, the
denotation of a question would be its answer (Clarke et al., ; Liang et al., ):
Text :What states border Georgia?
Logical form :λx.STATE(x) ∧ BORDER(x, GEORGIA)
Denotation :{Alabama, Florida, North Carolina,
South Carolina, Tennessee}
Similarly, in a robotic control setting, the denotation of a command would be an action or
sequence of actions (Artzi and Zettlemoyer, ). In both cases, the idea is to reward the
semantic parser for choosing an analysis whose denotation is correct: the right answer to
the question, or the right action.
Learning from logical forms was made possible by summing or maxing over deriva-
tions. This idea can be carried one step further, summing or maxing over all logical forms
with the correct denotation. Let vi(y) ∈ {, } be a validation function, which assigns a
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
binary score indicating whether the denotation JyK for the text w(i) is correct. We can then
learn by maximizing a conditional-likelihood objective,
vi(y) × p(y | w; θ)
ℓ(i)(θ) = log
p(y, z | w; θ),
= log
vi(y) ×
which sums over all derivations z of all valid logical forms, {y : vi(y) = }. This cor-
responds to the log-probability that the semantic parser produces a logical form with a
valid denotation.
Differentiating with respect to θ, we obtain,
∂ℓ(i)
y′,z′
p(y′, z′ | w)f(w, z′, y′),
∂θ =
y,z:vi(y)=
p(y, z | w)f(w, z, y) −
which is the usual difference in feature expectations. The positive term computes the
expected feature expectations conditioned on the denotation being valid, while the second
term computes the expected feature expectations according to the current model, without
regard to the ground truth. Large-margin learning formulations are also possible for this
problem. For example, Artzi and Zettlemoyer () generate a set of valid and invalid
derivations, and then impose a constraint that all valid derivations should score higher
than all invalid derivations. This constraint drives a perceptron-like learning rule.
Additional resources
A key issue not considered here is how to handle semantic underspeciﬁcation: cases in
which there are multiple semantic interpretations for a single syntactic structure. Quanti-
ﬁer scope ambiguity is a classic example. Blackburn and Bos () enumerate a number
of approaches to this issue, and also provide links between natural language semantics
and computational inference techniques. Much of the contemporary research on semantic
parsing uses the framework of combinatory categorial grammar (CCG). Carpenter ()
provides a comprehensive treatment of how CCG can support compositional semantic
analysis. Another recent area of research is the semantics of multi-sentence texts. This can
be handled with models of dynamic semantics, such as dynamic predicate logic (Groe-
nendijk and Stokhof, ).
Alternative readings on formal semantics include an “informal” reading from Levy
and Manning (), and a more involved introduction from Briscoe (). To learn more
about ongoing research on data-driven semantic parsing, readers may consult the survey
Jacob Eisenstein. Draft of November , .

.. LEARNING SEMANTIC PARSERS
article by Liang and Potts (), tutorial slides and videos by Artzi and Zettlemoyer
(), and the source code by Yoav Artzi and Percy Liang.
Exercises
. The modus ponens inference rule states that if we know φ ⇒ ψ and φ, then ψ must
be true. Justify this rule, using the deﬁnition of the ⇒ operator and some of the laws
provided in § .., plus one additional identity: ⊥ ∨ φ = φ.
. Convert the following examples into ﬁrst-order logic, using the relations CAN-SLEEP,
MAKES-NOISE, and BROTHER.
If Abigail makes noise, no one can sleep.
If Abigail makes noise, someone cannot sleep.
None of Abigail’s brothers can sleep.
If one of Abigail’s brothers makes noise, Abigail cannot sleep.
. Extend the grammar fragment G to include the ditransitive verb teaches and the
proper noun Swahili. Show how to derive the interpretation for the sentence Alex
teaches Brit Swahili, which should be TEACHES(ALEX,BRIT,SWAHILI). The grammar
need not be in Chomsky Normal Form. For the ditransitive verb, use NP and NP
to indicate the two direct objects.
. Derive the semantic interpretation for the sentence Alex likes every dog, using gram-
mar fragment G.
. Extend the grammar fragment G to handle adjectives, so that the meaning of an
angry dog is λP.∃xDOG(x) ∧ ANGRY(x) ∧ P(x). Speciﬁcally, you should supply the
lexical entry for the adjective angry, and you should specify the syntactic-semantic
productions NP → DET NOM, NOM → JJ NOM, and NOM → NN.
. Extend your answer to the previous question to cover copula constructions with
predicative adjectives, such as Alex is angry. The interpretation should be ANGRY(ALEX).
You should add a verb phrase production VP → Vcop JJ, and a terminal production
Vcop → is. Show why your grammar extensions result in the correct interpretation.
. In Figure . and Figure ., we treat the plurals shoots and leaves as entities. Revise
G so that the interpretation of Alex eats leaves is ∀x.(LEAF(x) ⇒ EATS(ALEX, x)), and
show the resulting perceptron update.
Videos are currently available at http://yoavartzi.com/tutorial/
http://yoavartzi.com/spf
https://github.com/percyliang/sempre
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . LOGICAL SEMANTICS
. Statements like every student eats a pizza have two possible interpretations, depend-
ing on quantiﬁer scope:
∀x∃yPIZZA(y) ∧ (STUDENT(x) ⇒ EATS(x, y))
∃y∀xPIZZA(y) ∧ (STUDENT(x) ⇒ EATS(x, y))
a) Explain why these interpretations really are different.
b) Which is generated by grammar G? Note that you may have to manipulate
the logical form to exactly align with the grammar.
. *Modify G so that produces the second interpretation in the previous problem.
Hint: one possible solution involves changing the semantics of the sentence pro-
duction and one other production.
. In the GeoQuery domain, give a natural language query that has multiple plausible
semantic interpretations with the same denotation. List both interpretaions and the
denotation.
Hint:
There are many ways to do this, but one approach involves using toponyms
(place names) that could plausibly map to several different entities in the model.
Jacob Eisenstein. Draft of November , .

Chapter
Predicate-argument semantics
This chapter considers more “lightweight” semantic representations, which discard some
aspects of ﬁrst-order logic, but focus on predicate-argument structures. Let’s begin by
thinking about the semantics of events, with a simple example:
Asha gives Boyang a book.
A ﬁrst-order logical representation of this sentence is,
∃x.BOOK(x) ∧ GIVE(ASHA, BOYANG, x)
In this representation, we deﬁne variable x for the book, and we link the strings Asha and
Boyang to entities ASHA and BOYANG. Because the action of giving involves a giver, a
recipient, and a gift, the predicate GIVE must take three arguments.
Now suppose we have additional information about the event:
Yesterday, Asha reluctantly gave Boyang a book.
One possible to solution is to extend the predicate GIVE to take additional arguments,
∃x.BOOK(x) ∧ GIVE(ASHA, BOYANG, x, YESTERDAY, RELUCTANTLY)
But this is clearly unsatisfactory: yesterday and relunctantly are optional arguments,
and we would need a different version of the GIVE predicate for every possible combi-
nation of arguments. Event semantics solves this problem by reifying the event as an
existentially quantiﬁed variable e,
∃e, x.GIVE-EVENT(e) ∧ GIVER(e, ASHA) ∧ GIFT(e, x) ∧ BOOK(e, x) ∧ RECIPIENT(e, BOYANG)
∧ TIME(e, YESTERDAY) ∧ MANNER(e, RELUCTANTLY)
CHAPTER . PREDICATE-ARGUMENT SEMANTICS
In this way, each argument of the event — the giver, the recipient, the gift — can be rep-
resented with a relation of its own, linking the argument to the event e. The expression
GIVER(e, ASHA) says that ASHA plays the role of GIVER in the event. This reformulation
handles the problem of optional information such as the time or manner of the event,
which are called adjuncts. Unlike arguments, adjuncts are not a mandatory part of the
relation, but under this representation, they can be expressed with additional logical rela-
tions that are conjoined to the semantic interpretation of the sentence.
The event semantic representation can be applied to nested clauses, e.g.,
Chris sees Asha pay Boyang.
This is done by using the event variable as an argument:
∃e∃e SEE-EVENT(e) ∧ SEER(e, CHRIS) ∧ SIGHT(e, e)
∧ PAY-EVENT(e) ∧ PAYER(e, ASHA) ∧ PAYEE(e, BOYANG)
As with ﬁrst-order logic, the goal of event semantics is to provide a representation that
generalizes over many surface forms. Consider the following paraphrases of (.):
a. Asha gives a book to Boyang.
b. A book is given to Boyang by Asha.
c. A book is given by Asha to Boyang.
d. The gift of a book from Asha to Boyang ...
All have the same event semantic meaning as Equation ., but the ways in which the
meaning can be expressed are diverse. The ﬁnal example does not even include a verb:
events are often introduced by verbs, but as shown by (.d), the noun gift can introduce
the same predicate, with the same accompanying arguments.
Semantic role labeling (SRL) is a relaxed form of semantic parsing, in which each
semantic role is ﬁlled by a set of tokens from the text itself. This is sometimes called
“shallow semantics” because, unlike model-theoretic semantic parsing, role ﬁllers need
not be symbolic expressions with denotations in some world model. A semantic role
labeling system is required to identify all predicates, and then specify the spans of text
that ﬁll each role. To give a sense of the task, here is a more complicated example:
Boyang wants Asha to give him a linguistics book.
This representation is often called Neo-Davidsonian event semantics.
The use of existentially-
quantiﬁed event variables was proposed by Davidson () to handle the issue of optional adjuncts. In
Neo-Davidsonian semantics, this treatment of adjuncts is extended to mandatory arguments as well (e.g.,
Parsons, ).
Jacob Eisenstein. Draft of November , .

.. SEMANTIC ROLES
In this example, there are two predicates, expressed by the verbs want and give. Thus, a
semantic role labeler might return the following output:
(PREDICATE : wants, WANTER : Boyang, DESIRE : Asha to give him a linguistics book)
(PREDICATE : give, GIVER : Asha, RECIPIENT : him, GIFT : a linguistics book)
Boyang and him may refer to the same person, but the semantic role labeling is not re-
quired to resolve this reference. Other predicate-argument representations, such as Ab-
stract Meaning Representation (AMR), do require reference resolution. We will return to
AMR in § ., but ﬁrst, let us further consider the deﬁnition of semantic roles.
Semantic roles
In event semantics, it is necessary to specify a number of additional logical relations to
link arguments to events: GIVER, RECIPIENT, SEER, SIGHT, etc. Indeed, every predicate re-
quires a set of logical relations to express its own arguments. In contrast, adjuncts such as
TIME and MANNER are shared across many types of events. A natural question is whether
it is possible to treat mandatory arguments more like adjuncts, by identifying a set of
generic argument types that are shared across many event predicates. This can be further
motivated by examples involving related verbs:
a. Asha gave Boyang a book.
b. Asha loaned Boyang a book.
c. Asha taught Boyang a lesson.
d. Asha gave Boyang a lesson.
The respective roles of Asha, Boyang, and the book are nearly identical across the ﬁrst
two examples. The third example is slightly different, but the fourth example shows that
the roles of GIVER and TEACHER can be viewed as related.
One way to think about the relationship between roles such as GIVER and TEACHER is
by enumerating the set of properties that an entity typically possesses when it fulﬁlls these
roles: givers and teachers are usually animate (they are alive and sentient) and volitional
(they choose to enter into the action). In contrast, the thing that gets loaned or taught is
usually not animate or volitional; furthermore, it is unchanged by the event.
Building on these ideas, thematic roles generalize across predicates by leveraging the
shared semantic properties of typical role ﬁllers (Fillmore, ). For example, in exam-
ples (.a-.d), Asha plays a similar role in all four sentences, which we will call the
There are always exceptions. For example, in the sentence The C programming language has taught me a
lot about perseverance, the “teacher” is the The C programming language, which is presumably not animate or
volitional.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
Asha
gave
Boyang
a book
VerbNet
AGENT
RECIPIENT
THEME
PropBank
ARG: giver
ARG: entity given to
ARG: thing given
FrameNet
DONOR
RECIPIENT
THEME
Asha
taught
Boyang
algebra
VerbNet
AGENT
RECIPIENT
TOPIC
PropBank
ARG: teacher
ARG: student
ARG: subject
FrameNet
TEACHER
STUDENT
SUBJECT
Figure .:
Example semantic annotations according to VerbNet, PropBank, and
FrameNet
agent. This reﬂects several shared semantic properties: she is the one who is actively and
intentionally performing the action, while Boyang is a more passive participant; the book
and the lesson would play a different role, as non-animate participants in the event.
Example annotations from three well known systems are shown in Figure .. We
will now discuss these systems in more detail.
VerbNet
VerbNet (Kipper-Schuler, ) is a lexicon of verbs, and it includes thirty “core” thematic
roles played by arguments to these verbs. Here are some example roles, accompanied by
their deﬁnitions from the VerbNet Guidelines.
AGENT: “ACTOR in an event who initiates and carries out the event intentionally or
consciously, and who exists independently of the event.”
PATIENT: “UNDERGOER in an event that experiences a change of state, location or
condition, that is causally involved or directly affected by other participants, and
exists independently of the event.”
RECIPIENT: “DESTINATION that is animate”
THEME: “UNDERGOER that is central to an event or state that does not have control
over the way the event occurs, is not structurally changed by the event, and/or is
characterized as being in a certain position or condition throughout the state.”
TOPIC: “THEME characterized by information content transferred to another partic-
ipant.”
http://verbs.colorado.edu/verb-index/VerbNet_Guidelines.pdf
Jacob Eisenstein. Draft of November , .

.. SEMANTIC ROLES
VerbNet roles are organized in a hierarchy, so that a TOPIC is a type of THEME, which in
turn is a type of UNDERGOER, which is a type of PARTICIPANT, the top-level category.
In addition, VerbNet organizes verb senses into a class hierarchy, in which verb senses
that have similar meanings are grouped together. Recall from § . that multiple meanings
of the same word are called senses, and that WordNet identiﬁes senses for many English
words. VerbNet builds on WordNet, so that verb classes are identiﬁed by the WordNet
senses of the verbs that they contain. For example, the verb class give-. includes
the ﬁrst WordNet sense of loan and the second WordNet sense of lend.
Each VerbNet class or subclass takes a set of thematic roles. For example, give-.
takes arguments with the thematic roles of AGENT, THEME, and RECIPIENT; the pred-
icate TEACH takes arguments with the thematic roles AGENT, TOPIC, RECIPIENT, and
SOURCE. So according to VerbNet, Asha and Boyang play the roles of AGENT and RECIP-
IENT in the sentences,
a. Asha gave Boyang a book.
b. Asha taught Boyang algebra.
The book and algebra are both THEMES, but algebra is a subcategory of THEME — a TOPIC
— because it consists of information content that is given to the receiver.
Proto-roles and PropBank
Detailed thematic role inventories of the sort used in VerbNet are not universally accepted.
For example, Dowty (, pp. ) notes that “Linguists have often found it hard to agree
on, and to motivate, the location of the boundary between role types.” He argues that a
solid distinction can be identiﬁed between just two proto-roles:
Proto-Agent. Characterized by volitional involvement in the event or state; sentience
and/or perception; causing an event or change of state in another participant; move-
ment; exists independently of the event.
Proto-Patient. Undergoes change of state; causally affected by another participant; sta-
tionary relative to the movement of another participant; does not exist indepen-
dently of the event.
https://verbs.colorado.edu/verb-index/vn/give-..php
https://verbs.colorado.edu/verb-index/vn/transfer_mesg-...php
Reisinger et al. () ask crowd workers to annotate these properties directly, ﬁnding that annotators
tend to agree on the properties of each argument. They also ﬁnd that in English, arguments having more
proto-agent properties tend to appear in subject position, while arguments with more proto-patient proper-
ties appear in object position.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
In the examples in Figure ., Asha has most of the proto-agent properties: in giving
the book to Boyang, she is acting volitionally (as opposed to Boyang got a book from Asha, in
which it is not clear whether Asha gave up the book willingly); she is sentient; she causes a
change of state in Boyang; she exists independently of the event. Boyang has some proto-
agent properties: he is sentient and exists independently of the event. But he also has
some proto-patient properties: he is the one who is causally affected and who undergoes
change of state. The book that Asha gives Boyang has even fewer of the proto-agent
properties: it is not volitional or sentient, and it has no causal role. But it also lacks many
of the proto-patient properties: it does not undergo change of state, exists independently
of the event, and is not stationary.
The Proposition Bank, or PropBank (Palmer et al., ), builds on this basic agent-
patient distinction, as a middle ground between generic thematic roles and roles that are
speciﬁc to each predicate. Each verb is linked to a list of numbered arguments, with ARG
as the proto-agent and ARG as the proto-patient. Additional numbered arguments are
verb-speciﬁc. For example, for the predicate TEACH, the arguments are:
ARG: the teacher
ARG: the subject
ARG: the student(s)
Verbs may have any number of arguments: for example, WANT and GET have ﬁve, while
EAT has only ARG and ARG. In addition to the semantic arguments found in the frame
ﬁles, roughly a dozen general-purpose adjuncts may be used in combination with any
verb. These are shown in Table ..
PropBank-style semantic role labeling is annotated over the entire Penn Treebank. This
annotation includes the sense of each verbal predicate, as well as the argument spans.
FrameNet
Semantic frames are descriptions of situations or events. Frames may be evoked by one
of their lexical units (often a verb, but not always), and they include some number of
frame elements, which are like roles (Fillmore, ). For example, the act of teaching
is a frame, and can be evoked by the verb taught; the associated frame elements include
the teacher, the student(s), and the subject being taught. Frame semantics has played a
signiﬁcant role in the history of artiﬁcial intelligence, in the work of Minsky () and
Schank and Abelson (). In natural language processing, the theory of frame semantics
has been implemented in FrameNet (Fillmore and Baker, ), which consists of a lexicon
http://verbs.colorado.edu/propbank/framesets-english-aliases/teach.html
Jacob Eisenstein. Draft of November , .

.. SEMANTIC ROLES
TMP
time
Boyang ate a bagel [AM-TMP yesterday].
LOC
location
Asha studies in [AM-LOC Stuttgart]
MOD
modal verb
Asha [AM-MOD will] study in Stuttgart
ADV
general purpose
[AM-ADV Luckily], Asha knew algebra.
MNR
manner
Asha ate [AM-MNR aggressively].
DIS
discourse connective
[AM-DIS However], Asha prefers algebra.
PRP
purpose
Barry studied [AM-PRP to pass the bar].
DIR
direction
Workers dumped burlap sacks [AM-DIR into a bin].
NEG
negation
Asha does [AM-NEG not] speak Albanian.
EXT
extent
Prices increased [AM-EXT %].
CAU
cause
Boyang returned the book [AM-CAU because it was overdue].
Table .: PropBank adjuncts (Palmer et al., ), sorted by frequency in the corpus
of roughly  frames, and a corpus of more than , “exemplar sentences,” in which
the frames and their elements are annotated.
Rather than seeking to link semantic roles such as TEACHER and GIVER into the-
matic roles such as AGENT, FrameNet aggressively groups verbs into frames, and links
semantically-related roles across frames. For example, the following two sentences would
be annotated identically in FrameNet:
a. Asha taught Boyang algebra.
b. Boyang learned algebra from Asha.
This is because teach and learn are both lexical units in the EDUCATION TEACHING frame.
Furthermore, roles can be shared even when the frames are distinct, as in the following
two examples:
a. Asha gave Boyang a book.
b. Boyang got a book from Asha.
The GIVING and GETTING frames both have RECIPIENT and THEME elements, so Boyang
and the book would play the same role. Asha’s role is different: she is the DONOR in the
GIVING frame, and the SOURCE in the GETTING frame. FrameNet makes extensive use of
multiple inheritance to share information across frames and frame elements: for example,
the COMMERCE SELL and LENDING frames inherit from GIVING frame.
Current details and data can be found at https://framenet.icsi.berkeley.edu/
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
Semantic role labeling
The task of semantic role labeling is to identify the parts of the sentence comprising the
semantic roles. In English, this task is typically performed on the PropBank corpus, with
the goal of producing outputs in the following form:
[ARG Asha] [GIVE. gave] [ARG Boyang’s mom] [ARG a book] [AM-TMP yesterday].
Note that a single sentence may have multiple verbs, and therefore a given word may be
part of multiple role-ﬁllers:
[ARG Asha]
Asha
[WANT. wanted]
wanted
[ARG Boyang to give her the book].
[ARG Boyang] [GIVE. to give] [ARG her] [ARG the book].
Semantic role labeling as classiﬁcation
PropBank is annotated on the Penn Treebank, and annotators used phrasal constituents
(§ ..) to ﬁll the roles. PropBank semantic role labeling can be viewed as the task of as-
signing to each phrase a label from the set R = {∅, PRED, ARG, ARG, ARG, . . . , AM-LOC, AM-TMP, .
with respect to each predicate. If we treat semantic role labeling as a classiﬁcation prob-
lem, we obtain the following functional form:
ˆy(i,j) = argmax
ψ(w, y, i, j, ρ, τ),
where,
(i, j) indicates the span of a phrasal constituent (wi+, wi+, . . . , wj);
w represents the sentence as a sequence of tokens;
ρ is the index of the predicate verb in w;
τ is the structure of the phrasal constituent parse of w.
Early work on semantic role labeling focused on discriminative feature-based models,
where ψ(w, y, i, j, ρ, τ) = θ  f(w, y, i, j, ρ, τ). Table . shows the features used in a sem-
inal paper on FrameNet semantic role labeling (Gildea and Jurafsky, ). By  there
PropBank roles can also be ﬁlled by split constituents, which are discontinuous spans of text. This
situation most frequently in reported speech, e.g.
[ARG By addressing these problems], Mr.
Maxwell said,
[ARG the new funds have become extremely attractive.] (example adapted from Palmer et al., ). This issue
is typically addressed by deﬁning “continuation arguments”, e.g. C-ARG, which refers to the continuation
of ARG after the split.
Jacob Eisenstein. Draft of November , .

.. SEMANTIC ROLE LABELING
Predicate lemma and
POS tag
The lemma of the predicate verb and its part-of-speech tag
Voice
Whether the predicate is in active or passive voice, as deter-
mined by a set of syntactic patterns for identifying passive
voice constructions
Phrase type
The constituent phrase type for the proposed argument in
the parse tree, e.g. NP, PP
Headword and POS
tag
The head word of the proposed argument and its POS tag,
identiﬁed using the Collins () rules
Position
Whether the proposed argument comes before or after the
predicate in the sentence
Syntactic path
The set of steps on the parse tree from the proposed argu-
ment to the predicate (described in detail in the text)
Subcategorization
The syntactic production from the ﬁrst branching node
above the predicate.
For example, in Figure ., the
subcategorization feature around taught would be VP →
VBD NP PP.
Table .: Features used in semantic role labeling by Gildea and Jurafsky ().
were several systems for PropBank semantic role labeling, and their approaches and fea-
ture sets are summarized by Carreras and M`arquez (). Typical features include: the
phrase type, head word, part-of-speech, boundaries, and neighbors of the proposed argu-
ment wi+:j; the word, lemma, part-of-speech, and voice of the verb wρ (active or passive),
as well as features relating to its frameset; the distance and path between the verb and
the proposed argument. In this way, semantic role labeling systems are high-level “con-
sumers” in the NLP stack, using features produced from lower-level components such as
part-of-speech taggers and parsers. More comprehensive feature sets are enumerated by
Das et al. () and T¨ackstr¨om et al. ().
A particularly powerful class of features relate to the syntactic path between the ar-
gument and the predicate. These features capture the sequence of moves required to get
from the argument to the verb by traversing the phrasal constituent parse of the sentence.
The idea of these features is to capture syntactic regularities in how various arguments
are realized. Syntactic path features are best illustrated by example, using the parse tree
in Figure .:
The path from Asha to the verb taught is NNP↑NP↑S↓VP↓VBD. The ﬁrst part of
the path, NNP↑NP↑S, means that we must travel up the parse tree from the NNP
tag (proper noun) to the S (sentence) constituent.
The second part of the path,
S↓VP↓VBD, means that we reach the verb by producing a VP (verb phrase) from
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
VP
NP
PP(Arg)
Nnp(Arg)
NP(Arg)
Vbd
Nn
In
Asha
Nn
Det
taught
algebra
about
class
the
Figure .: Semantic role labeling on the phrase-structure parse tree for a sentence. The
dashed line indicates the syntactic path from Asha to the predicate verb taught.
the S constituent, and then by producing a VBD (past tense verb). This feature is
consistent with Asha being in subject position, since the path includes the sentence
root S.
The path from the class to taught is NP↑VP↓VBD. This is consistent with the class
being in object position, since the path passes through the VP node that dominates
the verb taught.
Because there are many possible path features, it can also be helpful to look at smaller
parts: for example, the upward and downward parts can be treated as separate features;
another feature might consider whether S appears anywhere in the path.
Rather than using the constituent parse, it is also possible to build features from the de-
pendency path (see § .) between the head word of each argument and the verb (Prad-
han et al., ). Using the Universal Dependency part-of-speech tagset and dependency
relations (Nivre et al., ), the dependency path from Asha to taught is PROPN ←
NSUBJVERB,
because taught is the head of a relation of type
NSUBJ with Asha. Similarly, the dependency
path from class to taught is NOUN ←
DOBJVERB, because class heads the noun phrase that is a
direct object of taught. A more interesting example is Asha wanted to teach the class, where
the path from Asha to teach is PROPN ←
NSUBJVERB →
XCOMPVERB. The right-facing arrow in sec-
ond relation indicates that wanted is the head of its XCOMP relation with teach.
Jacob Eisenstein. Draft of November , .

.. SEMANTIC ROLE LABELING
Semantic role labeling as constrained optimization
A potential problem with treating SRL as a classiﬁcation problem is that there are a num-
ber of sentence-level constraints, which a classiﬁer might violate.
For a given verb, there can be only one argument of each type (ARG, ARG, etc.)
Arguments cannot overlap. This problem arises when we are labeling the phrases
in a constituent parse tree, as shown in Figure .: if we label the PP about algebra
as an argument or adjunct, then its children about and algebra must be labeled as ∅.
The same constraint also applies to the syntactic ancestors of this phrase.
These constraints introduce dependencies across labeling decisions. In structure pre-
diction problems such as sequence labeling and parsing, such dependencies are usually
handled by deﬁning a scoring over the entire structure, y. Efﬁcient inference requires
that the global score decomposes into local parts: for example, in sequence labeling, the
scoring function decomposes into scores of pairs of adjacent tags, permitting the applica-
tion of the Viterbi algorithm for inference. But the constraints that arise in semantic role
labeling are less amenable to local decomposition. We therefore consider constrained
optimization as an alternative solution.
Let the set C(τ) refer to all labelings that obey the constraints introduced by the parse
τ. The semantic role labeling problem can be reformulated as a constrained optimization
over y ∈ C(τ),
max
(i,j)∈τ
ψ(w, yi,j, i, j, ρ, τ)
s.t.
y ∈ C(τ).
In this formulation, the objective (shown on the ﬁrst line) is a separable function of each
individual labeling decision, but the constraints (shown on the second line) apply to the
overall labeling. The sum P
(i,j)∈τ indicates that we are summing over all constituent
spans in the parse τ. The expression s.t. in the second line means that we maximize the
objective subject to the constraint y ∈ C(τ).
A number of practical algorithms exist for restricted forms of constrained optimiza-
tion. One such restricted form is integer linear programming, in which the objective and
constraints are linear functions of integer variables. To formulate SRL as an integer linear
program, we begin by rewriting the labels as a set of binary variables z = {zi,j,r} (Pun-
yakanok et al., ),
zi,j,r =
yi,j = r
otherwise,
Dynamic programming solutions have been proposed by Tromble and Eisner () and T¨ackstr¨om et al.
(), but they involves creating a trellis structure whose size is exponential in the number of labels.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
where r ∈ R is a label in the set {ARG, ARG, . . . , AM-LOC, . . . , ∅}. Thus, the variables
z are a binarized version of the semantic role labeling y.
The objective can then be formulated as a linear function of z.
i,j,r
ψ(w, r, i, j, ρ, τ) × zi,j,r,
(i,j)∈τ
ψ(w, yi,j, i, j, ρ, τ) =
which is the sum of the scores of all relations, as indicated by zi,j,r.
Constraints
Integer linear programming permits linear inequality constraints, of the
general form Az ≤ b, where the parameters A and b deﬁne the constraints. To make
this more concrete, let’s start with the constraint that each non-null role type can occur
only once in a sentence. This constraint can be written,
(i,j)∈τ
zi,j,r ≤ .
∀r ̸= ∅,
Recall that zi,j,r =  iff the span (i, j) has label r; this constraint says that for each possible
label r ̸= ∅, there can be at most one (i, j) such that zi,j,r = . Rewriting this constraint
can be written in the form Az ≤ b, as you will ﬁnd if you complete the exercises at the
end of the chapter.
Now consider the constraint that labels cannot overlap. Let’s deﬁne the convenience
function o((i, j), (i′, j′)) =  iff (i, j) overlaps (i′, j′), and zero otherwise. Thus, o will
indicate if a constituent (i′, j′) is either an ancestor or descendant of (i, j). The constraint
is that if two constituents overlap, only one can have a non-null label:
r̸=∅
o((i, j), (i′, j′)) × zi′,j′,r ≤ ,
(i′,j′)∈τ
∀(i, j) ∈ τ,
where o((i, j), (i, j)) = .
In summary, the semantic role labeling problem can thus be rewritten as the following
integer linear program,
max
z∈{,}|τ|
r∈R
zi,j,rψi,j,r
(i,j)∈τ
(i,j)∈τ
zi,j,r ≤ .
s.t.
∀r ̸= ∅,
r̸=∅
o((i, j), (i′, j′)) × zi′,j′,r ≤ .
(i′,j′)∈τ
∀(i, j) ∈ τ,
Jacob Eisenstein. Draft of November , .

.. SEMANTIC ROLE LABELING
Learning with constraints
Learning can be performed in the context of constrained op-
timization using the usual perceptron or large-margin classiﬁcation updates. Because
constrained inference is generally more time-consuming, a key question is whether it is
necessary to apply the constraints during learning. Chang et al. () ﬁnd that better per-
formance can be obtained by learning without constraints, and then applying constraints
only when using the trained model to predict semantic roles for unseen data.
How important are the constraints?
Das et al. () ﬁnd that an unconstrained, classiﬁcation-
based method performs nearly as well as constrained optimization for FrameNet parsing:
while it commits many violations of the “no-overlap” constraint, the overall F score is
less than one point worse than the score at the constrained optimum. Similar results
were obtained for PropBank semantic role labeling by Punyakanok et al. (). He et al.
() ﬁnd that constrained inference makes a bigger impact if the constraints are based
on manually-labeled “gold” syntactic parses. This implies that errors from the syntac-
tic parser may limit the effectiveness of the constraints. Punyakanok et al. () hedge
against parser error by including constituents from several different parsers; any con-
stituent can be selected from any parse, and additional constraints ensure that overlap-
ping constituents are not selected.
Implementation
Integer linear programming solvers such as glpk, cplex, and Gurobi
allow inequality constraints to be expressed directly in the problem deﬁnition, rather than
in the matrix form Az ≤ b. The time complexity of integer linear programming is theoret-
ically exponential in the number of variables |z|, but in practice these off-the-shelf solvers
obtain good solutions efﬁciently. Using a standard desktop computer, Das et al. ()
report that the cplex solver requires  seconds to perform inference on the FrameNet
test set, which contains , predicates.
Recent work has shown that many constrained optimization problems in natural lan-
guage processing can be solved in a highly parallelized fashion, using optimization tech-
niques such as dual decomposition, which are capable of exploiting the underlying prob-
lem structure (Rush et al., ). Das et al. () apply this technique to FrameNet se-
mantic role labeling, obtaining an order-of-magnitude speedup over cplex.
Neural semantic role labeling
Neural network approaches to SRL have tended to treat it as a sequence labeling task,
using a labeling scheme such as the BIO notation, which we previously saw in named
entity recognition (§ .). In this notation, the ﬁrst token in a span of type ARG is labeled
https://www.gnu.org/software/glpk/
https://www-.ibm.com/software/commerce/optimization/cplex-optimizer/
http://www.gurobi.com/
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
B-ARG; all remaining tokens in the span are inside, and are therefore labeled I-ARG.
Tokens outside any argument are labeled O. For example:
Asha
B-ARG
taught
PRED
Boyang
B-ARG
’s
I-ARG
mom
I-ARG
about
B-ARG
algebra
I-ARG
Recurrent neural networks (§ .) are a natural approach to this tagging task. For
example, Zhou and Xu () apply a deep bidirectional multilayer LSTM (see § .) to
PropBank semantic role labeling. In this model, each bidirectional LSTM serves as input
for another, higher-level bidirectional LSTM, allowing complex non-linear transforma-
tions of the original input embeddings, X = [x, x, . . . , xM]. The hidden state of the ﬁnal
LSTM is Z(K) = [z(K)
, z(K)
, . . . , z(K)
M ]. The “emission” score for each tag Ym = y is equal
to the inner product θy  z(K)
m , and there is also a transition score for each pair of adjacent
tags. The complete model can be written,
Z() =BiLSTM(X)
Z(i) =BiLSTM(Z(i−))
ˆy = argmax
m−
Θ(y)z(K)
+ ψym−,ym.
Note that the ﬁnal step maximizes over the entire labeling y, and includes a score for
each tag transition ψym−,ym. This combination of LSTM and pairwise potentials on tags
is an example of an LSTM-CRF. The maximization over y is performed by the Viterbi
algorithm.
This model strongly outperformed alternative approaches at the time, including con-
strained decoding and convolutional neural networks. More recent work has combined
recurrent neural network models with constrained decoding, using the A∗ search algo-
rithm to search over labelings that are feasible with respect to the constraints (He et al.,
). This yields small improvements over the method of Zhou and Xu (). He et al.
() obtain larger improvements by creating an ensemble of SRL systems, each trained
on an % subsample of the corpus. The average prediction across this ensemble is more
robust than any individual model.
Abstract Meaning Representation
Semantic role labeling transforms the task of semantic parsing to a labeling task. Consider
the sentence,
The successful application of convolutional neural networks to semantic role labeling by Collobert and
Weston () was an inﬂuential early result in the current wave of neural networks in natural language
processing.
Jacob Eisenstein. Draft of November , .

ABSTRACT MEANING REPRESENTATION
w / wants-
Arg
Arg
h / whale
p / pursue-
Arg
Arg
c / captain
(w / want-
:ARG (h / whale)
:ARG (p / pursue-
:ARG (c / captain)
:ARG h))
Figure .: Two views of the AMR representation for the sentence The whale wants the
captain to pursue him.
The whale wants the captain to pursue him.
The PropBank semantic role labeling analysis is:
(PREDICATE : wants, ARG : the whale, ARG : the captain to pursue him)
(PREDICATE : pursue, ARG : the captain, ARG : him)
The Abstract Meaning Representation (AMR) uniﬁes this analysis into a graph struc-
ture, in which each node is a variable, and each edge indicates a concept (Banarescu
et al., ). This can be written in two ways, as shown in Figure .. On the left is the
PENMAN notation (Matthiessen and Bateman, ), in which each set of parentheses in-
troduces a variable. Each variable is an instance of a concept, which is indicated with the
slash notation: for example, w / want- indicates that the variable w is an instance of
the concept want-, which in turn refers to the PropBank frame for the ﬁrst sense of the
verb want; pursue- refers to the second sense of pursue. Relations are introduced with
colons: for example, :ARG (c / captain) indicates a relation of type ARG with the
newly-introduced variable c. Variables can be reused, so that when the variable h ap-
pears again as an argument to p, it is understood to refer to the same whale in both cases.
This arrangement is indicated compactly in the graph structure on the right, with edges
indicating concepts.
One way in which AMR differs from PropBank-style semantic role labeling is that it
reiﬁes each entity as a variable: for example, the whale in (.) is reiﬁed in the variable
h, which is reused as ARG in its relationship with w / want-, and as ARG in its
relationship with p / pursue-. Reifying entities as variables also makes it possible
to represent the substructure of noun phrases more explicitly. For example, Asha borrowed
the algebra book would be represented as:
(b / borrow-
:ARG (p / person
:name (n / name
:op "Asha"))
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
:ARG (b / book
:topic (a / algebra)))
This indicates that the variable p is a person, whose name is the variable n; that name
has one token, the string Asha. Similarly, the variable b is a book, and the topic of b
is a variable a whose type is algebra. The relations name and topic are examples of
“non-core roles”, which are similar to adjunct modiﬁers in PropBank. However, AMR’s
inventory is more extensive, including more than  non-core roles, such as negation,
time, manner, frequency, and location. Lists and sequences — such as the list of tokens in
a name — are described using the roles op, op, etc.
Another feature of AMR is that a semantic predicate can be introduced by any syntac-
tic element, as in the following examples from Banarescu et al. ():
a. The boy destroyed the room.
b. the destruction of the room by the boy ...
c. the boy’s destruction of the room ...
All these examples have the same semantics in AMR,
(d / destroy-
:ARG (b / boy)
:ARG (r / room))
The noun destruction is linked to the verb destroy, which is captured by the PropBank
frame destroy-. This can happen with adjectives as well: in the phrase the attractive
spy, the adjective attractive is linked to the PropBank frame attract-:
(s / spy
:ARG-of (a / attract-))
In this example, ARG-of is an inverse relation, indicating that s is the ARG of the
predicate a. Inverse relations make it possible for all AMR parses to have a single root
concept.
While AMR goes farther than semantic role labeling, it does not link semantically-
related frames such as buy/sell (as FrameNet does). AMR also does not handle quan-
tiﬁcation (as ﬁrst-order predicate calculus does), and it makes no attempt to handle noun
number and verb tense (as PropBank does).
Jacob Eisenstein. Draft of November , .

.. ABSTRACT MEANING REPRESENTATION
AMR Parsing
Abstract Meaning Representation is not a labeling of the original text — unlike PropBank
semantic role labeling, and most of the other tagging and parsing tasks that we have
encountered thus far. The AMR for a given sentence may include multiple concepts for
single words in the sentence: as we have seen, the sentence Asha likes algebra contains both
person and name concepts for the word Asha. Conversely, words in the sentence may not
appear in the AMR: in Boyang made a tour of campus, the light verb make would not appear
in the AMR, which would instead be rooted on the predicate tour. As a result, AMR
is difﬁcult to parse, and even evaluating AMR parsing involves considerable algorithmic
complexity (Cai and Yates, ).
A further complexity is that AMR labeled datasets do not explicitly show the align-
ment between the AMR annotation and the words in the sentence. For example, the link
between the word wants and the concept want- is not annotated. To acquire train-
ing data for learning-based parsers, it is therefore necessary to ﬁrst perform an alignment
between the training sentences and their AMR parses. Flanigan et al. () introduce a
rule-based parser, which links text to concepts through a series of increasingly high-recall
steps.
As with dependency parsing, AMR can be parsed by graph-based methods that ex-
plore the space of graph structures, or by incremental transition-based algorithms. One
approach to graph-based AMR parsing is to ﬁrst group adjacent tokens into local sub-
structures, and then to search the space of graphs over these substructures (Flanigan et al.,
). The identiﬁcation of concept subgraphs can be formulated as a sequence labeling
problem, and the subsequent graph search can be solved using integer linear program-
ming (§ ..). Various transition-based parsing algorithms have been proposed. Wang
et al. () construct an AMR graph by incrementally modifying the syntactic depen-
dency graph. At each step, the parser performs an action: for example, adding an AMR
relation label to the current dependency edge, swapping the direction of a syntactic de-
pendency edge, or cutting an edge and reattaching the orphaned subtree to a new parent.
Additional resources
Practical semantic role labeling was ﬁrst made possible by the PropBank annotations on
the Penn Treebank (Palmer et al., ). Abend and Rappoport () survey several
semantic representation schemes, including semantic role labeling and AMR. Other lin-
guistic features of AMR are summarized in the original paper (Banarescu et al., ) and
the tutorial slides by Schneider et al. (). Recent shared tasks have undertaken seman-
tic dependency parsing, in which the goal is to identify semantic relationships between
pairs of words (Oepen et al., ); see Ivanova et al. () for an overview of connections
between syntactic and semantic dependencies.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
Exercises
. Write out an event semantic representation for the following sentences. You may
make up your own predicates.
Abigail shares with Max.
Abigail reluctantly shares a toy with Max.
Abigail hates to share with Max.
. Find the PropBank framesets for share and hate at http://verbs.colorado.edu/
propbank/framesets-english-aliases/, and rewrite your answers from the
previous question, using the thematic roles ARG, ARG, and ARG.
. Compute the syntactic path features for Abigail and Max in each of the example sen-
tences (.) and (.) in Question , with respect to the verb share. If you’re not
sure about the parse, you can try an online parser such as http://nlp.stanford.
edu:/parser/.
. Compute the dependency path features for Abigail and Max in each of the example
sentences (.) and (.) in Question , with respect to the verb share. Again, if
you’re not sure about the parse, you can try an online parser such as http://nlp.
stanford.edu:/parser/. As a hint, the dependency relation between share
and Max is OBL according to the Universal Dependency treebank.
. PropBank semantic role labeling includes reference arguments, such as,
[AM-LOC The bed] on [R-AM-LOC which] I slept broke.
The label R-AM-LOC indicates that the word which is a reference to The bed, which
expresses the location of the event. Reference arguments must have referents: the
tag R-AM-LOC can appear only when AM-LOC also appears in the sentence. Show
how to express this as a linear constraint, speciﬁcally for the tag R-AM-LOC. Be sure
to correctly handle the case in which neither AM-LOC nor R-AM-LOC appear in the
sentence.
. Explain how to express the constraints on semantic role labeling in Equation .
and Equation . in the general form Az ≥ b.
. Produce the AMR annotations for the following examples:
a. The girl likes the boy.
Example from  NAACL tutorial slides by Shumin Wu
Jacob Eisenstein. Draft of November , .

.. ABSTRACT MEANING REPRESENTATION
b. The girl was liked by the boy.
c. Abigail likes Maxwell Aristotle.
d. The spy likes the attractive boy.
e. The girl doesn’t like the boy.
f. The girl likes her dog.
For (.c), recall that multi-token names are created using op, op, etc. You will
need to consult Banarescu et al. () for (.e), and Schneider et al. () for
(.f). You may assume that her refers to the girl in this example.
. In this problem, you will build a FrameNet sense classiﬁer for the verb can, which
can evoke two frames: POSSIBILITY (can you order a salad with french fries?) and
CAPABILITY(can you eat a salad with chopsticks?).
To build the dataset, access the FrameNet corpus in NLTK:
import nltk
nltk.download(’framenet_v’)
from nltk.corpus import framenet as fn
Next, ﬁnd instances in which the lexical unit can.v (the verb form of can) evokes a
frame. Do this by iterating over fn.docs(), and then over sentences, and then
for doc in fn.docs():
if ’sentence’ in doc:
for sent in doc[’sentence’]:
for anno_set in sent[’annotationSet’]:
if ’luName’ in anno_set and anno_set[’luName’] == ’can.v’:
pass # your code here
Use the ﬁeld frameName as a label, and build a set of features from the ﬁeld text.
Train a classiﬁer to try to accurately predict the frameName, disregarding cases
other than CAPABILITY and POSSIBILITY. Treat the ﬁrst hundred instances as a train-
ing set, and the remaining instances as the test set. Can you do better than a classiﬁer
that simply selects the most common class?
. *Download the PropBank sample data, using NLTK (http://www.nltk.org/
howto/propbank.html).
a) Use a deep learning toolkit such as PyTorch to train a BiLSTM sequence label-
ing model (§ .) to identify words or phrases that are predicates, e.g., we/O
took/B-PRED a/I-PRED walk/I-PRED together/O. Your model should compute
the tag score from the BiLSTM hidden state ψ(ym) = βy  hm.
b) Optionally, implement Viterbi to improve the predictions of the model in the
previous section.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . PREDICATE-ARGUMENT SEMANTICS
c) Try to identify ARG and ARG for each predicate. You should again use the
BiLSTM and BIO notation, but you may want to include the BiLSTM hidden
state at the location of the predicate in your prediction model, e.g., ψ(ym) =
βy[hm; hˆr], where ˆr is the predicted location of the (ﬁrst word of the) predicate.
. Using an off-the-shelf PropBank SRL system, build a simpliﬁed question answer-
ing system in the style of Shen and Lapata (). Speciﬁcally, your system should
do the following:
For each document in a collection, it should apply the semantic role labeler,
and should store the output as a tuple.
For a question, your system should again apply the semantic role labeler. If
any of the roles are ﬁlled by a wh-pronoun, you should mark that role as the
expected answer phrase (EAP).
To answer the question, search for a stored tuple which matches the question as
well as possible (same predicate, no incompatible semantic roles, and as many
matching roles as possible). Align the EAP against its role ﬁller in the stored
tuple, and return this as the answer.
To evaluate your system, download a set of three news articles on the same topic,
and write down ﬁve factoid questions that should be answerable from the arti-
cles. See if your system can answer these questions correctly. (If this problem is
assigned to an entire class, you can build a large-scale test set and compare various
approaches.)
At the time of writing, the following systems are availabe: SENNA (http://ronan.collobert.
com/senna/),
Illinois
Semantic
Role
Labeler
(https://cogcomp.cs.illinois.edu/page/
software_view/SRL), and mate-tools (https://code.google.com/archive/p/mate-tools/).
Jacob Eisenstein. Draft of November , .

Chapter
Distributional and distributed
semantics
A recurring theme in natural language processing is the complexity of the mapping from
words to meaning. In chapter , we saw that a single word form, like bank, can have mul-
tiple meanings; conversely, a single meaning may be created by multiple surface forms,
a lexical semantic relationship known as synonymy. Despite this complex mapping be-
tween words and meaning, natural language processing systems usually rely on words
as the basic unit of analysis. This is especially true in semantics: the logical and frame
semantic methods from the previous two chapters rely on hand-crafted lexicons that map
from words to semantic predicates. But how can we analyze texts that contain words
that we haven’t seen before? This chapter describes methods that learn representations
of word meaning by analyzing unlabeled data, vastly improving the generalizability of
natural language processing systems. The theory that makes it possible to acquire mean-
ingful representations from unlabeled data is the distributional hypothesis.
The distributional hypothesis
Here’s a word you may not know: tezg¨uino (the example is from Lin, ). If you do not
know the meaning of tezg¨uino, then you are in the same situation as a natural language
processing system when it encounters a word that did not appear in its training data.
Now suppose you see that tezg¨uino is used in the following contexts:
A bottle of
is on the table.
Everybody likes
Don’t have
before you drive.
We make
out of corn.
CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
tezg¨uino
loud
motor oil
tortillas
choices
wine
Table .: Distributional statistics for tezg¨uino and ﬁve related terms
king
dark
darker
darkest
man
sir
emperor
soft
softer
softest
brother
uncle
duke
queen
clear
clearer
clearest
earl
nephew
woman
heir
short
madam
strong
stronger
strongest
loud
louder
loudest
empress
sister
aunt
duchess
shorter
shortest
niece
slow
countess
slower
slowest
heiress
Figure .: Lexical semantic relationships have regular linear structures in two dimen-
sional projections of distributional statistics (Pennington et al., ).
What other words ﬁt into these contexts? How about: loud, motor oil, tortillas, choices,
wine? Each row of Table . is a vector that summarizes the contextual properties for
each word, with a value of one for contexts in which the word can appear, and a value of
zero for contexts in which it cannot. Based on these vectors, we can conclude: wine is very
similar to tezg¨uino; motor oil and tortillas are fairly similar to tezg¨uino; loud is completely
different.
These vectors, which we will call word representations, describe the distributional
properties of each word. Does vector similarity imply semantic similarity? This is the dis-
tributional hypothesis, stated by Firth () as: “You shall know a word by the company
it keeps.” The distributional hypothesis has stood the test of time: distributional statistics
are a core part of language technology today, because they make it possible to leverage
large amounts of unlabeled data to learn about rare words that do not appear in labeled
training data.
Distributional statistics have a striking ability to capture lexical semantic relationships
Jacob Eisenstein. Draft of November , .

.. DESIGN DECISIONS FOR WORD REPRESENTATIONS
such as analogies. Figure . shows two examples, based on two-dimensional projections
of distributional word embeddings, discussed later in this chapter. In each case, word-
pair relationships correspond to regular linear patterns in this two dimensional space. No
labeled data about the nature of these relationships was required to identify this underly-
ing structure.
Distributional semantics are computed from context statistics. Distributed seman-
tics are a related but distinct idea: that meaning can be represented by numerical vectors
rather than symbolic structures. Distributed representations are often estimated from dis-
tributional statistics, as in latent semantic analysis and WORDVEC, described later in this
chapter. However, distributed representations can also be learned in a supervised fashion
from labeled data, as in the neural classiﬁcation models encountered in chapter .
Design decisions for word representations
There are many approaches for computing word representations, but most can be distin-
guished on three main dimensions: the nature of the representation, the source of contex-
tual information, and the estimation procedure.
Representation
Today, the dominant word representations are k-dimensional vectors of real numbers,
known as word embeddings. (The name is due to the fact that each discrete word is em-
bedded in a continuous vector space.) This representation dates back at least to the late
s (Deerwester et al., ), and is used in popular techniques such as WORDVEC (Mikolov
et al., ).
Word embeddings are well suited for neural networks, where they can be plugged
in as inputs. They can also be applied in linear classiﬁers and structure prediction mod-
els (Turian et al., ), although it can be difﬁcult to learn linear models that employ
real-valued features (Kummerfeld et al., ). A popular alternative is bit-string rep-
resentations, such as Brown clusters (§ .), in which each word is represented by a
variable-length sequence of zeros and ones (Brown et al., ).
Another representational question is whether to estimate one embedding per surface
form (e.g., bank), or to estimate distinct embeddings for each word sense or synset. In-
tuitively, if word representations are to capture the meaning of individual words, then
words with multiple meanings should have multiple embeddings. This can be achieved
by integrating unsupervised clustering with word embedding estimation (Huang and
Yates, ; Li and Jurafsky, ). However, Arora et al. () argue that it is unnec-
essary to model distinct word senses explicitly, because the embeddings for each surface
form are a linear combination of the embeddings of the underlying senses.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
The moment one learns English, complications set in (Alfau, )
Brown Clusters
{one}
WORDVEC, h =
{moment, one, English, complications}
Structured WORDVEC, h =
{(moment, −), (one, −), (English, +), (complications, +)}
Dependency contexts,
{(one, NSUBJ), (English, DOBJ), (moment, ACL−)}
Table .: Contexts for the word learns, according to various word representations. For
dependency context, (one, NSUBJ) means that there is a relation of type NSUBJ (nominal
subject) to the word one, and (moment, ACL−) means that there is a relation of type ACL
(adjectival clause) from the word moment.
Context
The distributional hypothesis says that word meaning is related to the “contexts” in which
the word appears, but context can be deﬁned in many ways. In the tezg¨uino example, con-
texts are entire sentences, but in practice there are far too many sentences. At the oppo-
site extreme, the context could be deﬁned as the immediately preceding word; this is the
context considered in Brown clusters. WORDVEC takes an intermediate approach, using
local neighborhoods of words (e.g., h = ) as contexts (Mikolov et al., ). Contexts
can also be much larger: for example, in latent semantic analysis, each word’s context
vector includes an entry per document, with a value of one if the word appears in the
document (Deerwester et al., ); in explicit semantic analysis, these documents are
Wikipedia pages (Gabrilovich and Markovitch, ).
In structured WORDVEC, context words are labeled by their position with respect to
the target word wm (e.g., two words before, one word after), which makes the result-
ing word representations more sensitive to syntactic differences (Ling et al., ). An-
other way to incorporate syntax is to perform parsing as a preprocessing step, and then
form context vectors from the dependency edges (Levy and Goldberg, ) or predicate-
argument relations (Lin, ). The resulting context vectors for several of these methods
are shown in Table ..
The choice of context has a profound effect on the resulting representations, which
can be viewed in terms of word similarity. Applying latent semantic analysis (§ .) to
contexts of size h =  and h =  yields the following nearest-neighbors for the word
dog:
(h = ): cat, horse, fox, pet, rabbit, pig, animal, mongrel, sheep, pigeon
The example is from lecture slides by Marco Baroni, Alessandro Lenci, and Stefan Evert, who applied
latent semantic analysis to the British National Corpus. You can ﬁnd an online demo here: http://clic.
cimec.unitn.it/infomap-query/
Jacob Eisenstein. Draft of November , .

.. LATENT SEMANTIC ANALYSIS
(h = ): kennel, puppy, pet, bitch, terrier, rottweiler, canine, cat, to bark, Alsatian
Which word list is better? Each word in the h =  list is an animal, reﬂecting the fact that
locally, the word dog tends to appear in the same contexts as other animal types (e.g., pet
the dog, feed the dog). In the h =  list, nearly everything is dog-related, including speciﬁc
breeds such as rottweiler and Alsatian. The list also includes words that are not animals
(kennel), and in one case (to bark), is not a noun at all. The -word context window is more
sensitive to syntax, while the -word window is more sensitive to topic.
Estimation
Word embeddings are estimated by optimizing some objective: the likelihood of a set of
unlabeled data (or a closely related quantity), or the reconstruction of a matrix of context
counts, similar to Table ..
Maximum likelihood estimation
Likelihood-based optimization is derived from the
objective log p(w; U), where U ∈ RK × V is matrix of word embeddings, and w =
{wm}M
m= is a corpus, represented as a list of M tokens. Recurrent neural network lan-
guage models (§ .) optimize this objective directly, backpropagating to the input word
embeddings through the recurrent structure. However, state-of-the-art word embeddings
employ huge corpora with hundreds of billions of tokens, and recurrent architectures are
difﬁcult to scale to such data. As a result, likelihood-based word embeddings are usually
based on simpliﬁed likelihoods or heuristic approximations.
Matrix factorization
The matrix C = {count(i, j)} stores the co-occurrence counts of
word i and context j. Word representations can be obtained by approximately factoring
this matrix, so that count(i, j) is approximated by a function of a word embedding ui and
a context embedding vj. These embeddings can be obtained by minimizing the norm of
the reconstruction error,
min
u,v ||C − ˜C(u, v)||F ,
where ˜C(u, v) is the approximate reconstruction resulting from the embeddings u and
v, and ||X||F indicates the Frobenius norm, P
i,j x
i,j. Rather than factoring the matrix of
word-context counts directly, it is often helpful to transform these counts using information-
theoretic metrics such as pointwise mutual information (PMI), described in the next sec-
tion.
Latent semantic analysis
Latent semantic analysis (LSA) is one of the oldest approaches to distributed seman-
tics (Deerwester et al., ). It induces continuous vector representations of words by
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
factoring a matrix of word and context counts, using truncated singular value decompo-
sition (SVD),
min
U∈RV ×K,S∈RK×K,V∈R|C|×K
||C − USV⊤||F
s.t.
U⊤U = I
V⊤V = I
∀i ̸= j, Si,j = ,
where V is the size of the vocabulary, |C| is the number of contexts, and K is size of the
resulting embeddings, which are set equal to the rows of the matrix U. The matrix S is
constrained to be diagonal (these diagonal elements are called the singular values), and
the columns of the product SV⊤ provide descriptions of the contexts. Each element ci,j is
then reconstructed as a bilinear product,
ci,j ≈
k=
ui,kskvj,k.
The objective is to minimize the sum of squared approximation errors. The orthonormal-
ity constraints U⊤U = V⊤V = I ensure that all pairs of dimensions in U and V are
uncorrelated, so that each dimension conveys unique information. Efﬁcient implemen-
tations of truncated singular value decomposition are available in numerical computing
packages such as SCIPY and MATLAB.
Latent semantic analysis is most effective when the count matrix is transformed before
the application of SVD. One such transformation is pointwise mutual information (PMI;
Church and Hanks, ), which captures the degree of association between word i and
context j,
PMI(i, j) = log p(i, j)
p(i)p(j) = log p(i | j)p(j)
p(i)p(j)
= log p(i | j)
p(i)
= log count(i, j) − log
i′=
count(i′, j)
i′=
j′∈C
count(i, j′) + log
j′∈C
count(i′, j′).
− log
The pointwise mutual information can be viewed as the logarithm of the ratio of the con-
ditional probability of word i in context j to the marginal probability of word i in all
An important implementation detail is to represent C as a sparse matrix, so that the storage cost is equal
to the number of non-zero entries, rather than the size V × |C|.
Jacob Eisenstein. Draft of November , .

.. BROWN CLUSTERS
evaluation
assessment
reps
analysis
representatives
understanding
representative
opinion
rep
conversation
discussion
accounts
people
day
year
customers
week
individuals
employees
month
quarter
students
half
Figure .: Subtrees produced by bottom-up Brown clustering on news text (Miller et al.,
contexts. When word i is statistically associated with context j, the ratio will be greater
than one, so PMI(i, j) > . The PMI transformation focuses latent semantic analysis on re-
constructing strong word-context associations, rather than on reconstructing large counts.
The PMI is negative when a word and context occur together less often than if they
were independent, but such negative correlations are unreliable because counts of rare
events have high variance. Furthermore, the PMI is undeﬁned when count(i, j) = . One
solution to these problems is to use the Positive PMI (PPMI),
PPMI(i, j) =
PMI(i, j),
p(i | j) > p(i)
otherwise.
Bullinaria and Levy () compare a range of matrix transformations for latent se-
mantic analysis, using a battery of tasks related to word meaning and word similarity
(for more on evaluation, see § .). They ﬁnd that PPMI-based latent semantic analysis
yields strong performance on a battery of tasks related to word meaning: for example,
PPMI-based LSA vectors can be used to solve multiple-choice word similarity questions
from the Test of English as a Foreign Language (TOEFL), obtaining % accuracy.
Brown clusters
Learning algorithms like perceptron and conditional random ﬁelds often perform better
with discrete feature vectors. A simple way to obtain discrete representations from distri-
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
bitstring
ten most frequent words
excited thankful grateful stoked pumped anxious hyped psyched
exited geeked
talking talkin complaining talkn bitching tlkn tlkin bragging rav-
ing +k
thinking thinkin dreaming worrying thinkn speakin reminiscing
dreamin daydreaming fantasizing
saying sayin suggesting stating sayn jokin talmbout implying
insisting ’
wonder dunno wondered duno donno dno dono wonda wounder
dunnoe
wondering wonders debating deciding pondering unsure won-
derin debatin woundering wondern
sure suree suuure suure sure- surre sures shuree
Table .: Fragment of a Brown clustering of Twitter data (Owoputi et al., ). Each
row is a leaf in the tree, showing the ten most frequent words. This part of the tree
emphasizes verbs of communicating and knowing, especially in the present partici-
ple. Each leaf node includes orthographic variants (thinking, thinkin, thinkn), semanti-
cally related terms (excited, thankful, grateful), and some outliers (’, +k). See http:
//www.cs.cmu.edu/˜ark/TweetNLP/cluster_viewer.html for more.
butional statistics is by clustering (§ ..), so that words in the same cluster have similar
distributional statistics. This can help in downstream tasks, by sharing features between
all words in the same cluster. However, there is an obvious tradeoff: if the number of clus-
ters is too small, the words in each cluster will not have much in common; if the number
of clusters is too large, then the learner will not see enough examples from each cluster to
generalize.
A solution to this problem is hierarchical clustering: using the distributional statistics
to induce a tree-structured representation. Fragments of Brown cluster trees are shown in
Figure . and Table .. Each word’s representation consists of a binary string describ-
ing a path through the tree:  for taking the left branch, and  for taking the right branch.
In the subtree in the upper right of the ﬁgure, the representation of the word conversation
is ; the representation of the word assessment is . Bitstring preﬁxes capture similar-
ity at varying levels of speciﬁcity, and it is common to use the ﬁrst eight, twelve, sixteen,
and twenty bits as features in tasks such as named entity recognition (Miller et al., )
and dependency parsing (Koo et al., ).
Hierarchical trees can be induced from a likelihood-based objective, using a discrete
Jacob Eisenstein. Draft of November , .

.. BROWN CLUSTERS
latent variable ki ∈ {, , . . . , K} to represent the cluster of word i:
log p(w; k) ≈
m=
log p(wm | wm−; k)
m=
log p(wm | kwm) + log p(kwm | kwm−).
This is similar to a hidden Markov model, with the crucial difference that each word can
be emitted from only a single cluster: ∀k ̸= kwm, p(wm | k) = .
Using the objective in Equation ., the Brown clustering tree can be constructed
from the bottom up: begin with each word in its own cluster, and incrementally merge
clusters until only a single cluster remains. At each step, we merge the pair of clusters
such that the objective in Equation . is maximized. Although the objective seems to
involve a sum over the entire corpus, the score for each merger can be computed from
the cluster-to-cluster co-occurrence counts. These counts can be updated incrementally as
the clustering proceeds. The optimal merge at each step can be shown to maximize the
average mutual information,
I(k) =
k=
k=
p(k, k) × PMI(k, k)
p(k, k) =
count(k, k)
PK
k′=
PK
k′= count(k′, k′)
where p(k, k) is the joint probability of a bigram involving a word in cluster k followed
by a word in k. This probability and the PMI are both computed from the co-occurrence
counts between clusters. After each merger, the co-occurrence vectors for the merged
clusters are simply added up, so that the next optimal merger can be found efﬁciently.
This bottom-up procedure requires iterating over the entire vocabulary, and evaluat-
ing K
t possible mergers at each step, where Kt is the current number of clusters at step t
of the algorithm. Furthermore, computing the score for each merger involves a sum over
t clusters. The maximum number of clusters is K = V , which occurs when every word
is in its own cluster at the beginning of the algorithm. The time complexity is thus O(V ).
To avoid this complexity, practical implementations use a heuristic approximation
called exchange clustering. The K most common words are placed in clusters of their
own at the beginning of the process. We then consider the next most common word, and
merge it with one of the existing clusters. This continues until the entire vocabulary has
been incorporated, at which point the K clusters are merged down to a single cluster,
forming a tree. The algorithm never considers more than K +  clusters at any step, and
the complexity is O(V K + V log V ), with the second term representing the cost of sorting
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
vwm
vwm−
vwm−
vwm
vwm+
vwm+
wm
wm−
wm−
wm+
wm+
wm−
wm−
wm
wm+
wm+
(a) Continuous bag-of-words (CBOW)
(b) Skipgram
Figure .: The CBOW and skipgram variants of WORDVEC. The parameter U is the
matrix of word embeddings, and each vm is the context embedding for word wm.
the words at the beginning of the algorithm. For more details on the algorithm, see Liang
Neural word embeddings
Neural word embeddings combine aspects of the previous two methods: like latent se-
mantic analysis, they are a continuous vector representation; like Brown clusters, they are
trained from a likelihood-based objective. Let the vector ui represent the K-dimensional
embedding for word i, and let vj represent the K-dimensional embedding for context
j. The inner product ui  vj represents the compatibility between word i and context j.
By incorporating this inner product into an approximation to the log-likelihood of a cor-
pus, it is possible to estimate both parameters by backpropagation. WORDVEC (Mikolov
et al., ) includes two such approximations: continuous bag-of-words (CBOW) and
skipgrams.
Continuous bag-of-words (CBOW)
In recurrent neural network language models, each word wm is conditioned on a recurrently-
updated state vector, which is based on word representations going all the way back to the
beginning of the text. The continuous bag-of-words (CBOW) model is a simpliﬁcation:
the local context is computed as an average of embeddings for words in the immediate
neighborhood m − h, m − h + , . . . , m + h − , m + h,
vm =
n=
vwm+n + vwm−n.
Thus, CBOW is a bag-of-words model, because the order of the context words does not
matter; it is continuous, because rather than conditioning on the words themselves, we
condition on a continuous vector constructed from the word embeddings. The parameter
h determines the neighborhood size, which Mikolov et al. () set to h = .
Jacob Eisenstein. Draft of November , .

.. NEURAL WORD EMBEDDINGS
The CBOW model optimizes an approximation to the corpus log-likelihood,
log p(w) ≈
m=
log p(wm | wm−h, wm−h+, . . . , wm+h−, wm+h)
m=
log
exp (uwm  vm)
PV
j= exp (uj  vm)
m=
uwm  vm − log
j=
exp (uj  vm) .
Skipgrams
In the CBOW model, words are predicted from their context. In the skipgram model, the
context is predicted from the word, yielding the objective:
log p(w) ≈
m=
n=
log p(wm−n | wm) + log p(wm+n | wm)
hm
m=
n=
log exp(uwm−n  vwm)
hm
PV
j= exp(uj  vwm)
+ log exp(uwm+n  vwm)
PV
j= exp(uj  vwm)
m=
n=
uwm−n  vwm + uwm+n  vwm −  log
j=
exp (uj  vwm) .
hm
In the skipgram approximation, each word is generated multiple times; each time it is con-
ditioned only on a single word. This makes it possible to avoid averaging the word vec-
tors, as in the CBOW model. The local neighborhood size hm is randomly sampled from
a uniform categorical distribution over the range {, , . . . , hmax}; Mikolov et al. () set
hmax = . Because the neighborhood grows outward with h, this approach has the effect
of weighting near neighbors more than distant ones. Skipgram performs better on most
evaluations than CBOW (see § . for details of how to evaluate word representations),
but CBOW is faster to train (Mikolov et al., ).
Computational complexity
The WORDVEC models can be viewed as an efﬁcient alternative to recurrent neural net-
work language models, which involve a recurrent state update whose time complexity
is quadratic in the size of the recurrent state vector. CBOW and skipgram avoid this
computation, and incur only a linear time complexity in the size of the word and con-
text representations. However, all three models compute a normalized probability over
word tokens; a na¨ıve implementation of this probability requires summing over the entire
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
Ahab
σ(u  vc)
whale
σ(−u  vc) × σ(u  vc)
blubber
σ(−u  vc) × σ(−u  vc)
Figure .: A fragment of a hierarchical softmax tree. The probability of each word is
computed as a product of probabilities of local branching decisions in the tree.
vocabulary. The time complexity of this sum is O(V ×K), which dominates all other com-
putational costs. There are two solutions: hierarchical softmax, a tree-based computation
that reduces the cost to a logarithm of the size of the vocabulary; and negative sampling,
an approximation that eliminates the dependence on vocabulary size. Both methods are
also applicable to RNN language models.
Hierarchical softmax
In Brown clustering, the vocabulary is organized into a binary tree.
Mnih and Hin-
ton () show that the normalized probability over words in the vocabulary can be
reparametrized as a probability over paths through such a tree. This hierarchical softmax
probability is computed as a product of binary decisions over whether to move left or
right through the tree, with each binary decision represented as a sigmoid function of the
inner product between the context embedding vc and an output embedding associated
with the node un,
Pr(left at n | c) =σ(un  vc)
Pr(right at n | c) = − σ(un  vc) = σ(−un  vc),
where σ refers to the sigmoid function, σ(x) =
+exp(−x). The range of the sigmoid is the
interval (, ), and  − σ(x) = σ(−x).
As shown in Figure ., the probability of generating each word is redeﬁned as the
product of the probabilities across its path. The sum of all such path probabilities is guar-
anteed to be one, for any context vector vc ∈ RK. In a balanced binary tree, the depth is
logarithmic in the number of leaf nodes, and thus the number of multiplications is equal
to O(log V ). The number of non-leaf nodes is equal to O(V − ), so the number of pa-
rameters to be estimated increases by only a small multiple. The tree can be constructed
using an incremental clustering procedure similar to hierarchical Brown clusters (Mnih
Jacob Eisenstein. Draft of November , .

.. NEURAL WORD EMBEDDINGS
and Hinton, ), or by using the Huffman () encoding algorithm for lossless com-
pression.
Negative sampling
Likelihood-based methods are computationally intensive because each probability must
be normalized over the vocabulary. These probabilities are based on scores for each word
in each context, and it is possible to design an alternative objective that is based on these
scores more directly: we seek word embeddings that maximize the score for the word that
was really observed in each context, while minimizing the scores for a set of randomly
selected negative samples:
i′∈Wneg
log( − σ(ui′  vj)),
ψ(i, j) = log σ(ui  vj) +
where ψ(i, j) is the score for word i in context j, and Wneg is the set of negative samples.
The objective is to maximize the sum over the corpus, PM
m= ψ(wm, cm), where wm is
token m and cm is the associated context.
The set of negative samples Wneg is obtained by sampling from a unigram language
model. Mikolov et al. () construct this unigram language model by exponentiating
the empirical word probabilities, setting ˆp(i) ∝ (count(i))
. This has the effect of redis-
tributing probability mass from common to rare words. The number of negative samples
increases the time complexity of training by a constant factor. Mikolov et al. () report
that - negative samples works for small training sets, and that two to ﬁve samples
sufﬁce for larger corpora.
Word embeddings as matrix factorization
The negative sampling objective in Equation . can be justiﬁed as an efﬁcient approx-
imation to the log-likelihood, but it is also closely linked to the matrix factorization ob-
jective employed in latent semantic analysis. For a matrix of word-context pairs in which
all counts are non-zero, negative sampling is equivalent to factorization of the matrix M,
where Mij = PMI(i, j) − log k: each cell in the matrix is equal to the pointwise mutual
information of the word and context, shifted by log k, with k equal to the number of neg-
ative samples (Levy and Goldberg, ). For word-context pairs that are not observed in
the data, the pointwise mutual information is −∞, but this can be addressed by consid-
ering only PMI values that are greater than log k, resulting in a matrix of shifted positive
pointwise mutual information,
Mij = max(, PMI(i, j) − log k).
Word embeddings are obtained by factoring this matrix with truncated singular value
decomposition.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
word
word
similarity
love
sex
stock
jaguar
money
cash
development
issue
lad
brother
Table .: Subset of the WS- (Finkelstein et al., ) dataset of word similarity ratings
(examples from Faruqui et al. ()).
GloVe (“global vectors”) are a closely related approach (Pennington et al., ), in
which the matrix to be factored is constructed from log co-occurrence counts, Mij =
log count(i, j). The word embeddings are estimated by minimizing the sum of squares,
log Mij
min
u,v,b,˜b
j=
− log Mij
j∈C
f(Mij)

s.t.
log Mij
= ui  vj + bi + ˜bj,
where bi and ˜bj are offsets for word i and context j, which are estimated jointly with the
embeddings u and v. The weighting function f(Mij) is set to be zero at Mij = , thus
avoiding the problem of taking the logarithm of zero counts; it saturates at Mij = mmax,
thus avoiding the problem of overcounting common word-context pairs. This heuristic
turns out to be critical to the method’s performance.
The time complexity of sparse matrix reconstruction is determined by the number of
non-zero word-context counts. Pennington et al. () show that this number grows
sublinearly with the size of the dataset: roughly O(N.) for typical English corpora. In
contrast, the time complexity of WORDVEC is linear in the corpus size. Computing the co-
occurrence counts also requires linear time in the size of the corpus, but this operation can
easily be parallelized using MapReduce-style algorithms (Dean and Ghemawat, ).
Evaluating word embeddings
Distributed word representations can be evaluated in two main ways. Intrinsic evalu-
ations test whether the representations cohere with our intuitions about word meaning.
Extrinsic evaluations test whether they are useful for downstream tasks, such as sequence
labeling.
Jacob Eisenstein. Draft of November , .

.. EVALUATING WORD EMBEDDINGS
Intrinsic evaluations
A basic question for word embeddings is whether the similarity of words i and j is re-
ﬂected in the similarity of the vectors ui and uj. Cosine similarity is typically used to
compare two word embeddings,
cos(ui, uj) =
ui  uj
||ui|| × ||uj||
For any embedding method, we can evaluate whether the cosine similarity of word em-
beddings is correlated with human judgments of word similarity. The WS- dataset (Finkel-
stein et al., ) includes similarity scores for  word pairs (Table .). To test the
accuracy of embeddings for rare and morphologically complex words, Luong et al. ()
introduce a dataset of “rare words.” Outside of English, word similarity resources are lim-
ited, mainly consisting of translations of WS- and the related SimLex- dataset (Hill
et al., ).
Word analogies (e.g., king:queen :: man:woman) have also been used to evaluate word
embeddings (Mikolov et al., ). In this evaluation, the system is provided with the ﬁrst
three parts of the analogy (i : j :: i :?), and the ﬁnal element is predicted by ﬁnding the
word embedding most similar to ui − uj + ui. Another evaluation tests whether word
embeddings are related to broad lexical semantic categories called supersenses (Ciaramita
and Johnson, ): verbs of motion, nouns that describe animals, nouns that describe
body parts, and so on. These supersenses are annotated for English synsets in Word-
Net (Fellbaum, ). This evaluation is implemented in the QVEC metric, which tests
whether the matrix of supersenses can be reconstructed from the matrix of word embed-
dings (Tsvetkov et al., ).
Levy et al. () compared several dense word representations for English — includ-
ing latent semantic analysis, WORDVEC, and GloVe — using six word similarity metrics
and two analogy tasks. None of the embeddings outperformed the others on every task,
but skipgrams were the most broadly competitive. Hyperparameter tuning played a key
role: any method will perform badly if the wrong hyperparameters are used. Relevant
hyperparameters include the embedding size, as well as algorithm-speciﬁc details such
as the neighborhood size and the number of negative samples.
Extrinsic evaluations
Word representations contribute to downstream tasks like sequence labeling and docu-
ment classiﬁcation by enabling generalization across words. The use of distributed repre-
sentations as features is a form of semi-supervised learning, in which performance on a
supervised learning problem is augmented by learning distributed representations from
unlabeled data (Miller et al., ; Koo et al., ; Turian et al., ). These pre-trained
word representations can be used as features in a linear prediction model, or as the input
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
layer in a neural network, such as a Bi-LSTM tagging model (§ .). Word representations
can be evaluated by the performance of the downstream systems that consume them:
for example, GloVe embeddings are convincingly better than Latent Semantic Analysis
as features in the downstream task of named entity recognition (Pennington et al., ).
Unfortunately, extrinsic and intrinsic evaluations do not always point in the same direc-
tion, and the best word representations for one downstream task may perform poorly on
another task (Schnabel et al., ).
When word representations are updated from labeled data in the downstream task,
they are said to be ﬁne-tuned. When labeled data is plentiful, pre-training may be un-
necessary; when labeled data is scarce, ﬁne-tuning may lead to overﬁtting. Various com-
binations of pre-training and ﬁne-tuning can be employed. Pre-trained embeddings can
be used as initialization before ﬁne-tuning, and this can substantially improve perfor-
mance (Lample et al., ). Alternatively, both ﬁne-tuned and pre-trained embeddings
can be used as inputs in a single model (Kim, ).
In semi-supervised scenarios, pretrained word embeddings can be replaced by “con-
textualized” word representations (Peters et al., ). These contextualized represen-
tations are set to the hidden states of a deep bi-directional LSTM, which is trained as a
bi-directional language model, motivating the name ELMo (embeddings from language
models). By running the language model, we obtain contextualized word representa-
tions, which can then be used as the base layer in a supervised neural network for any
task. This approach yields signiﬁcant gains over pretrained word embeddings on several
tasks, presumably because the contextualized embeddings use unlabeled data to learn
how to integrate linguistic context into the base layer of the supervised neural network.
Fairness and bias
Figure . shows how word embeddings can capture analogies such as man:woman ::
king:queen. While king and queen are gender-speciﬁc by deﬁnition, other professions or
titles are associated with genders and other groups merely by statistical tendency. This
statistical tendency may be a fact about the world (e.g., professional baseball players are
usually men), or a fact about the text corpus (e.g., there are professional basketball leagues
for both women and men, but the men’s basketball is written about far more often).
There is now considerable evidence that word embeddings do indeed encode such bi-
ases. Bolukbasi et al. () show that the words most aligned with the vector difference
she − he are stereotypically female professions homemaker, nurse, receptionist; in the other
direction are maestro, skipper, protege. Caliskan et al. () systematize this observation by
showing that biases in word embeddings align with well-validated gender stereotypes.
Garg et al. () extend these results to ethnic stereotypes of Asian Americans, and pro-
vide a historical perspective on how stereotypes evolve over  years of text data.
Because word embeddings are the input layer for many other natural language pro-
Jacob Eisenstein. Draft of November , .

.. DISTRIBUTED REPRESENTATIONS BEYOND DISTRIBUTIONAL STATISTICS
cessing systems, these ﬁndings highlight the risk that natural language processing will
replicate and amplify biases in the world, as well as in text. If, for example, word em-
beddings encode the belief that women are as unlikely to be programmers as they are to
be nephews, then software is unlikely to successfully parse, translate, index, and generate
texts in which women do indeed program computers. For example, contemporary NLP
systems often fail to properly resolve pronoun references in texts that cut against gender
stereotypes (Rudinger et al., ; Zhao et al., ). (The task of pronoun resolution is
described in depth in chapter .) Such biases can have profound consequences: for exam-
ple, search engines are more likely to yield personalized advertisements for public arrest
records when queried with names that are statistically associated with African Ameri-
cans (Sweeney, ). There is now an active research literature on “debiasing” machine
learning and natural language processing, as evidenced by the growth of annual meet-
ings such as Fairness, Accountability, and Transparency in Machine Learning (FAT/ML).
However, given that the ultimate source of these biases is the text itself, it may be too
much to hope for a purely algorithmic solution. There is no substitute for critical thought
about the inputs to natural language processing systems – and the uses of their outputs.
Distributed representations beyond distributional statistics
Distributional word representations can be estimated from huge unlabeled datasets, thereby
covering many words that do not appear in labeled data: for example, GloVe embeddings
are estimated from  billion tokens of web data, while the largest labeled datasets for
NLP tasks are on the order of millions of tokens. Nonetheless, even a dataset of hundreds
of billions of tokens will not cover every word that may be encountered in the future.
Furthermore, many words will appear only a few times, making their embeddings un-
reliable. Many languages exceed English in morphological complexity, and thus have
lower token-to-type ratios. When this problem is coupled with small training corpora, it
becomes especially important to leverage other sources of information beyond distribu-
tional statistics.
Word-internal structure
One solution is to incorporate word-internal structure into word embeddings. Purely
distributional approaches consider words as atomic units, but in fact, many words have
internal structure, so that their meaning can be composed from the representations of
sub-word units. Consider the following terms, all of which are missing from Google’s
pre-trained WORDVEC embeddings:
http://commoncrawl.org/
https://code.google.com/archive/p/wordvec/, accessed September ,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
umillicuries
umillicurie
umillicuries
˜umillicuries
u(M)
milli+
u(M)
curie
u(M)
+s
u(M)
milli+
u(M)
curie
u(M)
+s
Figure .: Two architectures for building word embeddings from subword units. On the
left, morpheme embeddings u(m) are combined by addition with the non-compositional
word embedding ˜u (Botha and Blunsom, ). On the right, morpheme embeddings are
combined in a recursive neural network (Luong et al., ).
millicuries This word has morphological structure (see § .. for more on morphology):
the preﬁx milli- indicates an amount, and the sufﬁx -s indicates a plural. (A millicurie
is an unit of radioactivity.)
caesium This word is a single morpheme, but the characters -ium are often associated
with chemical elements.
(Caesium is the British spelling of a chemical element,
spelled cesium in American English.)
IAEA This term is an acronym, as suggested by the use of capitalization. The preﬁx I- fre-
quently refers to international organizations, and the sufﬁx -A often refers to agen-
cies or associations. (IAEA is the International Atomic Energy Agency.)
Zhezhgan This term is in title case, suggesting the name of a person or place, and the
character bigram zh indicates that it is likely a transliteration. (Zhezhgan is a mining
facility in Kazakhstan.)
How can word-internal structure be incorporated into word representations? One
approach is to construct word representations from embeddings of the characters or mor-
phemes. For example, if word i has morphological segments Mi, then its embedding can
be constructed by addition (Botha and Blunsom, ),
j∈Mi
u(M)
ui = ˜ui +
where u(M)
is a morpheme embedding and ˜ui is a non-compositional embedding of the
whole word, which is an additional free parameter of the model (Figure ., left side).
All embeddings are estimated from a log-bilinear language model (Mnih and Hinton,
), which is similar to the CBOW model (§ .), but includes only contextual informa-
tion from preceding words. The morphological segments are obtained using an unsuper-
vised segmenter (Creutz and Lagus, ). For words that do not appear in the training
Jacob Eisenstein. Draft of November , .

.. DISTRIBUTED REPRESENTATIONS BEYOND DISTRIBUTIONAL STATISTICS
data, the embedding can be constructed directly from the morphemes, assuming that each
morpheme appears in some other word in the training data. The free parameter ˜u adds
ﬂexibility: words with similar morphemes are encouraged to have similar embeddings,
but this parameter makes it possible for them to be different.
Word-internal structure can be incorporated into word representations in various other
ways. Here are some of the main parameters.
Subword units. Examples like IAEA and Zhezhgan are not based on morphological com-
position, and a morphological segmenter is unlikely to identify meaningful sub-
word units for these terms. Rather than using morphemes for subword embeddings,
one can use characters (Santos and Zadrozny, ; Ling et al., ; Kim et al., ),
character n-grams (Wieting et al., a; Bojanowski et al., ), and byte-pair en-
codings, a compression technique which captures frequent substrings (Gage, ;
Sennrich et al., ).
Composition. Combining the subword embeddings by addition does not differentiate
between orderings, nor does it identify any particular morpheme as the root. A
range of more ﬂexible compositional models have been considered, including re-
currence (Ling et al., ), convolution (Santos and Zadrozny, ; Kim et al.,
), and recursive neural networks (Luong et al., ), in which representa-
tions of progressively larger units are constructed over a morphological parse, e.g.
((milli+curie)+s), ((in+ﬂam)+able), (in+(vis+ible)). A recursive embedding model is
shown in the right panel of Figure ..
Estimation. Estimating subword embeddings from a full dataset is computationally ex-
pensive. An alternative approach is to train a subword model to match pre-trained
word embeddings (Cotterell et al., ; Pinter et al., ). To train such a model, it
is only necessary to iterate over the vocabulary, and not the corpus.
Lexical semantic resources
Resources such as WordNet provide another source of information about word meaning:
if we know that caesium is a synonym of cesium, or that a millicurie is a type of measurement
unit, then this should help to provide embeddings for the unknown words, and to smooth
embeddings of rare words. One way to do this is to retroﬁt pre-trained word embeddings
across a network of lexical semantic relationships (Faruqui et al., ) by minimizing the
following objective,
min
(i,j)∈L
βij||ui − uj||,
j=
||ui − ˆui|| +
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
where ˆui is the pretrained embedding of word i, and L = {(i, j)} is a lexicon of word
relations.
The hyperparameter βij controls the importance of adjacent words having
similar embeddings; Faruqui et al. () set it to the inverse of the degree of word i,
βij = |{j : (i, j) ∈ L}|−. Retroﬁtting improves performance on a range of intrinsic evalu-
ations, and gives small improvements on an extrinsic document classiﬁcation task.
Distributed representations of multiword units
Can distributed representations extend to phrases, sentences, paragraphs, and beyond?
Before exploring this possibility, recall the distinction between distributed and distri-
butional representations. Neural embeddings such as WORDVEC are both distributed
(vector-based) and distributional (derived from counts of words in context). As we con-
sider larger units of text, the counts decrease: in the limit, a multi-paragraph span of text
would never appear twice, except by plagiarism. Thus, the meaning of a large span of
text cannot be determined from distributional statistics alone; it must be computed com-
positionally from smaller spans. But these considerations are orthogonal to the question
of whether distributed representations — dense numerical vectors — are sufﬁciently ex-
pressive to capture the meaning of phrases, sentences, and paragraphs.
Purely distributional methods
Some multiword phrases are non-compositional: the meaning of such phrases is not de-
rived from the meaning of the individual words using typical compositional semantics.
This includes proper nouns like San Francisco as well as idiomatic expressions like kick
the bucket (Baldwin and Kim, ). For these cases, purely distributional approaches
can work. A simple approach is to identify multiword units that appear together fre-
quently, and then treat these units as words, learning embeddings using a technique such
as WORDVEC.
The problem of identifying multiword units is sometimes called collocation extrac-
tion. A good collocation has high pointwise mutual information (PMI; see § .). For
example, Na¨ıve Bayes is a good collocation because p(wt = Bayes | wt− = na¨ıve) is much
larger than p(wt = Bayes). Collocations of more than two words can be identiﬁed by a
greedy incremental search: for example, mutual information might ﬁrst be extracted as a
collocation and grouped into a single word type mutual information; then pointwise mu-
tual information can be extracted later. After identifying such units, they can be treated as
words when estimating skipgram embeddings. Mikolov et al. () show that the result-
ing embeddings perform reasonably well on a task of solving phrasal analogies, e.g. New
York : New York Times :: Baltimore : Baltimore Sun.
Jacob Eisenstein. Draft of November , .

.. DISTRIBUTED REPRESENTATIONS OF MULTIWORD UNITS
this was the only way
it was the only way
it was her turn to blink
it was hard to tell
it was time to move on
he had to do it again
they all looked at each other
they all turned to look back
they both turned to face him
they both turned and walked away
Figure .: By interpolating between the distributed representations of two sentences (in
bold), it is possible to generate grammatical sentences that combine aspects of both (Bow-
man et al., )
Distributional-compositional hybrids
To move beyond short multiword phrases, composition is necessary. A simple but sur-
prisingly powerful approach is to represent a sentence with the average of its word em-
beddings (Mitchell and Lapata, ). This can be considered a hybrid of the distribu-
tional and compositional approaches to semantics: the word embeddings are computed
distributionally, and then the sentence representation is computed by composition.
The WORDVEC approach can be stretched considerably further, embedding entire
sentences using a model similar to skipgrams, in the “skip-thought” model of Kiros et al.
(). Each sentence is encoded into a vector using a recurrent neural network: the encod-
ing of sentence t is set to the RNN hidden state at its ﬁnal token, h(t)
Mt. This vector is then
a parameter in a decoder model that is used to generate the previous and subsequent sen-
tences: the decoder is another recurrent neural network, which takes the encoding of the
neighboring sentence as an additional parameter in its recurrent update. (This encoder-
decoder model is discussed at length in chapter .) The encoder and decoder are trained
simultaneously from a likelihood-based objective, and the trained encoder can be used to
compute a distributed representation of any sentence. Skip-thought can also be viewed
as a hybrid of distributional and compositional approaches: the vector representation of
each sentence is computed compositionally from the representations of the individual
words, but the training objective is distributional, based on sentence co-occurrence across
a corpus.
Autoencoders are a variant of encoder-decoder models in which the decoder is trained
to produce the same text that was originally encoded, using only the distributed encod-
ing vector (Li et al., ). The encoding acts as a bottleneck, so that generalization is
necessary if the model is to successfully ﬁt the training data. In denoising autoencoders,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
the input is a corrupted version of the original sentence, and the auto-encoder must re-
construct the uncorrupted original (Vincent et al., ; Hill et al., ). By interpolating
between distributed representations of two sentences, αui+(−α)uj, it is possible to gen-
erate sentences that combine aspects of the two inputs, as shown in Figure . (Bowman
et al., ).
Autoencoders can also be applied to longer texts, such as paragraphs and documents.
This enables applications such as question answering, which can be performed by match-
ing the encoding of the question with encodings of candidate answers (Miao et al., ).
Supervised compositional methods
Given a supervision signal, such as a label describing the sentiment or meaning of a sen-
tence, a wide range of compositional methods can be applied to compute a distributed
representation that then predicts the label. The simplest is to average the embeddings
of each word in the sentence, and pass this average through a feedforward neural net-
work (Iyyer et al., ). Convolutional and recurrent neural networks go further, with
the ability to effectively capturing multiword phenomena such as negation (Kalchbrenner
et al., ; Kim, ; Li et al., ; Tang et al., ). Another approach is to incorpo-
rate the syntactic structure of the sentence into a recursive neural network, in which the
representation for each syntactic constituent is computed from the representations of its
children (Socher et al., ). However, in many cases, recurrent neural networks perform
as well or better than recursive networks (Li et al., ).
Whether convolutional, recurrent, or recursive, a key question is whether supervised
sentence representations are task-speciﬁc, or whether a single supervised sentence repre-
sentation model can yield useful performance on other tasks. Wieting et al. (b) train a
variety of sentence embedding models for the task of labeling pairs of sentences as para-
phrases. They show that the resulting sentence embeddings give good performance for
sentiment analysis. The Stanford Natural Language Inference corpus classiﬁes sentence
pairs as entailments (the truth of sentence i implies the truth of sentence j), contradictions
(the truth of sentence i implies the falsity of sentence j), and neutral (i neither entails nor
contradicts j). Sentence embeddings trained on this dataset transfer to a wide range of
classiﬁcation tasks (Conneau et al., ).
Hybrid distributed-symbolic representations
The power of distributed representations is in their generality: the distributed represen-
tation of a unit of text can serve as a summary of its meaning, and therefore as the input
for downstream tasks such as classiﬁcation, matching, and retrieval. For example, dis-
tributed sentence representations can be used to recognize the paraphrase relationship
between closely related sentences like the following:
Jacob Eisenstein. Draft of November , .

.. DISTRIBUTED REPRESENTATIONS OF MULTIWORD UNITS
a. Donald thanked Vlad profusely.
b. Donald conveyed to Vlad his profound appreciation.
c. Vlad was showered with gratitude by Donald.
Symbolic representations are relatively brittle to this sort of variation, but are better
suited to describe individual entities, the things that they do, and the things that are done
to them. In examples (.a)-(.c), we not only know that somebody thanked someone
else, but we can make a range of inferences about what has happened between the entities
named Donald and Vlad. Because distributed representations do not treat entities symbol-
ically, they lack the ability to reason about the roles played by entities across a sentence or
larger discourse. A hybrid between distributed and symbolic representations might give
the best of both worlds: robustness to the many different ways of describing the same
event, plus the expressiveness to support inferences about entities and the roles that they
play.
A “top-down” hybrid approach is to begin with logical semantics (of the sort de-
scribed in the previous two chapters), and but replace the predeﬁned lexicon with a set
of distributional word clusters (Poon and Domingos, ; Lewis and Steedman, ). A
“bottom-up” approach is to add minimal symbolic structure to existing distributed repre-
sentations, such as vector representations for each entity (Ji and Eisenstein, ; Wiseman
et al., ). This has been shown to improve performance on two problems that we will
encounter in the following chapters: classiﬁcation of discourse relations between adja-
cent sentences (chapter ; Ji and Eisenstein, ), and coreference resolution of entity
mentions (chapter ; Wiseman et al., ; Ji et al., ). Research on hybrid seman-
tic representations is still in an early stage, and future representations may deviate more
boldly from existing symbolic and distributional approaches.
Additional resources
Turney and Pantel () survey a number of facets of vector word representations, fo-
cusing on matrix factorization methods. Schnabel et al. () highlight problems with
similarity-based evaluations of word embeddings, and present a novel evaluation that
controls for word frequency. Baroni et al. () address linguistic issues that arise in
attempts to combine distributed and compositional representations.
In bilingual and multilingual distributed representations, embeddings are estimated
for translation pairs or tuples, such as (dog, perro, chien). These embeddings can improve
machine translation (Zou et al., ; Klementiev et al., ), transfer natural language
At a  workshop on semantic parsing, this critique of distributed representations was expressed by
Ray Mooney — a leading researcher in computational semantics — in a now well-known quote, “you can’t
cram the meaning of a whole sentence into a single vector!”
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
processing models across languages (T¨ackstr¨om et al., ), and make monolingual word
embeddings more accurate (Faruqui and Dyer, ). A typical approach is to learn a pro-
jection that maximizes the correlation of the distributed representations of each element
in a translation pair, which can be obtained from a bilingual dictionary. Distributed rep-
resentations can also be linked to perceptual information, such as image features. Bruni
et al. () use textual descriptions of images to obtain visual contextual information for
various words, which supplements traditional distributional context. Image features can
also be inserted as contextual information in log bilinear language models (Kiros et al.,
), making it possible to automatically generate text descriptions of images.
Exercises
. Prove that the sum of probabilities of paths through a hierarchical softmax tree is
equal to one.
. In skipgram word embeddings, the negative sampling objective can be written as,
i∈V
j∈C
count(i, j)ψ(i, j),
L =
with ψ(i, j) is deﬁned in Equation ..
Suppose we draw the negative samples from the empirical unigram distribution
ˆp(i) = punigram(i). First, compute the expectation of L with respect the negative
samples, using this probability.
Next, take the derivative of this expectation with respect to the score of a single word
context pair σ(uivj), and solve for the pointwise mutual information PMI(i, j). You
should be able to show that at the optimum, the PMI is a simple function of σ(uivj)
and the number of negative samples.
(This exercise is part of a proof that shows that skipgram with negative sampling is
closely related to PMI-weighted matrix factorization.)
. * In Brown clustering, prove that the cluster merge that maximizes the average mu-
tual information (Equation .) also maximizes the log-likelihood objective (Equa-
tion .).
. A simple way to compute a distributed phrase representation is to add up the dis-
tributed representations of the words in the phrase. Consider a sentiment analysis
model in which the predicted sentiment is, ψ(w) = θ  (PM
m= xm), where xm is
the vector representation of word m. Prove that in such a model, the following two
Jacob Eisenstein. Draft of November , .

.. DISTRIBUTED REPRESENTATIONS OF MULTIWORD UNITS
inequalities cannot both hold:
ψ(good) >ψ(not good)
ψ(bad) <ψ(not bad).
Then construct a similar example pair for the case in which phrase representations
are the average of the word representations.
. Now let’s consider a slight modiﬁcation to the prediction model in the previous
problem:
ψ(w) = θ  ReLU(
m=
xm)
Show that in this case, it is possible to achieve the inequalities above. Your solution
should provide the weights θ and the embeddings xgood, xbad, and xnot.
For the next two problems, download a set of pre-trained word embeddings, such as the
WORDVEC or polyglot embeddings.
. Use cosine similarity to ﬁnd the most similar words to: dog, whale, before, however,
fabricate.
. Use vector addition and subtraction to compute target vectors for the analogies be-
low. After computing each target vector, ﬁnd the top three candidates by cosine
similarity.
dog:puppy :: cat: ?
speak:speaker :: sing:?
France:French :: England:?
France:wine :: England:?
The remaining problems will require you to build a classiﬁer and test its properties. Pick a
text classiﬁcation dataset, such as the Cornell Movie Review data. Divide your data into
training (%), development (%), and test sets (%), if no such division already exists.
. Train a convolutional neural network, with inputs set to pre-trained word embed-
dings from the previous two problems. Use an additional, ﬁne-tuned embedding
for out-of-vocabulary words. Train until performance on the development set does
not improve. You can also use the development set to tune the model architecture,
such as the convolution width and depth. Report F -MEASURE and accuracy, as well
as training time.
http://www.cs.cornell.edu/people/pabo/movie-review-data/
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISTRIBUTIONAL AND DISTRIBUTED SEMANTICS
. Now modify your model from the previous problem to ﬁne-tune the word embed-
dings. Report F -MEASURE, accuracy, and training time.
. Try a simpler approach, in which word embeddings in the document are averaged,
and then this average is passed through a feed-forward neural network. Again, use
the development data to tune the model architecture. How close is the accuracy to
the convolutional networks from the previous problems?
Jacob Eisenstein. Draft of November , .

Chapter
Reference Resolution
References are one of the most noticeable forms of linguistic ambiguity, afﬂicting not just
automated natural language processing systems, but also ﬂuent human readers. Warn-
ings to avoid “ambiguous pronouns” are ubiquitous in manuals and tutorials on writing
style. But referential ambiguity is not limited to pronouns, as shown in the text in Fig-
ure .. Each of the bracketed substrings refers to an entity that is introduced earlier
in the passage. These references include the pronouns he and his, but also the shortened
name Cook, and nominals such as the ﬁrm and the ﬁrm’s biggest growth market.
Reference resolution subsumes several subtasks. This chapter will focus on corefer-
ence resolution, which is the task of grouping spans of text that refer to a single underly-
ing entity, or, in some cases, a single event: for example, the spans Tim Cook, he, and Cook
are all coreferent. These individual spans are called mentions, because they mention an
entity; the entity is sometimes called the referent. Each mention has a set of antecedents,
which are preceding mentions that are coreferent; for the ﬁrst mention of an entity, the an-
tecedent set is empty. The task of pronominal anaphora resolution requires identifying
only the antecedents of pronouns. In entity linking, references are resolved not to other
spans of text, but to entities in a knowledge base. This task is discussed in chapter .
Coreference resolution is a challenging problem for several reasons. Resolving differ-
ent types of referring expressions requires different types of reasoning: the features and
methods that are useful for resolving pronouns are different from those that are useful
to resolve names and nominals. Coreference resolution involves not only linguistic rea-
soning, but also world knowledge and pragmatics: you may not have known that China
was Apple’s biggest growth market, but it is likely that you effortlessly resolved this ref-
erence while reading the passage in Figure .. A further challenge is that coreference
This interpretation is based in part on the assumption that a cooperative author would not use the
expression the ﬁrm’s biggest growth market to refer to an entity not yet mentioned in the article (Grice, ).
Pragmatics is the discipline of linguistics concerned with the formalization of such assumptions (Huang,
CHAPTER . REFERENCE RESOLUTION
[[Apple Inc] Chief Executive Tim Cook] has jetted into [China] for talks with
government ofﬁcials as [he] seeks to clear up a pile of problems in [[the ﬁrm]
’s biggest growth market] ... [Cook] is on [his] ﬁrst trip to [the country] since
taking over...
Figure .: Running example (Yee and Jones, ). Coreferring entity mentions are in
brackets.
resolution decisions are often entangled: each mention adds information about the entity,
which affects other coreference decisions. This means that coreference resolution must
be addressed as a structure prediction problem. But as we will see, there is no dynamic
program that allows the space of coreference decisions to be searched efﬁciently.
Forms of referring expressions
There are three main forms of referring expressions — pronouns, names, and nominals.
Pronouns
Pronouns are a closed class of words that are used for references. A natural way to think
about pronoun resolution is SMASH (Kehler, ):
Search for candidate antecedents;
Match against hard agreement constraints;
And Select using Heuristics, which are “soft” constraints such as recency, syntactic
prominence, and parallelism.
Search
In the search step, candidate antecedents are identiﬁed from the preceding text or speech.
Any noun phrase can be a candidate antecedent, and pronoun resolution usually requires
Pronouns whose referents come later are known as cataphora, as in the opening line from a novel by
M´arquez ():
Many years later, as [he] faced the ﬁring squad, [Colonel Aureliano Buend´ıa] was to remember that
distant afternoon when [his] father took him to discover ice.
Jacob Eisenstein. Draft of November , .

.. FORMS OF REFERRING EXPRESSIONS
parsing the text to identify all such noun phrases. Filtering heuristics can help to prune
the search space to noun phrases that are likely to be coreferent (Lee et al., ; Durrett
and Klein, ). In nested noun phrases, mentions are generally considered to be the
largest unit with a given head word (see § ..): thus, Apple Inc. Chief Executive Tim Cook
would be included as a mention, but Tim Cook would not, since they share the same head
word, Cook.
Matching constraints for pronouns
References and their antecedents must agree on semantic features such as number, person,
gender, and animacy. Consider the pronoun he in this passage from the running example:
Tim Cook has jetted in for talks with ofﬁcials as [he] seeks to clear up a pile of
problems...
The pronoun and possible antecedents have the following features:
he: singular, masculine, animate, third person
ofﬁcials: plural, animate, third person
talks: plural, inanimate, third person
Tim Cook: singular, masculine, animate, third person
The SMASH method searches backwards from he, discarding ofﬁcials and talks because they
do not satisfy the agreements constraints.
Another source of constraints comes from syntax — speciﬁcally, from the phrase struc-
ture trees discussed in chapter . Consider a parse tree in which both x and y are phrasal
constituents. The constituent x c-commands the constituent y iff the ﬁrst branching node
above x also dominates y. For example, in Figure .a, Abigail c-commands her, because
the ﬁrst branching node above Abigail, S, also dominates her. Now, if x c-commands y,
government and binding theory (Chomsky, ) states that y can refer to x only if it is
a reﬂexive pronoun (e.g., herself). Furthermore, if y is a reﬂexive pronoun, then its an-
tecedent must c-command it. Thus, in Figure .a, her cannot refer to Abigail; conversely,
if we replace her with herself, then the reﬂexive pronoun must refer to Abigail, since this is
the only candidate antecedent that c-commands it.
Now consider the example shown in Figure .b. Here, Abigail does not c-command
her, but Abigail’s mom does. Thus, her can refer to Abigail — and we cannot use reﬂexive
In the OntoNotes coreference annotations, verbs can also be antecedents, if they are later referenced by
nominals (Pradhan et al., ):
Sales of passenger cars [grew] %. [The strong growth] followed year-to-year increases.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
VP
NP
Abigail
VP
NP
VP
NP
hopes
VP
NP
Abigail
speaks
PP
speaks
PP
mom
’s
Abigail
she
her
with
speaks
her
with
her
with
(a)
(b)
(c)
Figure .: In (a), Abigail c-commands her; in (b), Abigail does not c-command her, but
Abigail’s mom does; in (c), the scope of Abigail is limited by the S non-terminal, so that she
or her can bind to Abigail, but not both.
herself in this context, unless we are talking about Abigail’s mom. However, her does not
have to refer to Abigail. Finally, Figure .c shows the how these constraints are limited.
In this case, the pronoun she can refer to Abigail, because the S non-terminal puts Abigail
outside the domain of she. Similarly, her can also refer to Abigail. But she and her cannot be
coreferent, because she c-commands her.
Heuristics
After applying constraints, heuristics are applied to select among the remaining candi-
dates. Recency is a particularly strong heuristic. All things equal, readers will prefer
the more recent referent for a given pronoun, particularly when comparing referents that
occur in different sentences. Jurafsky and Martin () offer the following example:
The doctor found an old map in the captain’s chest. Jim found an even older map
hidden on the shelf. [It] described an island.
Readers are expected to prefer the older map as the referent for the pronoun it.
However, subjects are often preferred over objects, and this can contradict the prefer-
ence for recency when two candidate referents are in the same sentence. For example,
Abigail loaned Lucia a book on Spanish. [She] is always trying to help people.
Here, we may prefer to link she to Abigail rather than Lucia, because of Abigail’s position in
the subject role of the preceding sentence. (Arguably, this preference would not be strong
enough to select Abigail if the second sentence were She is visiting Valencia next month.)
A third heuristic is parallelism:
Abigail loaned Lucia a book on Spanish.
¨Ozlem loaned [her] a book on Por-
tuguese.
Jacob Eisenstein. Draft of November , .

.. FORMS OF REFERRING EXPRESSIONS
VP
NP
PP
PP
NN
NP
DET
VBD
NP
IN
NP
NP
The
DET
remained
IN
castle
CD
SBAR
until
PP
NNP
the
NN
in
WHP
Camelot
IN
NP
residence
VP
when
NP
of
NN
DET
PP
PRP
VBD
king
the
NP
NP
PRP
TO
moved
he
NNP
to
it
London
Figure .: Left-to-right breadth-ﬁrst tree traversal (Hobbs, ), indicating that the
search for an antecedent for it (NP) would proceed in the following order: ; the castle
in Camelot; the residence of the king; Camelot; the king. Hobbs () proposes semantic con-
straints to eliminate  and the castle in Camelot as candidates, since they are unlikely to
be the direct object of the verb move.
Here Lucia is preferred as the referent for her, contradicting the preference for the subject
Abigail in the preceding example.
The recency and subject role heuristics can be uniﬁed by traversing the document in
a syntax-driven fashion (Hobbs, ): each preceding sentence is traversed breadth-ﬁrst,
left-to-right (Figure .). This heuristic successfully handles (.): Abigail is preferred as
the referent for she because the subject NP is visited ﬁrst. It also handles (.): the older
map is preferred as the referent for it because the more recent sentence is visited ﬁrst. (An
alternative uniﬁcation of recency and syntax is proposed by centering theory (Grosz et al.,
), which is discussed in detail in chapter .)
In early work on reference resolution, the number of heuristics was small enough that
a set of numerical weights could be set by hand (Lappin and Leass, ). More recent
work uses machine learning to quantify the importance of each of these factors. However,
pronoun resolution cannot be completely solved by constraints and heuristics alone. This
is shown by the classic example pair (Winograd, ):
The [city council] denied [the protesters] a permit because [they] advocated/feared
violence.
Without reasoning about the motivations of the city council and protesters, it is unlikely
that any system could correctly resolve both versions of this example.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
Non-referential pronouns
While pronouns are generally used for reference, they need not refer to entities. The fol-
lowing examples show how pronouns can refer to propositions, events, and speech acts.
a. They told me that I was too ugly for show business, but I didn’t believe [it].
b. Elifsu saw Berthold get angry, and I saw [it] too.
c. Emmanuel said he worked in security. I suppose [that]’s one way to put it.
These forms of reference are generally not annotated in large-scale coreference resolution
datasets such as OntoNotes (Pradhan et al., ).
Pronouns may also have generic referents:
a. A poor carpenter blames [her] tools.
b. On the moon, [you] have to carry [your] own oxygen.
c. Every farmer who owns a donkey beats [it]. (Geach, )
In the OntoNotes dataset, coreference is not annotated for generic referents, even in cases
like these examples, in which the same generic entity is mentioned multiple times.
Some pronouns do not refer to anything at all:
a. [It]’s
[Il]
raining.
pleut.
(Fr)
b. [It] ’s money that she’s really after.
c. [It] is too bad that we have to work so hard.
How can we automatically distinguish these usages of it from referential pronouns?
Consider the the difference between the following two examples (Bergsma et al., ):
a. You can make [it] in advance.
b. You can make [it] in showbiz.
In the second example, the pronoun it is non-referential. One way to see this is by substi-
tuting another pronoun, like them, into these examples:
a. You can make [them] in advance.
b. ? You can make [them] in showbiz.
The questionable grammaticality of the second example suggests that it is not referential.
Bergsma et al. () operationalize this idea by comparing distributional statistics for the
n-grams around the word it, testing how often other pronouns or nouns appear in the
same context. In cases where nouns and other pronouns are infrequent, the it is unlikely
to be referential.
Jacob Eisenstein. Draft of November , .

.. FORMS OF REFERRING EXPRESSIONS
Proper Nouns
If a proper noun is used as a referring expression, it often corefers with another proper
noun, so that the coreference problem is simply to determine whether the two names
match. Subsequent proper noun references often use a shortened form, as in the running
example (Figure .):
Apple Inc Chief Executive [Tim Cook] has jetted into China ...[Cook] is on his
ﬁrst business trip to the country ...
A typical solution for proper noun coreference is to match the syntactic head words
of the reference with the referent. In § .., we saw that the head word of a phrase can
be identiﬁed by applying head percolation rules to the phrasal parse tree; alternatively,
the head can be identiﬁed as the root of the dependency subtree covering the name. For
sequences of proper nouns, the head word will be the ﬁnal token.
There are a number of caveats to the practice of matching head words of proper nouns.
In the European tradition, family names tend to be more speciﬁc than given names,
and family names usually come last. However, other traditions have other practices:
for example, in Chinese names, the family name typically comes ﬁrst; in Japanese,
honoriﬁcs come after the name, as in Nobu-San (Mr. Nobu).
In organization names, the head word is often not the most informative, as in Georgia
Tech and Virginia Tech. Similarly, Lebanon does not refer to the same entity as South-
ern Lebanon, necessitating special rules for the speciﬁc case of geographical modi-
ﬁers (Lee et al., ).
Proper nouns can be nested, as in [the CEO of [Microsoft]], resulting in head word
match without coreference.
Despite these difﬁculties, proper nouns are the easiest category of references to re-
solve (Stoyanov et al., ). In machine learning systems, one solution is to include a
range of matching features, including exact match, head match, and string inclusion. In
addition to matching features, competitive systems (e.g., Bengtson and Roth, ) in-
clude large lists, or gazetteers, of acronyms (e.g, the National Basketball Association/NBA),
demonyms (e.g., the Israelis/Israel), and other aliases (e.g., the Georgia Institute of Technol-
ogy/Georgia Tech).
Nominals
In coreference resolution, noun phrases that are neither pronouns nor proper nouns are
referred to as nominals. In the running example (Figure .), nominal references include:
the ﬁrm (Apple Inc); the ﬁrm’s biggest growth market (China); and the country (China).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
Nominals are especially difﬁcult to resolve (Denis and Baldridge, ; Durrett and
Klein, ), and the examples above suggest why this may be the case: world knowledge
is required to identify Apple Inc as a ﬁrm, and China as a growth market. Other difﬁcult
examples include the use of colloquial expressions, such as coreference between Clinton
campaign ofﬁcials and the Clinton camp (Soon et al., ).
Algorithms for coreference resolution
The ground truth training data for coreference resolution is a set of mention sets, where all
mentions within each set refer to a single entity. In the running example from Figure .,
the ground truth coreference annotation is:
c ={Apple Inc:, the ﬁrm:}
c ={Apple Inc Chief Executive Tim Cook:, he, Cook, his}
c ={China, the ﬁrm ’s biggest growth market:, the country:}
Each row speciﬁes the token spans that mention an entity. (“Singleton” entities, which are
mentioned only once (e.g., talks, government ofﬁcials), are excluded from the annotations.)
Equivalently, if given a set of M mentions, {mi}M
i=, each mention i can be assigned to a
cluster zi, where zi = zj if i and j are coreferent. The cluster assignments z are invariant
under permutation. The unique clustering associated with the assignment z is written
c(z).
Coreference resolution can thus be viewed as a structure prediction problem, involv-
ing two subtasks: identifying which spans of text mention entities, and then clustering
those spans.
Mention identiﬁcation
The task of identifying mention spans for coreference resolution
is often performed by applying a set of heuristics to the phrase structure parse of each
sentence. A typical approach is to start with all noun phrases and named entities, and
then apply ﬁltering rules to remove nested noun phrases with the same head (e.g., [Apple
CEO [Tim Cook]]), numeric entities (e.g., [ miles], [%]), non-referential it, etc (Lee
et al., ; Durrett and Klein, ). In general, these deterministic approaches err in
favor of recall, since the mention clustering component can choose to ignore false positive
mentions, but cannot recover from false negatives. An alternative is to consider all spans
(up to some ﬁnite length) as candidate mentions, performing mention identiﬁcation and
clustering jointly (Daum´e III and Marcu, ; Lee et al., ).
In many annotations, the term markable is used to refer to spans of text that can potentially mention an
entity. The set of markables includes non-referential pronouns, which does not mention any entity. Part of the
job of the coreference system is to avoid incorrectly linking these non-referential markables to any mention
chains.
Jacob Eisenstein. Draft of November , .

.. ALGORITHMS FOR COREFERENCE RESOLUTION
Mention clustering
The subtask of mention clustering will be the focus of the remainder
of this chapter. There are two main classes of models. In mention-based models, the scoring
function for a coreference clustering decomposes over pairs of mentions. These pairwise
decisions are then aggregated, using a clustering heuristic. Mention-based coreference
clustering can be treated as a fairly direct application of supervised classiﬁcation or rank-
ing. However, the mention-pair locality assumption can result in incoherent clusters, like
{Hillary Clinton ← Clinton ← Mr Clinton}, in which the pairwise links score well, but the
overall result is unsatisfactory. Entity-based models address this issue by scoring entities
holistically. This can make inference more difﬁcult, since the number of possible entity
groupings is exponential in the number of mentions.
Mention-pair models
In the mention-pair model, a binary label yi,j ∈ {, } is assigned to each pair of mentions
(i, j), where i < j. If i and j corefer (zi = zj), then yi,j = ; otherwise, yi,j = . The
mention he in Figure . is preceded by ﬁve other mentions: () Apple Inc; () Apple Inc
Chief Executive Tim Cook; () China; () talks; () government ofﬁcials. The correct mention
pair labeling is y, =  and yi̸=, =  for all other i. If a mention j introduces a new entity,
such as mention  in the example, then yi,j =  for all i. The same is true for “mentions”
that do not refer to any entity, such as non-referential pronouns. If mention j refers to an
entity that has been mentioned more than once, then yi,j =  for all i < j that mention the
referent.
By transforming coreference into a set of binary labeling problems, the mention-pair
model makes it possible to apply an off-the-shelf binary classiﬁer (Soon et al., ). This
classiﬁer is applied to each mention j independently, searching backwards from j until
ﬁnding an antecedent i which corefers with j with high conﬁdence. After identifying a
single antecedent, the remaining mention pair labels can be computed by transitivity: if
yi,j =  and yj,k = , then yi,k = .
Since the ground truth annotations give entity chains c but not individual mention-
pair labels y, an additional heuristic must be employed to convert the labeled data into
training examples for classiﬁcation. A typical approach is to generate at most one pos-
itive labeled instance yaj,j =  for mention j, where aj is the index of the most recent
antecedent, aj = max{i : i < j ∧ zi = zj}. Negative labeled instances are generated for
all for all i ∈ {aj + , . . . , j}. In the running example, the most recent antecedent of the
pronoun he is a = , so the training data would be y, =  and y, = y, = y, = .
The variable y, is not part of the training data, because the ﬁrst mention appears before
the true antecedent a = .
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
Mention-ranking models
In mention ranking (Denis and Baldridge, ), the classiﬁer learns to identify a single
antecedent ai ∈ {ϵ, , , . . . , i − } for each referring expression i,
ˆai =
argmax
a∈{ϵ,,,...,i−}
ψM(a, i),
where ψM(a, i) is a score for the mention pair (a, i). If a = ϵ, then mention i does not refer
to any previously-introduced entity — it is not anaphoric. Mention-ranking is similar to
the mention-pair model, but all candidates are considered simultaneously, and at most
a single antecedent is selected. The mention-ranking model explicitly accounts for the
possibility that mention i is not anaphoric, through the score ψM(ϵ, i). The determination
of anaphoricity can be made by a special classiﬁer in a preprocessing step, so that non-ϵ
antecedents are identiﬁed only for spans that are determined to be anaphoric (Denis and
Baldridge, ).
As a learning problem, ranking can be trained using the same objectives as in dis-
criminative classiﬁcation. For each mention i, we can deﬁne a gold antecedent a∗
i , and an
associated loss, such as the hinge loss, ℓi = ( − ψM(a∗
i , i) + ψM(ˆa, i))+ or the negative
log-likelihood, ℓi = − log p(a∗
i | i; θ). (For more on learning to rank, see § ...) But as
with the mention-pair model, there is a mismatch between the labeled data, which comes
in the form of mention sets, and the desired supervision, which would indicate the spe-
ciﬁc antecedent of each mention. The antecedent variables {ai}M
i= relate to the mention
sets in a many-to-one mapping: each set of antecedents induces a single clustering, but a
clustering can correspond to many different settings of antecedent variables.
A heuristic solution is to set a∗
i = max{j : j < i ∧ zj = zi}, the most recent mention in
the same cluster as i. But the most recent mention may not be the most informative: in the
running example, the most recent antecedent of the mention Cook is the pronoun he, but
a more useful antecedent is the earlier mention Apple Inc Chief Executive Tim Cook. Rather
than selecting a speciﬁc antecedent to train on, the antecedent can be treated as a latent
variable, in the manner of the latent variable perceptron from § .. (Fernandes et al.,
ˆa = argmax
i=
ψM(ai, i)
i=
ψM(ai, i)
a∗ = argmax
a∈A(c)
∂L
∂θ ψM(ˆai, i)
∂L
∂θ ψM(a∗
i , i) −
θ ←θ +
i=
i=
Jacob Eisenstein. Draft of November , .

.. ALGORITHMS FOR COREFERENCE RESOLUTION
where A(c) is the set of antecedent structures that is compatible with the ground truth
coreference clustering c. Another alternative is to sum over all the conditional probabili-
ties of antecedent structures that are compatible with the ground truth clustering (Durrett
and Klein, ; Lee et al., ). For the set of mention m, we compute the following
probabilities:
i=
p(ai | i, m)
a∈A(c)
a∈A(c)
p(a | m) =
p(c | m) =
p(ai | i, m) =
exp (ψM(ai, i))
a′∈{ϵ,,,...,i−} exp (ψM(a′, i)).
This objective rewards models that assign high scores for all valid antecedent structures.
In the running example, this would correspond to summing the probabilities of the two
valid antecedents for Cook, he and Apple Inc Chief Executive Tim Cook. In one of the exer-
cises, you will compute the number of valid antecedent structures for a given clustering.
Transitive closure in mention-based models
A problem for mention-based models is that individual mention-level decisions may be
incoherent. Consider the following mentions:
m =Hillary Clinton
m =Clinton
m =Bill Clinton
A mention-pair system might predict ˆy, = , ˆy, = , ˆy, = . Similarly, a mention-
ranking system might choose ˆa =  and ˆa = . Logically, if mentions  and  are both
coreferent with mention , then all three mentions must refer to the same entity. This
constraint is known as transitive closure.
Transitive closure can be applied post hoc, revising the independent mention-pair or
mention-ranking decisions. However, there are many possible ways to enforce transitive
closure: in the example above, we could set ˆy, = , or ˆy, = , or ˆy, = . For docu-
ments with many mentions, there may be many violations of transitive closure, and many
possible ﬁxes. Transitive closure can be enforced by always adding edges, so that ˆy, =
is preferred (e.g., Soon et al., ), but this can result in overclustering, with too many
mentions grouped into too few entities.
Mention-pair coreference resolution can be viewed as a constrained optimization prob-
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
lem,
j=
i=
ψM(i, j) × yi,j
max
y∈{,}M
s.t.
yi,j + yj,k −  ≤ yi,k,
∀i < j < k,
with the constraint enforcing transitive closure. This constrained optimization problem
is equivalent to graph partitioning with positive and negative edge weights: construct a
graph where the nodes are mentions, and the edges are the pairwise scores ψM(i, j); the
goal is to partition the graph so as to maximize the sum of the edge weights between all
nodes within the same partition (McCallum and Wellner, ). This problem is NP-hard,
motivating approximations such as correlation clustering (Bansal et al., ) and integer
linear programming (Klenner, ; Finkel and Manning, , also see § ..).
Entity-based models
A weakness of mention-based models is that they treat coreference resolution as a classiﬁ-
cation or ranking problem, when it is really a clustering problem: the goal is to group the
mentions together into clusters that correspond to the underlying entities. Entity-based
approaches attempt to identify these clusters directly. Such methods require a scoring
function at the entity level, measuring whether each set of mentions is internally consis-
tent. Coreference resolution can then be viewed as the following optimization,
max
e=
ψE({i : zi = e}),
where zi indicates the entity referenced by mention i, and ψE({i : zi = e}) is a scoring
function applied to all mentions i that are assigned to entity e.
Entity-based coreference resolution is conceptually similar to the unsupervised clus-
tering problems encountered in chapter : the goal is to obtain clusters of mentions that
are internally coherent. The number of possible clusterings of n items is the Bell number,
which is deﬁned by the following recurrence (Bell, ; Luo et al., ),
Bn =
k=
Bk
n −

B =
B = .
n−
This recurrence is illustrated by the Bell tree, which is applied to a short coreference prob-
lem in Figure .. The Bell number Bn grows exponentially with n, making exhaustive
search of the space of clusterings impossible. For this reason, entity-based coreference
resolution typically involves incremental search, in which clustering decisions are based
on local evidence, in the hope of approximately optimizing the full objective in Equa-
tion .. This approach is sometimes called cluster ranking, in contrast to mention
ranking.
Jacob Eisenstein. Draft of November , .

.. ALGORITHMS FOR COREFERENCE RESOLUTION
{Abigail, she, her}
{Abigail, she}
{Abigail, she}, {her}
{Abigail}
{Abigail}, {she, her}
{Abigail}, {she}
{Abigail, her}, {she}
{Abigail}, {she}, {her}
Figure .: The Bell Tree for the sentence Abigail hopes she speaks with her. Which paths
are excluded by the syntactic constraints mentioned in § ..?
*Generative models of coreference
Entity-based coreference can be approached through
probabilistic generative models, in which the mentions in the document are conditioned
on a set of latent entities (Haghighi and Klein, , ). An advantage of these meth-
ods is that they can be learned from unlabeled data (Poon and Domingos, , e.g.,); a
disadvantage is that probabilistic inference is required not just for learning, but also for
prediction. Furthermore, generative models require independence assumptions that are
difﬁcult to apply in coreference resolution, where the diverse and heterogeneous features
do not admit an easy decomposition into mutually independent subsets.
Incremental cluster ranking
The SMASH method (§ ..) can be extended to entity-based coreference resolution by
building up coreference clusters while moving through the document (Cardie and Wagstaff,
). At each mention, the algorithm iterates backwards through possible antecedent
clusters; but unlike SMASH, a cluster is selected only if all members of its cluster are com-
patible with the current mention. As mentions are added to a cluster, so are their features
(e.g., gender, number, animacy). In this way, incoherent chains like {Hillary Clinton, Clinton, Bill Clinton}
can be avoided. However, an incorrect assignment early in the document — a search error
— might lead to a cascade of errors later on.
More sophisticated search strategies can help to ameliorate the risk of search errors.
One approach is beam search (ﬁrst discussed in § .), in which a set of hypotheses is
maintained throughout search. Each hypothesis represents a path through the Bell tree
(Figure .). Hypotheses are “expanded” either by adding the next mention to an ex-
isting cluster, or by starting a new cluster. Each expansion receives a score, based on
Equation ., and the top K hypotheses are kept on the beam as the algorithm moves
to the next step.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
Incremental cluster ranking can be made more accurate by performing multiple passes
over the document, applying rules (or “sieves”) with increasing recall and decreasing
precision at each pass (Lee et al., ). In the early passes, coreference links are pro-
posed only between mentions that are highly likely to corefer (e.g., exact string match
for full names and nominals). Information can then be shared among these mentions,
so that when more permissive matching rules are applied later, agreement is preserved
across the entire cluster. For example, in the case of {Hillary Clinton, Clinton, she}, the
name-matching sieve would link Clinton and Hillary Clinton, and the pronoun-matching
sieve would then link she to the combined cluster. A deterministic multi-pass system
won nearly every track of the  CoNLL shared task on coreference resolution (Prad-
han et al., ). Given the dominance of machine learning in virtually all other areas
of natural language processing — and more than ﬁfteen years of prior work on machine
learning for coreference — this was a surprising result, even if learning-based methods
have subsequently regained the upper hand (e.g., Lee et al., , the state of the art at the
time of this writing).
Incremental perceptron
Incremental coreference resolution can be learned with the incremental perceptron, as
described in § ... At mention i, each hypothesis on the beam corresponds to a cluster-
ing of mentions  . . . i−, or equivalently, a path through the Bell tree up to position i−.
As soon as none of the hypotheses on the beam are compatible with the gold coreference
clustering, a perceptron update is made (Daum´e III and Marcu, ). For concreteness,
consider a linear cluster ranking model,
i:zi=e
θ  f(i, {j : j < i ∧ zj = e}),
ψE({i : zi = e}) =
where the score for each cluster is computed as the sum of scores of all mentions that are
linked into the cluster, and f(i, ∅) is a set of features for the non-anaphoric mention that
initiates the cluster.
Using Figure . as an example, suppose that the ground truth is,
c∗ = {Abigail, her}, {she},
but that with a beam of size one, the learner reaches the hypothesis,
ˆc = {Abigail, she}.
This hypothesis is incompatible with c∗, so an update is needed:
θ ←θ + f(c∗) − f(ˆc)
=θ + (f(Abigail, ∅) + f(she, ∅)) − (f(Abigail, ∅) + f(she, {Abigail}))
=θ + f(she, ∅) − f(she, {Abigail}).
Jacob Eisenstein. Draft of November , .

.. ALGORITHMS FOR COREFERENCE RESOLUTION
This style of incremental update can also be applied to a margin loss between the gold
clustering and the top clustering on the beam. By backpropagating from this loss, it is also
possible to train a more complicated scoring function, such as a neural network in which
the score for each entity is a function of embeddings for the entity mentions (Wiseman
et al., ).
Reinforcement learning
Reinforcement learning is a topic worthy of a textbook of its own (Sutton and Barto,
), so this section will provide only a very brief overview, in the context of coreference
resolution. A stochastic policy assigns a probability to each possible action, conditional
on the context. The goal is to learn a policy that achieves a high expected reward, or
equivalently, a low expected cost.
In incremental cluster ranking, a complete clustering on M mentions can be produced
by a sequence of M actions, in which the action zi either merges mention i with an existing
cluster or begins a new cluster. We can therefore create a stochastic policy using the cluster
scores (Clark and Manning, ),
Pr(zi = e; θ) =
exp ψE(i ∪ {j : zj = e}; θ)
e′ exp ψE(i ∪ {j : zj = e′}′; θ),
where ψE(i ∪ {j : zj = e}; θ) is the score under parameters θ for assigning mention i to
cluster e. This score can be an arbitrary function of the mention i, the cluster e and its
(possibly empty) set of mentions; it can also include the history of actions taken thus far.
If a policy assigns probability p(c; θ) to clustering c, then its expected loss is,
c∈C(m)
pθ(c) × ℓ(c),
L(θ) =
where C(m) is the set of possible clusterings for mentions m. The loss ℓ(c) can be based on
any arbitrary scoring function, including the complex evaluation metrics used in corefer-
ence resolution (see § .). This is an advantage of reinforcement learning, which can be
trained directly on the evaluation metric — unlike traditional supervised learning, which
requires a loss function that is differentiable and decomposable across individual deci-
sions.
Rather than summing over the exponentially many possible clusterings, we can ap-
proximate the expectation by sampling trajectories of actions, z = (z, z, . . . , zM), from
A draft of the second edition can be found here:
http://incompleteideas.net/book/
the-book-nd.html. Reinforcement learning has been used in spoken dialogue systems (Walker, )
and text-based game playing (Branavan et al., ), and was applied to coreference resolution by Clark and
Manning ().
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
the current policy. Each action zi corresponds to a step in the Bell tree: adding mention
mi to an existing cluster, or forming a new cluster. Each trajectory z corresponds to a
single clustering c, and so we can write the loss of an action sequence as ℓ(c(z)). The
policy gradient algorithm computes the gradient of the expected loss as an expectation
over trajectories (Sutton et al., ),
∂θL(θ) =Ez∼Z(m)ℓ(c(z))
∂θ log p(zi | z:i−, m)
i=
∂θ log p(z(k)
| z(k)
:i−, m),
i=
k=
ℓ(c(z(k)))
where each action sequence z(k) is sampled from the current policy. Unlike the incremen-
tal perceptron, an update is not made until the complete action sequence is available.
Learning to search
Policy gradient can suffer from high variance: while the average loss over K samples is
asymptotically equal to the expected reward of a given policy, this estimate may not be
accurate unless K is very large. This can make it difﬁcult to allocate credit and blame to
individual actions. In learning to search, this problem is addressed through the addition
of an oracle policy, which is known to receive zero or small loss. The oracle policy can be
used in two ways:
The oracle can be used to generate partial hypotheses that are likely to score well,
by generating i actions from the initial state. These partial hypotheses are then used
as starting points for the learned policy. This is known as roll-in.
The oracle can be used to compute the minimum possible loss from a given state, by
generating M − i actions from the current state until completion. This is known as
roll-out.
The oracle can be combined with the existing policy during both roll-in and roll-out, sam-
pling actions from each policy (Daum´e III et al., ). One approach is to gradually
decrease the number of actions drawn from the oracle over the course of learning (Ross
et al., ).
In the context of entity-based coreference resolution, Clark and Manning () use
the learned policy for roll-in and the oracle policy for roll-out. Algorithm  shows how
the gradients on the policy weights are computed in this case. In this application, the
oracle is “noisy”, because it selects the action that minimizes only the local loss — the
accuracy of the coreference clustering up to mention i — rather than identifying the action
sequence that will lead to the best ﬁnal coreference clustering on the entire document.
Jacob Eisenstein. Draft of November , .

.. REPRESENTATIONS FOR COREFERENCE RESOLUTION
Algorithm  Learning to search for entity-based coreference resolution
: procedure COMPUTE-GRADIENT(mentions m, loss function ℓ, parameters θ)
L(θ) ←
z ∼ p(z | m; θ)
▷ Sample a trajectory from the current policy
for i ∈ {, , . . . M} do
for action z ∈ Z(z:i−, m) do
▷ All possible actions after history z:i−
h ← z:i− ⊕ z
▷ Concatenate history z:i− with action z
for j ∈ {i + , i + , . . . , M} do
▷ Roll-out
hj ← argminh ℓ(h:j− ⊕ h)
▷ Oracle selects action with minimum loss
L(θ) ← L(θ) + p(z | z:i−, m; θ) × ℓ(h)
▷ Update expected loss
return
∂θL(θ)
When learning from noisy oracles, it can be helpful to mix in actions from the current
policy with the oracle during roll-out (Chang et al., ).
Representations for coreference resolution
Historically, coreference resolution has employed an array of hand-engineered features
to capture the linguistic constraints and preferences described in § . (Soon et al., ).
Later work has documented the utility of lexical and bilexical features on mention pairs (Bj¨orkelund
and Nugues, ; Durrett and Klein, ). The most recent and successful methods re-
place many (but not all) of these features with distributed representations of mentions
and entities (Wiseman et al., ; Clark and Manning, ; Lee et al., ).
Features
Coreference features generally rely on a preprocessing pipeline to provide part-of-speech
tags and phrase structure parses. This pipeline makes it possible to design features that
capture many of the phenomena from § ., and is also necessary for typical approaches
to mention identiﬁcation. However, the pipeline may introduce errors that propagate
to the downstream coreference clustering system. Furthermore, the existence of such
a pipeline presupposes resources such as treebanks, which do not exist for many lan-
guages.
The Universal Dependencies project has produced dependency treebanks for more than sixty languages.
However, coreference features and mention detection are generally based on phrase structure trees, which
exist for roughly two dozen languages. A list is available here: https://en.wikipedia.org/wiki/
Treebank
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
Mention features
Features of individual mentions can help to predict anaphoricity. In systems where men-
tion detection is performed jointly with coreference resolution, these features can also
predict whether a span of text is likely to be a mention. For mention i, typical features
include:
Mention type. Each span can be identiﬁed as a pronoun, name, or nominal, using the
part-of-speech of the head word of the mention: both the Penn Treebank and Uni-
versal Dependencies tagsets (§ ..) include tags for pronouns and proper nouns,
and all other heads can be marked as nominals (Haghighi and Klein, ).
Mention width. The number of tokens in a mention is a rough predictor of its anaphoric-
ity, with longer mentions being less likely to refer back to previously-deﬁned enti-
ties.
Lexical features. The ﬁrst, last, and head words can help to predict anaphoricity; they are
also useful in conjunction with features such as mention type and part-of-speech,
providing a rough measure of agreement (Bj¨orkelund and Nugues, ). The num-
ber of lexical features can be very large, so it can be helpful to select only frequently-
occurring features (Durrett and Klein, ).
Morphosyntactic features. These features include the part-of-speech, number, gender,
and dependency ancestors.
The features for mention i and candidate antecedent a can be conjoined, producing
joint features that can help to assess the compatibility of the two mentions. For example,
Durrett and Klein () conjoin each feature with the mention types of the anaphora
and the antecedent. Coreference resolution corpora such as ACE and OntoNotes contain
documents from various genres. By conjoining the genre with other features, it is possible
to learn genre-speciﬁc feature weights.
Mention-pair features
For any pair of mentions i and j, typical features include:
Distance. The number of intervening tokens, mentions, and sentences between i and j
can all be used as distance features. These distances can be computed on the surface
text, or on a transformed representation reﬂecting the breadth-ﬁrst tree traversal
(Figure .). Rather than using the distances directly, they are typically binned,
creating binary features.
Jacob Eisenstein. Draft of November , .

.. REPRESENTATIONS FOR COREFERENCE RESOLUTION
String match. A variety of string match features can be employed: exact match, sufﬁx
match, head match, and more complex matching rules that disregard irrelevant
modiﬁers (Soon et al., ).
Compatibility. Building on the model, features can measure the anaphor and antecedent
agree with respect to morphosyntactic attributes such as gender, number, and ani-
macy.
Nesting. If one mention is nested inside another (e.g., [The President of [France]]), they
generally cannot corefer.
Same speaker. For documents with quotations, such as news articles, personal pronouns
can be resolved only by determining the speaker for each mention (Lee et al., ).
Coreference is also more likely between mentions from the same speaker.
Gazetteers. These features indicate that the anaphor and candidate antecedent appear in
a gazetteer of acronyms (e.g., USA/United States, GATech/Georgia Tech), demonyms
(e.g., Israel/Israeli), or other aliases (e.g., Knickerbockers/New York Knicks).
Lexical semantics. These features use a lexical resource such as WORDNET to determine
whether the head words of the mentions are related through synonymy, antonymy,
and hypernymy (§ .).
Dependency paths. The dependency path between the anaphor and candidate antecedent
can help to determine whether the pair can corefer, under the government and bind-
ing constraints described in § ...
Comprehensive lists of mention-pair features are offered by Bengtson and Roth () and
Rahman and Ng (). Neural network approaches use far fewer mention-pair features:
for example, Lee et al. () include only speaker, genre, distance, and mention width
features.
Semantics
In many cases, coreference seems to require knowledge and semantic infer-
ences, as in the running example, where we link China with a country and a growth mar-
ket. Some of this information can be gleaned from WORDNET, which deﬁnes a graph
over synsets (see § .). For example, one of the synsets of China is an instance of an
Asian nation#, which in turn is a hyponym of country#, a synset that includes
country. Such paths can be used to measure the similarity between concepts (Pedersen
et al., ), and this similarity can be incorporated into coreference resolution as a fea-
ture (Ponzetto and Strube, ). Similar ideas can be applied to knowledge graphs in-
duced from Wikipedia (Ponzetto and Strube, ). But while such approaches improve
teletype font is used to indicate wordnet synsets, and italics is used to indicate strings.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
relatively simple classiﬁcation-based systems, they have proven less useful when added
to the current generation of techniques. For example, Durrett and Klein () employ
a range of semantics-based features — WordNet synonymy and hypernymy relations on
head words, named entity types (e.g., person, organization), and unsupervised cluster-
ing over nominal heads — but ﬁnd that these features give minimal improvement over a
baseline system using surface features.
Entity features
Many of the features for entity-mention coreference are generated by aggregating mention-
pair features over all mentions in the candidate entity (Culotta et al., ; Rahman and
Ng, ). Speciﬁcally, for each binary mention-pair feature f(i, j), we compute the fol-
lowing entity-mention features for mention i and entity e = {j : j < i ∧ zj = e}.
ALL-TRUE: Feature f(i, j) holds for all mentions j ∈ e.
MOST-TRUE: Feature f(i, j) holds for at least half and fewer than all mentions j ∈ e.
MOST-FALSE: Feature f(i, j) holds for at least one and fewer than half of all men-
tions j ∈ e.
NONE: Feature f(i, j) does not hold for any mention j ∈ e.
For scalar mention-pair features (e.g., distance features), aggregation can be performed by
computing the minimum, maximum, and median values across all mentions in the cluster.
Additional entity-mention features include the number of mentions currently clustered in
the entity, and ALL-X and MOST-X features for each mention type.
Distributed representations of mentions and entities
Recent work has emphasized distributed representations of both mentions and entities.
One potential advantage is that pre-trained embeddings could help to capture the se-
mantic compatibility underlying nominal coreference, helping with difﬁcult cases like
(Apple, the ﬁrm) and (China, the ﬁrm’s biggest growth market).
Furthermore, a distributed
representation of entities can be trained to capture semantic features that are added by
each mention.
Mention embeddings
Entity mentions can be embedded into a vector space, providing the base layer for neural
networks that score coreference decisions (Wiseman et al., ).
This point was made by Michael Strube at a  workshop, noting that as the quality of the machine
learning models in coreference has improved, the beneﬁt of including semantics has become negligible.
Jacob Eisenstein. Draft of November , .

.. REPRESENTATIONS FOR COREFERENCE RESOLUTION
uﬁrst
uhead
ulast

in
the
ﬁrm
’s
biggest
growth
market
Figure .: A bidirectional recurrent model of mention embeddings. The mention is
represented by its ﬁrst word, its last word, and an estimate of its head word, which is
computed from a weighted average (Lee et al., ).
Constructing the mention embedding
Various approaches for embedding multiword
units can be applied (see § .). Figure . shows a recurrent neural network approach,
which begins by running a bidirectional LSTM over the entire text, obtaining hidden states
from the left-to-right and right-to-left passes, hm = [←−
h m; −→
h m]. Each candidate mention
span (s, t) is then represented by the vertical concatenation of four vectors:
u(s,t) = [u(s,t)
ﬁrst ; u(s,t)
last ; u(s,t)
head; φ(s,t)],
where u(s,t)
ﬁrst = hs+ is the embedding of the ﬁrst word in the span, u(s,t)
last
= ht is the
embedding of the last word, u(s,t)
head is the embedding of the “head” word, and φ(s,t) is a
vector of surface features, such as the length of the span (Lee et al., ).
Attention over head words
Rather than identifying the head word from the output of a
parser, it can be computed from a neural attention mechanism:
˜αm =θα  hm
a(s,t) = SoftMax ([˜αs+, ˜αs+, . . . , ˜αt])
u(s,t)
head =
m=s+
a(s,t)
hm.
Each token m gets a scalar score ˜αm = θα  hm, which is the dot product of the LSTM
hidden state hm and a vector of weights θα. The vector of scores for tokens in the span
m ∈ {s + , s + , . . . , t} is then passed through a softmax layer, yielding a vector a(s,t)
that allocates one unit of attention across the span. This eliminates the need for syntactic
parsing to recover the head word; instead, the model learns to identify the most important
words in each span. Attention mechanisms were introduced in neural machine transla-
tion (Bahdanau et al., ), and are described in more detail in § ...
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
Using mention embeddings
Given a set of mention embeddings, each mention i and
candidate antecedent a is scored as,
ψ(a, i) =ψS(a) + ψS(i) + ψM(a, i)
ψS(a) =FeedForwardS(u(a))
ψS(i) =FeedForwardS(u(i))
ψM(a, i) =FeedForwardM([u(a); u(i); u(a) ⊙ u(i); f(a, i, w)]),
where u(a) and u(i) are the embeddings for spans a and i respectively, as deﬁned in Equa-
tion ..
The scores ψS(a) quantify whether span a is likely to be a coreferring mention, inde-
pendent of what it corefers with. This allows the model to learn identify mentions
directly, rather than identifying mentions with a preprocessing step.
The score ψM(a, i) computes the compatibility of spans a and i. Its base layer is a
vector that includes the embeddings of spans a and i, their elementwise product
u(a) ⊙ u(i), and a vector of surface features f(a, i, w), including distance, speaker,
and genre information.
Lee et al. () provide an error analysis that shows how this method can correctly link
a blaze and a ﬁre, while incorrectly linking pilots and ﬁght attendants. In each case, the
coreference decision is based on similarities in the word embeddings.
Rather than embedding individual mentions, Clark and Manning () embed men-
tion pairs. At the base layer, their network takes embeddings of the words in and around
each mention, as well as one-hot vectors representing a few surface features, such as the
distance and string matching features. This base layer is then passed through a multilayer
feedforward network with ReLU nonlinearities, resulting in a representation of the men-
tion pair. The output of the mention pair encoder ui,j is used in the scoring function of
a mention-ranking model, ψM(i, j) = θ  ui,j. A similar approach is used to score cluster
pairs, constructing a cluster-pair encoding by pooling over the mention-pair encodings
for all pairs of mentions within the two clusters.
Entity embeddings
In entity-based coreference resolution, each entity should be represented by properties of
its mentions. In a distributed setting, we maintain a set of vector entity embeddings, ve.
Each candidate mention receives an embedding ui; Wiseman et al. () compute this
embedding by a single-layer neural network, applied to a vector of surface features. The
decision of whether to merge mention i with entity e can then be driven by a feedforward
Jacob Eisenstein. Draft of November , .

.. EVALUATING COREFERENCE RESOLUTION
network, ψE(i, e) = Feedforward([ve; ui]). If i is added to entity e, then its representa-
tion is updated recurrently, ve ← f(ve, ui), using a recurrent neural network such as a
long short-term memory (LSTM; chapter ). Alternatively, we can apply a pooling oper-
ation, such as max-pooling or average-pooling (chapter ), setting ve ← Pool(ve, ui). In
either case, the update to the representation of entity e can be thought of as adding new
information about the entity from mention i.
Evaluating coreference resolution
The state of coreference evaluation is aggravatingly complex.
Early attempts at sim-
ple evaluation metrics were found to be susceptible to trivial baselines, such as placing
each mention in its own cluster, or grouping all mentions into a single cluster. Follow-
ing Denis and Baldridge (), the CoNLL  shared task on coreference (Pradhan
et al., ) formalized the practice of averaging across three different metrics: MUC (Vi-
lain et al., ), B-CUBED (Bagga and Baldwin, a), and CEAF (Luo, ). Refer-
ence implementations of these metrics are available from Pradhan et al. () at https:
//github.com/conll/reference-coreference-scorers.
Additional resources
Ng () surveys coreference resolution through . Early work focused exclusively
on pronoun resolution, with rule-based (Lappin and Leass, ) and probabilistic meth-
ods (Ge et al., ). The full coreference resolution problem was popularized in a shared
task associated with the sixth Message Understanding Conference, which included coref-
erence annotations for training and test sets of thirty documents each (Grishman and
Sundheim, ). An inﬂuential early paper was the decision tree approach of Soon et al.
(), who introduced mention ranking. A comprehensive list of surface features for
coreference resolution is offered by Bengtson and Roth (). Durrett and Klein ()
improved on prior work by introducing a large lexicalized feature set; subsequent work
has emphasized neural representations of entities and mentions (Wiseman et al., ).
Exercises
. Select an article from today’s news, and annotate coreference for the ﬁrst twenty
noun phrases and possessive pronouns that appear in the article, include ones that
are nested within larger noun phrases. Then specify the mention-pair training data
that would result from the ﬁrst ﬁve of these candidate entity mentions.
. Using your annotations from the preceding problem, compute the following statis-
tics:
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
The number of times new entities are introduced by each of the three types of
referring expressions: pronouns, proper nouns, and nominals. Include “single-
ton” entities that are mentioned only once.
For each type of referring expression, compute the fraction of mentions that are
anaphoric.
. Apply a simple heuristic to all pronouns in the article from the previous exercise:
link each pronoun to the closest preceding noun phrase that agrees in gender, num-
ber, animacy, and person. Compute the following evaluation:
True positive: a pronoun that is linked to a noun phrase with which it is coref-
erent, or is labeled as the ﬁrst mention of an entity when in fact it does not
corefer with any preceding mention. In this case, non-referential pronouns can
be true positives if they are marked as having no antecedent.
False positive: a pronoun that is linked to a noun phrase with which it is not
coreferent. This includes mistakenly linking singleton or non-referential pro-
nouns.
False negative: a pronoun that has at least one antecedent, but is either labeled
as not having an antecednet, or is linked to mention with which it does not
corefer.
Compute the F -MEASURE for your method, and for a trivial baseline in which every
pronoun refers to the immediately preceding entity mention. Are there any addi-
tional heuristics that would have improved the performance of this method?
. Durrett and Klein () compute the probability of the gold coreference clustering
by summing over all antecedent structures that are compatible with the clustering.
For example, if there are three mentions of a single entity, m, m, m, there are two
possible antecedent structures: a = , a =  and a = , a = . Compute the
number of antecedent structures for a single entity with K mentions.
. Suppose that all mentions can be unambiguously divided into C classes, for exam-
ple by gender and number. Further suppose that mentions from different classes
can never corefer. In a document with M mentions, give upper and lower bounds
on the total number of possible coreference clusterings, in terms of the Bell numbers
and the parameters M and C. Compute numerical upper and lower bounds for the
case M = , C = .
. Lee et al. () propose a model that considers all contiguous spans in a document
as possible mentions.
a) In a document of length M, how many mention pairs must be evaluated? (All
answers can be given in asymptotic, big-O notation.)
Jacob Eisenstein. Draft of November , .

.. EVALUATING COREFERENCE RESOLUTION
b) To make inference more efﬁcient, Lee et al. () restrict consideration to spans
of maximum length L ≪ M. Under this restriction, how many mention pairs
must be evaluated?
c) To further improve inference, one might evaluate coreference only between
pairs of mentions whose endpoints are separated by a maximum of D tokens.
Under this additional restriction, how many mention pairs must be evaluated?
. In Spanish, the subject can be omitted when it is clear from context, e.g.,
Las ballenas
The whales
no
no
son
are
peces.
ﬁsh.
Son
Are
mam´ıferos.
mammals.
Whales are not ﬁsh. They are mammals.
Resolution of such null subjects is facilitated by the Spanish system of verb mor-
phology, which includes distinctive sufﬁxes for most combinations of person and
number. For example, the verb form son (‘are’) agrees with the third-person plural
pronouns ellos (masculine) and ellas (feminine), as well as the second-person plural
ustedes.
Suppose that you are given the following components:
A system that automatically identiﬁes verbs with null subjects.
A function c(j, p) ∈ {, } that indicates whether pronoun p is compatible with
null subject j, according to the verb morphology.
A trained mention-pair model, which computes scores ψ(wi, wj, j − i) ∈ R for
all pairs of mentions i and j, scoring the pair by the antecedent mention wi, the
anaphor wj, and the distance j − i.
Describe an integer linear program that simultaneously performs two tasks: resolv-
ing coreference among all entity mentions, and identifying suitable pronouns for all
null subjects. In the example above, your program should link the null subject with
las ballenas (‘whales’), and identify ellas as the correct pronoun. For simplicity, you
may assume that null subjects cannot be antecedents, and you need not worry about
the transitivity constraint described in § ...
. Use the policy gradient algorithm to compute the gradient for the following sce-
nario, based on the Bell tree in Figure .:
The gold clustering c∗ is {Abigail, her}, {she}.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . REFERENCE RESOLUTION
Drawing a single sequence of actions (K = ) from the current policy, you
obtain the following incremental clusterings:
c(a) ={Abigail}
c(a:) ={Abigail, she}
c(a:) ={Abigail, she}, {her}.
At each mention t, the space of actions At includes merging the mention with
each existing cluster or with the empty cluster. The probability of merging mt
with cluster c is proportional to the exponentiated score for the merged cluster,
p(Merge(mt, c))) ∝ exp ψE(mt ∪ c),
where ψE(mt ∪ c) is deﬁned in Equation ..
Compute the gradient
∂θL(θ) in terms of the loss ℓ(c(a)) and the features of each
(potential) cluster. Explain the differences between the gradient-based update θ ← θ − ∂
∂θL(θ)
and the incremental perceptron update from this same example.
. As discussed in § .., some pronouns are not referential. In English, this occurs
frequently with the word it. Download the text of Alice in Wonderland from NLTK,
and examine the ﬁrst ten appearances of it. For each occurrence:
First, examine a ﬁve-token window around the word. In the ﬁrst example, this
window is,
, but it had no
Is there another pronoun that could be substituted for it? Consider she, they,
and them. In this case, both she and they yield grammatical substitutions. What
about the other ten appearances of it?
Now, view an ﬁfteen-word window for each example. Based on this window,
mark whether you think the word it is referential.
How often does the substitution test predict whether it is referential?
. Now try to automate the test, using the Google n-grams corpus (Brants and Franz,
). Speciﬁcally, ﬁnd the count of each -gram containing it, and then compute
the counts of -grams in which it is replaced with other third-person pronouns: he,
she, they, her, him, them, herself, himself.
There are various ways to get these counts.
One approach is to download the
raw data and search it; another is to construct web queries to https://books.
google.com/ngrams.
Jacob Eisenstein. Draft of November , .

.. EVALUATING COREFERENCE RESOLUTION
Compare the ratio of the counts of the original -gram to the summed counts of
the -grams created by substitution. Is this ratio a good predictor of whether it is
referential?
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Chapter
Discourse
Applications of natural language processing often concern multi-sentence documents:
from paragraph-long restaurant reviews, to -word newspaper articles, to -page
novels. Yet most of the methods that we have discussed thus far are concerned with
individual sentences. This chapter discusses theories and methods for handling multi-
sentence linguistic phenomena, known collectively as discourse. There are diverse char-
acterizations of discourse structure, and no single structure is ideal for every computa-
tional application. This chapter covers some of the most well studied discourse repre-
sentations, while highlighting computational models for identifying and exploiting these
structures.
Segments
A document or conversation can be viewed as a sequence of segments, each of which is
cohesive in its content and/or function. In Wikipedia biographies, these segments often
pertain to various aspects to the subject’s life: early years, major events, impact on others,
and so on. This segmentation is organized around topics. Alternatively, scientiﬁc research
articles are often organized by functional themes: the introduction, a survey of previous
research, experimental setup, and results.
Written texts often mark segments with section headers and related formatting de-
vices. However, such formatting may be too coarse-grained to support applications such
as the retrieval of speciﬁc passages of text that are relevant to a query (Hearst, ).
Unformatted speech transcripts, such as meetings and lectures, are also an application
scenario for segmentation (Carletta, ; Glass et al., ; Janin et al., ).
CHAPTER . DISCOURSE
original
smoothing L=
smoothing L=
cosine similarity
sentence
Figure .: Smoothed cosine similarity among adjacent sentences in a news article. Local
minima at m =  and m =  indicate likely segmentation points.
Topic segmentation
A cohesive topic segment forms a uniﬁed whole, using various linguistic devices: re-
peated references to an entity or event; the use of conjunctions to link related ideas; and
the repetition of meaning through lexical choices (Halliday and Hasan, ). Each of
these cohesive devices can be measured, and then used as features for topic segmentation.
A classical example is the use of lexical cohesion in the TEXTTILING method for topic seg-
mentation (Hearst, ). The basic idea is to compute the textual similarity between each
pair of adjacent blocks of text (sentences or ﬁxed-length units), using a formula such as
the smoothed cosine similarity of their bag-of-words vectors,
sm =
xm  xm+
||xm|| × ||xm+||
sm =
ℓ=
kℓ(sm+ℓ + sm−ℓ),
with kℓ representing the value of a smoothing kernel of size L, e.g. k = [, ., .]⊤.
Segmentation points are then identiﬁed at local minima in the smoothed similarities s,
since these points indicate changes in the overall distribution of words in the text. An
example is shown in Figure ..
Text segmentation can also be formulated as a probabilistic model, in which each seg-
ment has a unique language model that deﬁnes the probability over the text in the seg-
ment (Utiyama and Isahara, ; Eisenstein and Barzilay, ; Du et al., ). A good
There is a rich literature on how latent variable models (such as latent Dirichlet allocation) can track
Jacob Eisenstein. Draft of November , .

.. ENTITIES AND REFERENCE
segmentation achieves high likelihood by grouping segments with similar word distribu-
tions. This probabilistic approach can be extended to hierarchical topic segmentation, in
which each topic segment is divided into subsegments (Eisenstein, ). All of these ap-
proaches are unsupervised. While labeled data can be obtained from well-formatted texts
such as textbooks, such annotations may not generalize to speech transcripts in alterna-
tive domains. Supervised methods have been tried in cases where in-domain labeled data
is available, substantially improving performance by learning weights on multiple types
of features (Galley et al., ).
Functional segmentation
In some genres, there is a canonical set of communicative functions: for example, in sci-
entiﬁc research articles, one such function is to communicate the general background for
the article, another is to introduce a new contribution, or to describe the aim of the re-
search (Teufel et al., ). A functional segmentation divides the document into con-
tiguous segments, sometimes called rhetorical zones, in which each sentence has the same
function. Teufel and Moens () train a supervised classiﬁer to identify the functional
of each sentence in a set of scientiﬁc research articles, using features that describe the sen-
tence’s position in the text, its similarity to the rest of the article and title, tense and voice of
the main verb, and the functional role of the previous sentence. Functional segmentation
can also be performed without supervision. Noting that some types of Wikipedia arti-
cles have very consistent functional segmentations (e.g., articles about cities or chemical
elements), Chen et al. () introduce an unsupervised model for functional segmenta-
tion, which learns both the language model associated with each function and the typical
patterning of functional segments across the article.
Entities and reference
Another dimension of discourse relates to which entities are mentioned throughout the
text, and how. Consider the examples in Figure .: Grosz et al. () argue that the ﬁrst
discourse is more coherent. Do you agree? The examples differ in their choice of refer-
ring expressions for the protagonist John, and in the syntactic constructions in sentences
(b) and (d). The examples demonstrate the need for theoretical models to explain how
referring expressions are chosen, and where they are placed within sentences. Such mod-
els can then be used to help interpret the overall structure of the discourse, to measure
discourse coherence, and to generate discourses in which referring expressions are used
coherently.
topics across documents (Blei et al., ; Blei, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
a. John went to his favorite music
store to buy a piano.
a. John went to his favorite music
store to buy a piano.
b. He had frequented the store for
many years.
b. It was a store John had fre-
quented for many years.
c. He was excited that he could ﬁ-
nally buy a piano.
c. He was excited that he could ﬁ-
nally buy a piano.
d. He arrived just as the store was
closing for the day
d. It was closing just as John ar-
rived.
Figure .: Two tellings of the same story (Grosz et al., ). The discourse on the left
uses referring expressions coherently, while the one on the right does not.
Centering theory
Centering theory presents a uniﬁed account of the relationship between discourse struc-
ture and entity reference (Grosz et al., ). According to the theory, every utterance in
the discourse is characterized by a set of entities, known as centers.
The forward-looking centers in utterance m are all the entities that are mentioned
in the utterance, cf(wm) = {e, e, . . . , }. The forward-looking centers are partially
ordered by their syntactic prominence, favoring subjects over objects, and objects
over other positions (Brennan et al., ). For example, in example (.a) of Fig-
ure ., the ordered list of forward-looking centers in the ﬁrst utterance is John, the
music store, and the piano.
The backward-looking center cb(wm) is the highest-ranked element in the set of
forward-looking centers from the previous utterance cf(wm−) that is also men-
tioned in wm. In example (.b) of item ., the backward looking center is John.
Given these two deﬁnitions, centering theory makes the following predictions about
the form and position of referring expressions:
. If a pronoun appears in the utterance wm, then the backward-looking center cb(wm)
must also be realized as a pronoun. This rule argues against the use of it to refer
to the piano store in Example (.d), since JOHN is the backward looking center of
(.d), and he is mentioned by name and not by a pronoun.
. Sequences of utterances should retain the same backward-looking center if possible,
and ideally, the backward-looking center should also be the top-ranked element in
the list of forward-looking centers. This rule argues in favor of the preservation of
JOHN as the backward-looking center throughout Example (.).
Jacob Eisenstein. Draft of November , .

.. ENTITIES AND REFERENCE
SKYLER
WALTER
DANGER
A GUY
THE DOOR
You don’t know who you’re talk-
ing to,
so let me clue you in.
I am not in danger, Skyler.
I am the danger.
A guy opens his door and gets
shot,
and you think that of me?
No. I am the one who knocks!
Figure .: The entity grid representation for a dialogue from the television show Break-
ing Bad.
Centering theory uniﬁes aspects of syntax, discourse, and anaphora resolution. However,
it can be difﬁcult to clarify exactly how to rank the elements of each utterance, or even
how to partition a text or dialog into utterances (Poesio et al., ).
The entity grid
One way to formalize the ideas of centering theory is to arrange the entities in a text or
conversation in an entity grid. This is a data structure with one row per sentence, and
one column per entity (Barzilay and Lapata, ). Each cell c(m, i) can take the following
values:
c(m, i) =

S,
entity i is in subject position in sentence m
O,
entity i is in object position in sentence m
X,
entity i appears in sentence m, in neither subject nor object position
entity i does not appear in sentence m.
To populate the entity grid, syntactic parsing is applied to identify subject and object
positions, and coreference resolution is applied to link multiple mentions of a single entity.
An example is shown in Figure ..
After the grid is constructed, the coherence of a document can be measured by the
transitions between adjacent cells in each column. For example, the transition (S → S)
keeps an entity in subject position across adjacent sentences; the transition (O → S) pro-
motes an entity from object position to subject position; the transition (S → −) drops the
subject of one sentence from the next sentence. The probabilities of each transition can be
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
estimated from labeled data, and an entity grid can then be scored by the sum of the log-
probabilities across all columns and all transitions, PNe
i=
PM
m= log p(c(m, i) | c(m − , i)).
The resulting probability can be used as a proxy for the coherence of a text. This has been
shown to be useful for a range of tasks: determining which of a pair of articles is more
readable (Schwarm and Ostendorf, ), correctly ordering the sentences in a scrambled
text (Lapata, ), and disentangling multiple conversational threads in an online multi-
party chat (Elsner and Charniak, ).
*Formal semantics beyond the sentence level
An alternative view of the role of entities in discourse focuses on formal semantics, and the
construction of meaning representations for multi-sentence units. Consider the following
two sentences (from Bird et al., ):
a. Angus owns a dog.
b. It bit Irene.
We would like to recover the formal semantic representation,
∃x.DOG(x) ∧ OWN(ANGUS, x) ∧ BITE(x, IRENE).
However, the semantic representations of each individual sentence are,
∃x.DOG(x) ∧ OWN(ANGUS, x)
BITE(y, IRENE).
Unifying these two representations into the form of Equation . requires linking the
unbound variable y from [.] with the quantiﬁed variable x in [.]. Discourse un-
derstanding therefore requires the reader to update a set of assignments, from variables
to entities. This update would (presumably) link the dog in the ﬁrst sentence of [.]
with the unbound variable y in the second sentence, thereby licensing the conjunction in
[.]. This basic idea is at the root of dynamic semantics (Groenendijk and Stokhof,
). Segmented discourse representation theory links dynamic semantics with a set
of discourse relations, which explain how adjacent units of text are rhetorically or con-
ceptually related (Lascarides and Asher, ). The next section explores the theory of
discourse relations in more detail.
Groenendijk and Stokhof () treats the y variable in Equation . as unbound. Even if it were bound
locally with an existential quantiﬁer (∃yBITE(y, IRENE)), the variable would still need to be reconciled with
the quantiﬁed variable in Equation ..
This linking task is similar to coreference resolution (see chapter ), but here the connections are be-
tween semantic variables, rather than spans of text.
Jacob Eisenstein. Draft of November , .

.. RELATIONS
Relations
In dependency grammar, sentences are characterized by a graph (usually a tree) of syntac-
tic relations between words, such as NSUBJ and DET. A similar idea can be applied at the
document level, identifying relations between discourse units, such as clauses, sentences,
or paragraphs. The task of discourse parsing involves identifying discourse units and
the relations that hold between them. These relations can then be applied to tasks such as
document classiﬁcation and summarization, as discussed in § ...
Shallow discourse relations
The existence of discourse relations is hinted by discourse connectives, such as however,
moreover, meanwhile, and if . . . then. These connectives explicitly specify the relationship
between adjacent units of text: however signals a contrastive relationship, moreover signals
that the subsequent text elaborates or strengthens the point that was made immediately
beforehand, meanwhile indicates that two events are contemporaneous, and if ...then sets
up a conditional relationship. Discourse connectives can therefore be viewed as a starting
point for the analysis of discourse relations.
In lexicalized tree-adjoining grammar for discourse (D-LTAG), each connective an-
chors a relationship between two units of text (Webber, ). This model provides the
theoretical basis for the Penn Discourse Treebank (PDTB), the largest corpus of discourse
relations in English (Prasad et al., ). It includes a hierarchical inventory of discourse
relations (shown in Table .), which is created by abstracting the meanings implied by
the discourse connectives that appear in real texts (Knott, ). These relations are then
annotated on the same corpus of news text used in the Penn Treebank (see § ..), adding
the following information:
Each connective is annotated for the discourse relation or relations that it expresses,
if any — many discourse connectives have senses in which they do not signal a
discourse relation (Pitler and Nenkova, ).
For each discourse relation, the two arguments of the relation are speciﬁed as ARG
and ARG, where ARG is constrained to be adjacent to the connective. These argu-
ments may be sentences, but they may also smaller or larger units of text.
Adjacent sentences are annotated for implicit discourse relations, which are not
marked by any connective. When a connective could be inserted between a pair
of sentence, the annotator supplies it, and also labels its sense (e.g., example .).
In some cases, there is no relationship at all between a pair of adjacent sentences;
in other cases, the only relation is that the adjacent sentences mention one or more
shared entity. These phenomena are annotated as NOREL and ENTREL (entity rela-
tion), respectively.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
COMPARISON
TEMPORAL
– Asynchronous
– Synchronous:
precedence, succession
– Contrast: juxtaposition, opposition
– Pragmatic contrast
– Concession: expectation,
contra-expectation
– Pragmatic concession
CONTINGENCY
EXPANSION
– Cause: result, reason
– Pragmatic cause:
justiﬁcation
– Conjunction
– Instantiation
– Restatement: speciﬁcation,
equivalence, generalization
– Condition: hypothetical,
general, unreal present,
unreal past, real present,
real past
– Alternative: conjunctive, disjunctive,
chosen alternative
– Pragmatic condition:
relevance, implicit
assertion
– Exception
– List
Table .: The hierarchy of discourse relation in the Penn Discourse Treebank annota-
tions (Prasad et al., ). For example, PRECEDENCE is a subtype of SYNCHRONOUS,
which is a type of TEMPORAL relation.
Examples of Penn Discourse Treebank annotations are shown in (.). In (.), the
word therefore acts as an explicit discourse connective, linking the two adjacent units of
text. The Treebank annotations also specify the “sense” of each relation, linking the con-
nective to a relation in the sense inventory shown in Table .: in (.), the relation is
PRAGMATIC CAUSE:JUSTIFICATION because it relates to the author’s communicative in-
tentions. The word therefore can also signal causes in the external world (e.g., He was
therefore forced to relinquish his plan). In discourse sense classiﬁcation, the goal is to de-
termine which discourse relation, if any, is expressed by each connective. A related task
is the classiﬁcation of implicit discourse relations, as in (.). In this example, the re-
lationship between the adjacent sentences could be expressed by the connective because,
indicating a CAUSE:REASON relationship.
Classifying explicit discourse relations and their arguments
As suggested by the examples above, many connectives can be used to invoke multiple
types of discourse relations. Similarly, some connectives have senses that are unrelated
to discourse: for example, and functions as a discourse connective when it links propo-
Jacob Eisenstein. Draft of November , .

.. RELATIONS
. . .as this business of whaling has somehow come to be regarded among landsmen as a
rather unpoetical and disreputable pursuit; therefore, I am all anxiety to convince
ye, ye landsmen, of the injustice hereby done to us hunters of whales.
But a few funds have taken other defensive steps. Some have raised their cash
positions to record levels. Implicit = BECAUSE High cash positions help buffer a
fund when the market falls.
Michelle lives in a hotel room, and although she drives a canary-colored
Porsche, she hasn’t time to clean or repair it.
Most oil companies, when they set exploration and production budgets for this
year, forecast revenue of $ for each barrel of crude produced.
Figure .: Example annotations of discourse relations. In the style of the Penn Discourse
Treebank, the discourse connective is underlined, the ﬁrst argument is shown in italics,
and the second argument is shown in bold. Examples (.-.) are quoted from Prasad
et al. ().
sitions, but not when it links noun phrases (Lin et al., ). Nonetheless, the senses of
explicitly-marked discourse relations in the Penn Treebank are relatively easy to classify,
at least at the coarse-grained level. When classifying the four top-level PDTB relations,
% accuracy can be obtained simply by selecting the most common relation for each
connective (Pitler and Nenkova, ). At the more ﬁne-grained levels of the discourse
relation hierarchy, connectives are more ambiguous. This fact is reﬂected both in the ac-
curacy of automatic sense classiﬁcation (Versley, ) and in interannotator agreement,
which falls to % for level- discourse relations (Prasad et al., ).
A more challenging task for explicitly-marked discourse relations is to identify the
scope of the arguments. Discourse connectives need not be adjacent to ARG, as shown
in item ., where ARG follows ARG; furthermore, the arguments need not be contigu-
ous, as shown in (.). For these reasons, recovering the arguments of each discourse
connective is a challenging subtask. Because intra-sentential arguments are often syn-
tactic constituents (see chapter ), many approaches train a classiﬁer to predict whether
each constituent is an appropriate argument for each explicit discourse connective (Well-
ner and Pustejovsky, ; Lin et al., , e.g.,).
Classifying implicit discourse relations
Implicit discourse relations are considerably more difﬁcult to classify and to annotate.
Most approaches are based on an encoding of each argument, which is then used as input
In the dataset for the  shared task on shallow discourse parsing, the interannotator agreement was
% for explicit discourse relations and % for implicit relations, across all levels of detail (Xue et al., ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
to a nonlinear classiﬁer:
z(i) =Encode(w(i))
z(i+) =Encode(w(i+))
ˆyi = argmax
Ψ(y, z(i), z(i+)).
This basic framework can be instantiated in several ways, including both feature-based
and neural encoders.
Feature-based approaches
Each argument can be encoded into a vector of surface fea-
tures. The encoding typically includes lexical features (all words, or all content words, or
a subset of words such as the ﬁrst three and the main verb), Brown clusters of individ-
ual words (§ .), and syntactic features such as terminal productions and dependency
arcs (Pitler et al., ; Lin et al., ; Rutherford and Xue, ). The classiﬁcation func-
tion then has two parts. First, it creates a joint feature vector by combining the encodings
of each argument, typically by computing the cross-product of all features in each encod-
ing:
f(y, z(i), z(i+)) = {(a × b × y) : (z(i)
a z(i+)
The size of this feature set grows with the square of the size of the vocabulary, so it can be
helpful to select a subset of features that are especially useful on the training data (Park
and Cardie, ). After f is computed, any classiﬁer can be trained to compute the ﬁnal
score, Ψ(y, z(i), z(i+)) = θ  f(y, z(i), z(i+)).
Neural network approaches
In neural network architectures, the encoder is learned
jointly with the classiﬁer as an end-to-end model. Each argument can be encoded using
a variety of neural architectures (surveyed in § .): recursive (§ ..; Ji and Eisenstein,
), recurrent (§ .; Ji et al., ), and convolutional (§ .; Qin et al., ). The clas-
siﬁcation function can then be implemented as a feedforward neural network on the two
encodings (chapter ; for examples, see Rutherford et al., ; Qin et al., ), or as a
simple bilinear product, Ψ(y, z(i), z(i+)) = (z(i))⊤Θyz(i+) (Ji and Eisenstein, ). The
encoding model can be trained by backpropagation from the classiﬁcation objective, such
as the margin loss. Rutherford et al. () show that neural architectures outperform
feature-based approaches in most settings. While neural approaches require engineering
the network architecture (e.g., embedding size, number of hidden units in the classiﬁer),
feature-based approaches also require signiﬁcant engineering to incorporate linguistic re-
sources such as Brown clusters and parse trees, and to select a subset of relevant features.
Jacob Eisenstein. Draft of November , .

.. RELATIONS
Hierarchical discourse relations
In sentence parsing, adjacent phrases combine into larger constituents, ultimately pro-
ducing a single constituent for the entire sentence. The resulting tree structure enables
structured analysis of the sentence, with subtrees that represent syntactically coherent
chunks of meaning. Rhetorical Structure Theory (RST) extends this style of hierarchical
analysis to the discourse level (Mann and Thompson, ).
The basic element of RST is the discourse unit, which refers to a contiguous span of
text. Elementary discourse units (EDUs) are the atomic elements in this framework, and
are typically (but not always) clauses. Each discourse relation combines two or more
adjacent discourse units into a larger, composite discourse unit; this process ultimately
unites the entire text into a tree-like structure.
Nuclearity
In many discourse relations, one argument is primary. For example:
[LaShawn loves animals]N
[She has nine dogs and one pig]S
In this example, the second sentence provides EVIDENCE for the point made in the ﬁrst
sentence. The ﬁrst sentence is thus the nucleus of the discourse relation, and the second
sentence is the satellite. The notion of nuclearity is similar to the head-modiﬁer structure
of dependency parsing (see § ..). However, in RST, some relations have multiple
nuclei. For example, the arguments of the CONTRAST relation are equally important:
[The clash of ideologies survives this treatment]N
[but the nuance and richness of Gorky’s individual characters have vanished in the scufﬂe]N
Relations that have multiple nuclei are called coordinating; relations with a single nu-
cleus are called subordinating. Subordinating relations are constrained to have only two
arguments, while coordinating relations (such as CONJUNCTION) may have more than
two.
Details of discourse segmentation can be found in the RST annotation manual (Carlson and Marcu,
While RST analyses are typically trees, this should not be taken as a strong theoretical commitment to
the principle that all coherent discourses have a tree structure. Taboada and Mann () write:
It is simply the case that trees are convenient, easy to represent, and easy to understand. There
is, on the other hand, no theoretical reason to assume that trees are the only possible represen-
tation of discourse structure and of coherence relations.
The appropriateness of tree structures to discourse has been challenged, e.g., by Wolf and Gibson (), who
propose a more general graph-structured representation.
from the RST Treebank (Carlson et al., )
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
Concession

Justify

Conjunction
Elaboration

Justify
Conjunction
[It could have been a great movie]A [It does have beautiful scenery,]B [some of
the best since Lord of the Rings.]C [The acting is well done,]D [and I really liked
the son of the leader of the Samurai.]E [He was a likable chap,]F [and I :::::
hated to
see him die.]G [But, other than all that, this movie is
nothing more than hidden
rip-oﬀs.]H
Figure .: A rhetorical structure theory analysis of a short movie review, adapted from
Voll and Taboada (). Positive and :::::::::
negative sentiment words are underlined, indicat-
ing RST’s potential utility in document-level sentiment analysis.
RST Relations
Rhetorical structure theory features a large inventory of discourse rela-
tions, which are divided into two high-level groups: subject matter relations, and presen-
tational relations. Presentational relations are organized around the intended beliefs of
the reader. For example, in (.), the second discourse unit provides evidence intended
to increase the reader’s belief in the proposition expressed by the ﬁrst discourse unit, that
LaShawn loves animals. In contrast, subject-matter relations are meant to communicate ad-
ditional facts about the propositions contained in the discourse units that they relate:
[the debt plan was rushed to completion]N
[in order to be announced at the meeting]S
In this example, the satellite describes a world state that is realized by the action described
in the nucleus. This relationship is about the world, and not about the author’s commu-
nicative intentions.
Example
Figure . depicts an RST analysis of a paragraph from a movie review. Asym-
metric (subordinating) relations are depicted with an arrow from the satellite to the nu-
cleus; symmetric (coordinating) relations are depicted with lines. The elementary dis-
course units F and G are combined into a larger discourse unit with the symmetric
CONJUNCTION relation. The resulting discourse unit is then the satellite in a JUSTIFY
relation with E.
from the RST Treebank (Carlson et al., )
Jacob Eisenstein. Draft of November , .

.. RELATIONS
Hierarchical discourse parsing
The goal of discourse parsing is to recover a hierarchical structural analysis from a doc-
ument text, such as the analysis in Figure .. For now, let’s assume a segmentation of
the document into elementary discourse units (EDUs); segmentation algorithms are dis-
cussed below. After segmentation, discourse parsing can be viewed as a combination of
two components: the discourse relation classiﬁcation techniques discussed in § .., and
algorithms for phrase-structure parsing, such as chart parsing and shift-reduce, which
were discussed in chapter .
Both chart parsing and shift-reduce require encoding composite discourse units, ei-
ther in a discrete feature vector or a dense neural representation. Some discourse parsers
rely on the strong compositionality criterion (Marcu, ), which states the assumption
that a composite discourse unit can be represented by its nucleus. This criterion is used in
feature-based discourse parsing to determine the feature vector for a composite discourse
unit (Hernault et al., ); it is used in neural approaches to setting the vector encod-
ing for a composite discourse unit equal to the encoding of its nucleus (Ji and Eisenstein,
). An alternative neural approach is to learn a composition function over the compo-
nents of a composite discourse unit (Li et al., ), using a recursive neural network (see
§ ..).
Bottom-up discourse parsing
Assume a segmentation of the text into N elementary
discourse units with base representations {z(i)}N
i=, and assume a composition function
COMPOSE
z(i), z(j), ℓ
, which maps two encodings and a discourse relation ℓ into a new
encoding. The composition function can follow the strong compositionality criterion and
simply select the encoding of the nucleus, or it can do something more complex. We
also need a scoring function Ψ(z(i,k), z(k,j), ℓ), which computes a scalar score for the (bi-
narized) discourse relation ℓ with left child covering the span i +  : k, and the right
child covering the span k +  : j. Given these components, we can construct vector rep-
resentations for each span, and this is the basic idea underlying compositional vector
grammars (Socher et al., ).
These same components can also be used in bottom-up parsing, in a manner that is
similar to the CKY algorithm for weighted context-free grammars (see § .): compute
the score and best analysis for each possible span of increasing lengths, while storing
back-pointers that make it possible to recover the optimal parse of the entire input. How-
ever, there is an important distinction from CKY parsing: for each labeled span (i, j, ℓ), we
must use the composition function to construct a representation z(i,j,ℓ). This representa-
tion is then used to combine the discourse unit spanning i+ : j in higher-level discourse
relations. The representation z(i,j,ℓ) depends on the entire substructure of the unit span-
To use these algorithms, is also necessary to binarize all discourse relations during parsing, and then to
“unbinarize” them to reconstruct the desired structure (e.g., Hernault et al., ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
ning i +  : j, and this violates the locality assumption that underlie CKY’s optimality
guarantee. Bottom-up parsing with recursively constructed span representations is gen-
erally not guaranteed to ﬁnd the best-scoring discourse parse. This problem is explored
in an exercise at the end of the chapter.
Transition-based discourse parsing
One drawback of bottom-up parsing is its cubic
time complexity in the length of the input. For long documents, transition-based parsing
is an appealing alternative. The shift-reduce algorithm (see § ..) can be applied to
discourse parsing fairly directly (Sagae, ): the stack stores a set of discourse units and
their representations, and each action is chosen by a function of these representations.
This function could be a linear product of weights and features, or it could be a neural
network applied to encodings of the discourse units. The REDUCE action then performs
composition on the two discourse units at the top of the stack, yielding a larger composite
discourse unit, which goes on top of the stack. All of the techniques for integrating learn-
ing and transition-based parsing, described in § ., are applicable to discourse parsing.
Segmenting discourse units
In rhetorical structure theory, elementary discourse units do not cross the sentence bound-
ary, so discourse segmentation can be performed within sentences, assuming the sentence
segmentation is given. The segmentation of sentences into elementary discourse units is
typically performed using features of the syntactic analysis (Braud et al., ). One ap-
proach is to train a classiﬁer to determine whether each syntactic constituent is an EDU,
using features such as the production, tree structure, and head words (Soricut and Marcu,
; Hernault et al., ). Another approach is to train a sequence labeling model, such
as a conditional random ﬁeld (Sporleder and Lapata, ; Xuan Bach et al., ; Feng
et al., ). This is done using the BIO formalism for segmentation by sequence labeling,
described in § ..
Argumentation
An alternative view of text-level relational structure focuses on argumentation (Stab and
Gurevych, b). Each segment (typically a sentence or clause) may support or rebut
another segment, creating a graph structure over the text. In the following example (from
Peldszus and Stede, ), segment S provides argumentative support for the proposi-
tion in the segment S:
[We should tear the building down,]S
[because it is full of asbestos]S.
Assertions may also support or rebut proposed links between two other assertions, cre-
ating a hypergraph, which is a generalization of a graph to the case in which edges can
Jacob Eisenstein. Draft of November , .

.. RELATIONS
join any number of vertices. This can be seen by introducing another sentence into the
example:
[In principle it is possible to clean it up,]S
[but according to the mayor that is too expensive.]S
S acknowledges the validity of S, but undercuts its support of S. This can be repre-
sented by introducing a hyperedge, (S, S, S)undercut, indicating that S undercuts the
proposed relationship between S and S. S then undercuts the relevance of S.
Argumentation mining is the task of recovering such structures from raw texts. At
present, annotations of argumentation structure are relatively small: Stab and Gurevych
(a) have annotated a collection of  persuasive essays, and Peldszus and Stede ()
have solicited and annotated a set of  paragraph-length “microtexts” in German.
Applications of discourse relations
The predominant application of discourse parsing is to select content within a document.
In rhetorical structure theory, the nucleus is considered the more important element of
the relation, and is more likely to be part of a summary of the document; it may also
be more informative for document classiﬁcation. The D-LTAG theory that underlies the
Penn Discourse Treebank lacks this notion of nuclearity, but arguments may have varying
importance, depending on the relation type. For example, the span of text constituting
ARG of an expansion relation is more likely to appear in a summary, while the sentence
constituting ARG of an implicit relation is less likely (Louis et al., ). Discourse rela-
tions may also signal segmentation points in the document structure. Explicit discourse
markers have been shown to correlate with changes in subjectivity, and identifying such
change points can improve document-level sentiment classiﬁcation, by helping the clas-
siﬁer to focus on the subjective parts of the text (Trivedi and Eisenstein, ; Yang and
Cardie, ).
Extractive Summarization
Text summarization is the problem of converting a longer text into a shorter one, while
still conveying the key facts, events, ideas, and sentiments from the original. In extractive
summarization, the summary is a subset of the original text; in abstractive summariza-
tion, the summary is produced de novo, by paraphrasing the original, or by ﬁrst encoding
it into a semantic representation (see § .). The main strategy for extractive summa-
rization is to maximize coverage, choosing a subset of the document that best covers the
concepts mentioned in the document as a whole; typically, coverage is approximated by
bag-of-words overlap (Nenkova and McKeown, ). Coverage-based objectives can be
supplemented by hierarchical discourse relations, using the principle of nuclearity: in
any subordinating discourse relation, the nucleus is more critical to the overall meaning
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
of the text, and is therefore more important to include in an extractive summary (Marcu,
a). This insight can be generalized from individual relations using the concept of
discourse depth (Hirao et al., ): for each elementary discourse unit e, the discourse
depth de is the number of relations in which a discourse unit containing e is the satellite.
Both discourse depth and nuclearity can be incorporated into extractive summariza-
tion, using constrained optimization. Let xn be a bag-of-words vector representation of
elementary discourse unit n, let yn ∈ {, } indicate whether n is included in the summary,
and let dn be the depth of unit n. Furthermore, let each discourse unit have a “head” h,
which is deﬁned recursively:
if a discourse unit is produced by a subordinating relation, then its head is the head
of the (unique) nucleus;
if a discourse unit is produced by a coordinating relation, then its head is the head
of the left-most nucleus;
for each elementary discourse unit, its parent π(n) ∈ {∅, , , . . . , N} is the head of
the smallest discourse unit containing n whose head is not n;
if n is the head of the discourse unit spanning the whole document, then π(n) = ∅.
With these deﬁnitions in place, discourse-driven extractive summarization can be for-
malized as (Hirao et al., ),
dn
n=
yn
Ψ (xn, {x:N})
max
y={,}N
s.t.
n=
yn(
j=
xn,j) ≤ L
yπ(n) ≥ yn,
∀n s.t. π(n) ̸= ∅
where Ψ (xn, {x:N}) measures the coverage of elementary discourse unit n with respect
to the rest of the document, and PV
j= xn,j is the number of tokens in xn. The ﬁrst con-
straint ensures that the number of tokens in the summary has an upper bound L. The
second constraint ensures that no elementary discourse unit is included unless its parent
is also included. In this way, the discourse structure is used twice: to downweight the
contributions of elementary discourse units that are not central to the discourse, and to
ensure that the resulting structure is a subtree of the original discourse parse. The opti-
Conversely, the arguments of a multi-nuclear relation should either both be included in the summary,
or both excluded (Durrett et al., ).
Jacob Eisenstein. Draft of November , .

.. RELATIONS
Figure .: A discourse depth tree (Hirao et al., ) for the discourse parse from Fig-
ure ., in which each elementary discourse unit is connected to its parent. The discourse
units in one valid summary are underlined.
mization problem in . can be solved with integer linear programming, described in
§ ...
Figure . shows a discourse depth tree for the RST analysis from Figure ., in
which each elementary discourse is connected to (and below) its parent. The underlined
discourse units in the ﬁgure constitute the following summary:
It could have been a great movie, and I really liked the son of the leader of the
Samurai. But, other than all that, this movie is nothing more than hidden rip-offs.
Document classiﬁcation
Hierarchical discourse structures lend themselves naturally to text classiﬁcation: in a sub-
ordinating discourse relation, the nucleus should play a stronger role in the classiﬁcation
decision than the satellite. Various implementations of this idea have been proposed.
Focusing on within-sentence discourse relations and lexicon-based classiﬁcation (see
§ ..), Voll and Taboada () simply ignore the text in the satellites of each dis-
course relation.
At the document level, elements of each discourse relation argument can be reweighted,
favoring words in the nucleus, and disfavoring words in the satellite (Heerschop
et al., ; Bhatia et al., ). This approach can be applied recursively, computing
weights across the entire document. The weights can be relation-speciﬁc, so that the
features from the satellites of contrastive relations are discounted or even reversed.
Alternatively, the hierarchical discourse structure can deﬁne the structure of a re-
cursive neural network (see § ..). In this network, the representation of each
Formally, . is a special case of the knapsack problem, in which the goal is to ﬁnd a subset of items
with maximum value, constrained by some maximum weight (Cormen et al., ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
discourse unit is computed from its arguments and from a parameter correspond-
ing to the discourse relation (Ji and Smith, ).
Shallow, non-hierarchical discourse relations have also been applied to document clas-
siﬁcation. One approach is to impose a set of constraints on the analyses of individual
discourse units, so that adjacent units have the same polarity when they are connected
by a discourse relation indicating agreement, and opposite polarity when connected by a
contrastive discourse relation, indicating disagreement (Somasundaran et al., ; Zirn
et al., ). Yang and Cardie () apply explicitly-marked relations from the Penn
Discourse Treebank to the problem of sentence-level sentiment polarity classiﬁcation (see
§ .). They impose the following soft constraints:
When a CONTRAST relation appears at the beginning of a sentence, the sentence
should have the opposite sentiment polarity as its predecessor.
When an EXPANSION or CONTINGENCY appears at the beginning of a sentence, it
should have the same polarity as its predecessor.
When a CONTRAST relation appears within a sentence, the sentence should have
neutral polarity, since it is likely to express both sentiments.
These discourse-driven constraints are shown to improve performance on two datasets of
product reviews.
Coherence
Just as grammaticality is the property shared by well-structured sentences, coherence is
the property shared by well-structured discourses. One application of discourse process-
ing is to measure (and maximize) the coherence of computer-generated texts like transla-
tions and summaries (Kibble and Power, ). Coherence assessment is also used to eval-
uate human-generated texts, such as student essays (e.g., Miltsakaki and Kukich, ;
Burstein et al., ).
Coherence subsumes a range of phenomena, many of which have been highlighted
earlier in this chapter: e.g., that adjacent sentences should be lexically cohesive (Foltz
et al., ; Ji et al., ; Li and Jurafsky, ), and that entity references should follow
the principles of centering theory (Barzilay and Lapata, ; Nguyen and Joty, ).
Discourse relations also bear on the coherence of a text in a variety of ways:
Hierarchical discourse relations tend to have a “canonical ordering” of the nucleus
and satellite (Mann and Thompson, ): for example, in the ELABORATION rela-
tion from rhetorical structure theory, the nucleus always comes ﬁrst, while in the
JUSTIFICATION relation, the satellite tends to be ﬁrst (Marcu, b).
Jacob Eisenstein. Draft of November , .

.. RELATIONS
Discourse relations should be signaled by connectives that are appropriate to the
semantic or functional relationship between the arguments: for example, a coherent
text would be more likely to use however to signal a COMPARISON relation than a
temporal relation (Kibble and Power, ).
Discourse relations tend to be ordered in appear in predictable sequences: for ex-
ample, COMPARISON relations tend to immediately precede CONTINGENCY rela-
tions (Pitler et al., ). This observation can be formalized by generalizing the
entity grid model (§ ..), so that each cell (i, j) provides information about the
role of the discourse argument containing a mention of entity j in sentence i (Lin
et al., ). For example, if the ﬁrst sentence is ARG of a comparison relation, then
any entity mentions in the sentence would be labeled COMP.ARG. This approach
can also be applied to RST discourse relations (Feng et al., ).
Datasets
One difﬁculty with evaluating metrics of discourse coherence is that human-
generated texts usually meet some minimal threshold of coherence. For this reason, much
of the research on measuring coherence has focused on synthetic data. A typical setting is
to permute the sentences of a human-written text, and then determine whether the origi-
nal sentence ordering scores higher according to the proposed coherence measure (Barzi-
lay and Lapata, ). There are also small datasets of human evaluations of the coherence
of machine summaries: for example, human judgments of the summaries from the partic-
ipating systems in the  Document Understanding Conference are available online.
Researchers from the Educational Testing Service (an organization which administers sev-
eral national exams in the United States) have studied the relationship between discourse
coherence and student essay quality (Burstein et al., , ). A public dataset of es-
says from second-language learners, with quality annotations, has been made available by
researchers at Cambridge University (Yannakoudakis et al., ). At the other extreme,
Louis and Nenkova () analyze the structure of professionally written scientiﬁc essays,
ﬁnding that discourse relation transitions help to distinguish prize-winning essays from
other articles in the same genre.
Additional resources
For a manuscript-length discussion of discourse processing, see Stede (). Article-
length surveys are offered by Webber et al. () and Webber and Joshi ().
http://homepages.inf.ed.ac.uk/mlap/coherence/
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
Exercises
. Some discourse connectives tend to occur between their arguments; others can pre-
cede both arguments, and a few can follow both arguments. Indicate whether the
following connectives can occur between, before, and after their arguments: how-
ever, but, while (contrastive, not temporal), although, therefore, nonetheless.
. This exercise is to be done in pairs.
Each participant selects an article from to-
day’s news, and replaces all mentions of individual people with special tokens like
PERSON, PERSON, and so on. The other participant should then use the rules
of centering theory to guess each type of referring expression: full name (Captain
Ahab), partial name (e.g., Ahab), nominal (e.g., the ship’s captain), or pronoun. Check
whether the predictions match the original text, and whether the text conforms to
the rules of centering theory.
. In this exercise, you will produce a ﬁgure similar to Figure ..
a) Implement the smoothed cosine similarity metric from Equation ., using the
smoothing kernel k = [., ., ., .].
b) Download the text of a news article with at least ten paragraphs.
c) Compute and plot the smoothed similarity s over the length of the article.
d) Identify local minima in s as follows: ﬁrst ﬁnd all sentences m such that sm <
sm±. Then search among these points to ﬁnd the ﬁve sentences with the lowest
sm.
e) How often do the ﬁve local minima correspond to paragraph boundaries?
The fraction of local minima that are paragraph boundaries is the precision-
at-k, where in this case, k = .
The fraction of paragraph boundaries which are local minima is the recall-
at-k.
Compute precision-at-k and recall-at-k for k =  and k = .
. One way to formulate text segmentation as a probabilistic model is through the use
of the Dirichlet Compound Multinomial (DCM) distribution, which computes the
probability of a bag-of-words, DCM(x; α), where the parameter α is a vector of
positive reals. This distribution can be conﬁgured to assign high likelihood to bag-
of-words vectors that are internally coherent, such that individual words appear re-
peatedly: for example, this behavior can be observed for simple parameterizations,
such as α = α with α < .
Let ψα(i, j) represent the log-probability of a segment wi+:j under a DCM distribu-
tion with parameter α. Give a dynamic program for segmenting a text into a total
Jacob Eisenstein. Draft of November , .

.. RELATIONS
of K segments maximizing the sum of log-probabilities PK
k= ψα(sk−, sk), where
sk indexes the last token of segment k, and s = . The time complexity of your
dynamic program should not be worse than quadratic in the length of the input and
linear in the number of segments.
. Building on the previous problem, you will now adapt the CKY algorithm to per-
form hierarchical segmentation. Deﬁne a hierarchical segmentation as a set of seg-
mentations {{s(ℓ)
k }K(ℓ)
k= }L
ℓ=, where L is the segmentation depth. To ensure that the
segmentation is hierarchically valid, we require that each segmentation point s(ℓ)
at
level ℓ is also a segmentation point at level ℓ − , where ℓ > .
For simplicity, this problem focuses on binary hierarchical segmentation, so that
each segment at level ℓ >  has exactly  subsegments. Deﬁne the score of a hierar-
chical segmentation as the sum of the scores of all segments (at all levels), using the
the DCM log-probabilities from the previous problem as the segment scores. Give a
CKY-like recurrence such that the optimal “parse” of the text is the maximum log-
probability binary segmentation with exactly L levels.
. The entity grid representation of centering theory can be used to compute a score for
adjacent sentences, as described in § ... Given a set of sentences, these scores can
be used to compute an optimal ordering. Show that ﬁnding the ordering with the
maximum log probability is NP-complete, by reduction from a well-known prob-
lem.
. In § .., it is noted that bottom-up parsing with compositional vector representa-
tions of each span is not guaranteed to be optimal. In this exercise, you will construct
a minimal example proving this point. Consider a discourse with four units, with
base representations {z(i)}
i=. Construct a scenario in which the parse selected by
bottom-up parsing is not optimal, and give the precise mathematical conditions un-
der which this suboptimal parse is selected. You may ignore the relation labels ℓ for
the purpose of this example.
. As noted in § .., arguments can described by hypergraphs, in which a segment
may undercut a proposed edge between two other segments. Extend the model of
extractive summarization described in § .. to arguments, adding the follwoing
constraint: if segment i undercuts an argumentative relationship between j and k,
then i cannot be included in the summary unless both j and k are included. Your so-
lution should take the form of a set of linear constraints on an integer linear program
— that is, each constraint can only involve addition and subtraction of variables.
In the next two exercises, you will explore the use of discourse connectives in a real corpus.
Using NLTK, acquire the Brown corpus, and identify sentences that begin with any of the
following connectives: however, nevertheless, moreover, furthermore, thus.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . DISCOURSE
. Both lexical consistency and discourse connectives contribute to the cohesion of a
text. We might therefore expect adjacent sentences that are joined by explicit dis-
course connectives to also have higher word overlap. Using the Brown corpus, test
this theory by computing the average cosine similarity between adjacent sentences
that are connected by one of the connectives mentioned above. Compare this to the
average cosine similarity of all other adjacent sentences. If you know how, perform
a two-sample t-test to determine whether the observed difference is statistically sig-
niﬁcant.
. Group the above connectives into the following three discourse relations:
Expansion: moreover, furthermore
Comparison: however, nevertheless
Contingency: thus
Focusing on pairs of sentences which are joined by one of these ﬁve connectives,
build a classiﬁer to predict the discourse relation from the text of the two adjacent
sentences — taking care to ignore the connective itself. Use the ﬁrst  sentences
of the Brown corpus as the training set, and the remaining sentences as the test
set. Compare the performance of your classiﬁer against simply choosing the most
common class. Using a bag-of-words classiﬁer, it is hard to do much better than this
baseline, so consider more sophisticated alternatives!
Jacob Eisenstein. Draft of November , .

Part IV
Applications
Chapter
Information extraction
Computers offer powerful capabilities for searching and reasoning about structured records
and relational data. Some have argued that the most important limitation of artiﬁcial in-
telligence is not inference or learning, but simply having too little knowledge (Lenat et al.,
). Natural language processing provides an appealing solution: automatically con-
struct a structured knowledge base by reading natural language text.
For example, many Wikipedia pages have an “infobox” that provides structured in-
formation about an entity or event. An example is shown in Figure .a: each row rep-
resents one or more properties of the entity IN THE AEROPLANE OVER THE SEA, a record
album. The set of properties is determined by a predeﬁned schema, which applies to all
record albums in Wikipedia. As shown in Figure .b, the values for many of these ﬁelds
are indicated directly in the ﬁrst few sentences of text on the same Wikipedia page.
The task of automatically constructing (or “populating”) an infobox from text is an
example of information extraction. Much of information extraction can be described in
terms of entities, relations, and events.
Entities are uniquely speciﬁed objects in the world, such as people (JEFF MANGUM),
places (ATHENS, GEORGIA), organizations (MERGE RECORDS), and times (FEBRUARY
, ). Chapter  described the task of named entity recognition, which labels
tokens as parts of entity spans. Now we will see how to go further, linking each
entity mention to an element in a knowledge base.
Relations include a predicate and two arguments: for example, CAPITAL(GEORGIA, ATLANTA).
Events involve multiple typed arguments. For example, the production and release
CHAPTER . INFORMATION EXTRACTION
In the Aeroplane Over the Sea is the
second and ﬁnal studio album by the
American indie rock band Neutral Milk
Hotel.
It was released in the United States on
February ,  on Merge Records
and ::::
May:::::
on ::::
Blue:::::
Rose::::::::
Records in
the United Kingdom.
Jeff::::::::::
Mangum
moved
from
Athens,
Georgia to Denver, Colorado to prepare
the bulk of the album’s material with
producer Robert Schneider, this time at
Schneider’s newly created Pet Sounds
Studio at the home of:::
Jim:::::::::
McIntyre.
(a) A Wikipedia infobox
(b) The ﬁrst few sentences of text. Strings that
match ﬁelds or ﬁeld names in the infobox are
underlined; strings that mention other entities
are :::::
wavy::::::::::
underlined.
Figure .: From the Wikipedia page for the album “In the Aeroplane Over the Sea”,
retrieved October , .
of the album described in Figure . is described by the event,
⟨TITLE : IN THE AEROPLANE OVER THE SEA,
ARTIST : NEUTRAL MILK HOTEL,
RELEASE-DATE : -FEB-, . . .⟩
The set of arguments for an event type is deﬁned by a schema. Events often refer to
time-delimited occurrences: weddings, protests, purchases, terrorist attacks.
Information extraction is similar to semantic role labeling (chapter ): we may think
of predicates as corresponding to events, and the arguments as deﬁning slots in the event
representation. However, the goals of information extraction are different. Rather than
accurately parsing every sentence, information extraction systems often focus on recog-
nizing a few key relation or event types, or on the task of identifying all properties of a
given entity. Information extraction is often evaluated by the correctness of the resulting
knowledge base, and not by how many sentences were accurately parsed. The goal is
sometimes described as macro-reading, as opposed to micro-reading, in which each sen-
tence must be analyzed correctly. Macro-reading systems are not penalized for ignoring
difﬁcult sentences, as long as they can recover the same information from other, easier-
to-read sources. However, macro-reading systems must resolve apparent inconsistencies
Jacob Eisenstein. Draft of November , .

.. ENTITIES
(was the album released on MERGE RECORDS or BLUE ROSE RECORDS?), requiring rea-
soning across the entire dataset.
In addition to the basic tasks of recognizing entities, relations, and events, information
extraction systems must handle negation, and must be able to distinguish statements of
fact from hopes, fears, hunches, and hypotheticals. Finally, information extraction is of-
ten paired with the problem of question answering, which requires accurately parsing a
query, and then selecting or generating a textual answer. Question answering systems can
be built on knowledge bases that are extracted from large text corpora, or may attempt to
identify answers directly from the source texts.
Entities
The starting point for information extraction is to identify mentions of entities in text.
Consider the following example:
The United States Army captured a hill overlooking Atlanta on May , .
For this sentence, there are two goals:
. Identify the spans United States Army, Atlanta, and May ,  as entity mentions.
(The hill is not uniquely identiﬁed, so it is not a named entity.) We may also want to
recognize the named entity types: organization, location, and date. This is named
entity recognition, and is described in chapter .
. Link these spans to entities in a knowledge base: U.S. ARMY, ATLANTA, and -
MAY-. This task is known as entity linking.
The strings to be linked to entities are mentions — similar to the use of this term in
coreference resolution. In some formulations of the entity linking task, only named enti-
ties are candidates for linking. This is sometimes called named entity linking (Ling et al.,
). In other formulations, such as Wikiﬁcation (Milne and Witten, ), any string
can be a mention. The set of target entities often corresponds to Wikipedia pages, and
Wikipedia is the basis for more comprehensive knowledge bases such as YAGO (Suchanek
et al., ), DBPedia (Auer et al., ), and Freebase (Bollacker et al., ). Entity link-
ing may also be performed in more “closed” settings, where a much smaller list of targets
is provided in advance. The system must also determine if a mention does not refer to
any entity in the knowledge base, sometimes called a NIL entity (McNamee and Dang,
Returning to (.), the three entity mentions may seem unambiguous. But the Wikipedia
disambiguation page for the string Atlanta says otherwise: there are more than twenty
https://en.wikipedia.org/wiki/Atlanta_(disambiguation), retrieved November , .
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
different towns and cities, ﬁve United States Navy vessels, a magazine, a television show,
a band, and a singer — each prominent enough to have its own Wikipedia page. We now
consider how to choose among these dozens of possibilities. In this chapter we will focus
on supervised approaches. Unsupervised entity linking is closely related to the problem
of cross-document coreference resolution, where the task is to identify pairs of mentions
that corefer, across document boundaries (Bagga and Baldwin, b; Singh et al., ).
Entity linking by learning to rank
Entity linking is often formulated as a ranking problem,
ˆy = argmax
y∈Y(x)
Ψ(y, x, c),
where y is a target entity, x is a description of the mention, Y(x) is a set of candidate
entities, and c is a description of the context — such as the other text in the document,
or its metadata. The function Ψ is a scoring function, which could be a linear model,
Ψ(y, x, c) = θ  f(y, x, c), or a more complex function such as a neural network. In either
case, the scoring function can be learned by minimizing a margin-based ranking loss,
+ ,
ℓ(ˆy, y(i), x(i), c(i)) =

Ψ(ˆy, x(i), c(i)) − Ψ(y(i), x(i), c(i)) +
where y(i) is the ground truth and ˆy ̸= y(i) is the predicted target for mention x(i) in
context c(i) (Joachims, ; Dredze et al., ).
Candidate identiﬁcation
For computational tractability, it is helpful to restrict the set of
candidates, Y(x). One approach is to use a name dictionary, which maps from strings
to the entities that they might mention. This mapping is many-to-many: a string such as
Atlanta can refer to multiple entities, and conversely, an entity such as ATLANTA can be
referenced by multiple strings. A name dictionary can be extracted from Wikipedia, with
links between each Wikipedia entity page and the anchor text of all hyperlinks that point
to the page (Bunescu and Pasca, ; Ratinov et al., ). To improve recall, the name
dictionary can be augmented by partial and approximate matching (Dredze et al., ),
but as the set of candidates grows, the risk of false positives increases. For example, the
string Atlanta is a partial match to the Atlanta Fed (a name for the FEDERAL RESERVE BANK
OF ATLANTA), and a noisy match (edit distance of one) from Atalanta (a heroine in Greek
mythology and an Italian soccer team).
Features
Feature-based approaches to entity ranking rely on three main types of local
information (Dredze et al., ):
Jacob Eisenstein. Draft of November , .

.. ENTITIES
The similarity of the mention string to the canonical entity name, as quantiﬁed by
string similarity. This feature would elevate the city ATLANTA over the basketball
team ATLANTA HAWKS for the string Atlanta.
The popularity of the entity, which can be measured by Wikipedia page views or
PageRank in the Wikipedia link graph. This feature would elevate ATLANTA, GEOR-
GIA over the unincorporated community of ATLANTA, OHIO.
The entity type, as output by the named entity recognition system. This feature
would elevate the city of ATLANTA over the magazine ATLANTA in contexts where
the mention is tagged as a location.
In addition to these local features, the document context can also help. If Jamaica is men-
tioned in a document about the Caribbean, it is likely to refer to the island nation; in
the context of New York, it is likely to refer to the neighborhood in Queens; in the con-
text of a menu, it might refer to a hibiscus tea beverage. Such hints can be formalized
by computing the similarity between the Wikipedia page describing each candidate en-
tity and the mention context c(i), which may include the bag-of-words representing the
document (Dredze et al., ; Hoffart et al., ) or a smaller window of text around
the mention (Ratinov et al., ). For example, we can compute the cosine similarity
between bag-of-words vectors for the context and entity description, typically weighted
using inverse document frequency to emphasize rare words.
Neural entity linking
An alternative approach is to compute the score for each entity
candidate using distributed vector representations of the entities, mentions, and context.
For example, for the task of entity linking in Twitter, Yang et al. () employ the bilinear
scoring function,
Ψ(y, x, c) = v⊤
y Θ(y,x)x + v⊤
y Θ(y,c)c,
with vy ∈ RKy as the vector embedding of entity y, x ∈ RKx as the embedding of the
mention, c ∈ RKc as the embedding of the context, and the matrices Θ(y,x) and Θ(y,c)
as parameters that score the compatibility of each entity with respect to the mention and
context. Each of the vector embeddings can be learned from an end-to-end objective, or
pre-trained on unlabeled data.
Pretrained entity embeddings can be obtained from an existing knowledge base (Bor-
des et al., , ), or by running a word embedding algorithm such as WORDVEC
The document frequency of word j is DF(j) =
PN
i= δ

x(i)
, equal to the number of docu-
ments in which the word appears. The contribution of each word to the cosine similarity of two bag-of-
words vectors can be weighted by the inverse document frequency
DF(j) or log
DF(j), to emphasize rare
words (Sp¨arck Jones, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
on the text of Wikipedia, with hyperlinks substituted for the anchor text.
The embedding of the mention x can be computed by averaging the embeddings
of the words in the mention (Yang et al., ), or by the compositional techniques
described in § ..
The embedding of the context c can also be computed from the embeddings of the
words in the context. A denoising autoencoder learns a function from raw text to
dense K-dimensional vector encodings by minimizing a reconstruction loss (Vin-
cent et al., ),
min
θg,θh
i=
||x(i) − g(h(˜x(i); θh); θg)||,
where ˜x(i) is a noisy version of the bag-of-words counts x(i), which is produced by
randomly setting some counts to zero; h : RV → RK is an encoder with parameters
θh; and g : RK → RV , with parameters θg. The encoder and decoder functions
are typically implemented as feedforward neural networks. To apply this model to
entity linking, each entity and context are initially represented by the encoding of
their bag-of-words vectors, h(e) and g(c), and these encodings are then ﬁne-tuned
from labeled data (He et al., ). The context vector c can also be obtained by
convolution (§ .) on the embeddings of words in the document (Sun et al., ),
or by examining metadata such as the author’s social network (Yang et al., ).
The remaining parameters Θ(y,x) and Θ(y,c) can be trained by backpropagation from the
margin loss in Equation ..
Collective entity linking
Entity linking can be more accurate when it is performed jointly across a document. To
see why, consider the following lists:
a. California, Oregon, Washington
b. Baltimore, Washington, Philadelphia
c. Washington, Adams, Jefferson
In each case, the term Washington refers to a different entity, and this reference is strongly
suggested by the other entries on the list. In the last list, all three names are highly am-
biguous — there are dozens of other Adams and Jefferson entities in Wikipedia. But a
Pre-trained entity embeddings can be downloaded from https://code.google.com/archive/p/
wordvec/.
Jacob Eisenstein. Draft of November , .

.. ENTITIES
preference for coherence motivates collectively linking these references to the ﬁrst three
U.S. presidents.
A general approach to collective entity linking is to introduce a compatibility score
ψc(y). Collective entity linking is then performed by optimizing the global objective,
i=
Ψℓ(y(i), x(i), c(i)),
ˆy = argmax
y∈Y(x)
Ψc(y) +
where Y(x) is the set of all possible collective entity assignments for the mentions in x,
and ψℓ is the local scoring function for each entity i. The compatibility function is typically
decomposed into a sum of pairwise scores, Ψc(y) = PN
i=
PN
j̸=i Ψc(y(i), y(j)). These scores
can be computed in a number of different ways:
Wikipedia deﬁnes high-level categories for entities (e.g., living people, Presidents of
the United States, States of the United States), and Ψc can reward entity pairs for the
number of categories that they have in common (Cucerzan, ).
Compatibility can be measured by the number of incoming hyperlinks shared by
the Wikipedia pages for the two entities (Milne and Witten, ).
In a neural architecture, the compatibility of two entities can be set equal to the inner
product of their embeddings, Ψc(y(i), y(j)) = vy(i)  vy(j).
A non-pairwise compatibility score can be deﬁned using a type of latent variable
model known as a probabilistic topic model (Blei et al., ; Blei, ). In this
framework, each latent topic is a probability distribution over entities, and each
document has a probability distribution over topics. Each entity helps to determine
the document’s distribution over topics, and in turn these topics help to resolve am-
biguous entity mentions (Newman et al., ). Inference can be performed using
the sampling techniques described in chapter .
Unfortunately, collective entity linking is NP-hard even for pairwise compatibility func-
tions, so exact optimization is almost certainly intractable. Various approximate inference
techniques have been proposed, including integer linear programming (Cheng and Roth,
), Gibbs sampling (Han and Sun, ), and graph-based algorithms (Hoffart et al.,
; Han et al., ).
*Pairwise ranking loss functions
The loss function deﬁned in Equation . considers only the highest-scoring prediction
ˆy, but in fact, the true entity y(i) should outscore all other entities. A loss function based on
this idea would give a gradient against the features or representations of several entities,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
Algorithm  WARP approximate ranking loss
: procedure WARP(y(i), x(i))
N ←
repeat
Randomly sample y ∼ Y(x(i))
N ← N +
if ψ(y, x(i)) +  > ψ(y(i), x(i)) then
▷ check for margin violation
r ←
|Y(x(i))|/N
▷ compute approximate rank
return Lrank(r) × (ψ(y, x(i)) +  − ψ(y(i), x(i)))
until N ≥ |Y(x(i))| −
▷ no violation found
return
▷ return zero loss
not just the top-scoring prediction. Usunier et al. () deﬁne a general ranking error
function,
Lrank(k) =
j=
αj,
with α ≥ α ≥    ≥ ,
where k is equal to the number of labels ranked higher than the correct label y(i). This
function deﬁnes a class of ranking errors: if αj =  for all j, then the ranking error is
equal to the rank of the correct entity; if α =  and αj> = , then the ranking error is
one whenever the correct entity is not ranked ﬁrst; if αj decreases smoothly with j, as in
αj =
j , then the error is between these two extremes.
This ranking error can be integrated into a margin objective. Remember that large
margin classiﬁcation requires not only the correct label, but also that the correct label
outscores other labels by a substantial margin. A similar principle applies to ranking: we
want a high rank for the correct entity, and we want it to be separated from other entities
by a substantial margin. We therefore deﬁne the margin-augmented rank,
r(y(i), x(i)) ≜
y∈Y(x(i))\y(i)

+ ψ(y, x(i)) ≥ ψ(y(i), x(i))

where δ () is a delta function, and Y(x(i)) \ y(i) is the set of all entity candidates minus
the true entity y(i). The margin-augmented rank is the rank of the true entity, after aug-
menting every other candidate with a margin of one, under the current scoring function
ψ. (The context c is omitted for clarity, and can be considered part of x.)
For each instance, a hinge loss is computed from the ranking error associated with this
Jacob Eisenstein. Draft of November , .

.. RELATIONS
margin-augmented rank, and the violation of the margin constraint,
ℓ(y(i), x(i)) =Lrank(r(y(i), x(i)))
+ ,
r(y(i), x(i))

ψ(y, x(i)) − ψ(y(i), x(i)) +
y∈Y(x)\y(i)
The sum in Equation . includes non-zero values for every label that is ranked at least as
high as the true entity, after applying the margin augmentation. Dividing by the margin-
augmented rank of the true entity thus gives the average violation.
The objective in Equation . is expensive to optimize when the label space is large,
as is usually the case for entity linking against large knowledge bases. This motivates a
randomized approximation called WARP (Weston et al., ), shown in Algorithm . In
this procedure, we sample random entities until one violates the pairwise margin con-
straint, ψ(y, x(i)) +  ≥ ψ(y(i), x(i)). The number of samples N required to ﬁnd such
a violation yields an approximation of the margin-augmented rank of the true entity,
r(y(i), x(i)) ≈
|Y(x)|
. If a violation is found immediately, N = , the correct entity
probably ranks below many others, r ≈ |Y(x)|. If many samples are required before a
violation is found, N → |Y(x)|, then the correct entity is probably highly ranked, r → .
A computational advantage of WARP is that it is not necessary to ﬁnd the highest-scoring
label, which can impose a non-trivial computational cost when Y(x(i)) is large. The objec-
tive is conceptually similar to the negative sampling objective in WORDVEC (chapter ),
which compares the observed word against randomly sampled alternatives.
Relations
After identifying the entities that are mentioned in a text, the next step is to determine
how they are related. Consider the following example:
George Bush traveled to France on Thursday for a summit.
This sentence introduces a relation between the entities referenced by George Bush and
France. In the Automatic Content Extraction (ACE) ontology (Linguistic Data Consortium,
), the type of this relation is PHYSICAL, and the subtype is LOCATED. This relation
would be written,
PHYSICAL.LOCATED(GEORGE BUSH, FRANCE).
Relations take exactly two arguments, and the order of the arguments matters.
In the ACE datasets, relations are annotated between entity mentions, as in the exam-
ple above. Relations can also hold between nominals, as in the following example from
the SemEval- shared task (Hendrickx et al., ):
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
CAUSE-EFFECT
those cancers were caused by radiation exposures
INSTRUMENT-AGENCY
phone operator
PRODUCT-PRODUCER
a factory manufactures suits
CONTENT-CONTAINER
a bottle of honey was weighed
ENTITY-ORIGIN
letters from foreign countries
ENTITY-DESTINATION
the boy went to bed
COMPONENT-WHOLE
my apartment has a large kitchen
MEMBER-COLLECTION
there are many trees in the forest
COMMUNICATION-TOPIC
the lecture was about semantics
Table .: Relations and example sentences from the SemEval- dataset (Hendrickx
et al., )
The cup contained tea from dried ginseng.
This sentence describes a relation of type ENTITY-ORIGIN between tea and ginseng. Nomi-
nal relation extraction is closely related to semantic role labeling (chapter ). The main
difference is that relation extraction is restricted to a relatively small number of relation
types; for example, Table . shows the ten relation types from SemEval-.
Pattern-based relation extraction
Early work on relation extraction focused on hand-crafted patterns (Hearst, ). For
example, the appositive Starbuck, a native of Nantucket signals the relation ENTITY-ORIGIN
between Starbuck and Nantucket. This pattern can be written as,
PERSON , a native of LOCATION ⇒ ENTITY-ORIGIN(PERSON, LOCATION).
This pattern will be “triggered” whenever the literal string , a native of occurs between an
entity of type PERSON and an entity of type LOCATION. Such patterns can be generalized
beyond literal matches using techniques such as lemmatization, which would enable the
words (buy, buys, buying) to trigger the same patterns (see § ..). A more aggressive
strategy would be to group all words in a WordNet synset (§ .), so that, e.g., buy and
purchase trigger the same patterns.
Relation extraction patterns can be implemented in ﬁnite-state automata (§ .). If the
named entity recognizer is also a ﬁnite-state machine, then the systems can be combined
by ﬁnite-state transduction (Hobbs et al., ). This makes it possible to propagate uncer-
tainty through the ﬁnite-state cascade, and disambiguate from higher-level context. For
example, suppose the entity recognizer cannot decide whether Starbuck refers to either a
PERSON or a LOCATION; in the composed transducer, the relation extractor would be free
to select the PERSON annotation when it appears in the context of an appropriate pattern.
Jacob Eisenstein. Draft of November , .

.. RELATIONS
Relation extraction as a classiﬁcation task
Relation extraction can be formulated as a classiﬁcation problem,
ˆr(i,j),(m,n) = argmax
r∈R
Ψ(r, (i, j), (m, n), w),
where r ∈ R is a relation type (possibly NIL), wi+:j is the span of the ﬁrst argument, and
wm+:n is the span of the second argument. The argument wm+:n may appear before
or after wi+:j in the text, or they may overlap; we stipulate only that wi+:j is the ﬁrst
argument of the relation. We now consider three alternatives for computing the scoring
function.
Feature-based classiﬁcation
In a feature-based classiﬁer, the scoring function is deﬁned as,
Ψ(r, (i, j), (m, n), w) = θ  f(r, (i, j), (m, n), w),
with θ representing a vector of weights, and f() a vector of features. The pattern-based
methods described in § .. suggest several features:
Local features of wi+:j and wm+:n, including: the strings themselves; whether they
are recognized as entities, and if so, which type; whether the strings are present in a
gazetteer of entity names; each string’s syntactic head (§ ..).
Features of the span between the two arguments, wj+:m or wn+:i (depending on
which argument appears ﬁrst): the length of the span; the speciﬁc words that appear
in the span, either as a literal sequence or a bag-of-words; the wordnet synsets (§ .)
that appear in the span between the arguments.
Features of the syntactic relationship between the two arguments, typically the de-
pendency path between the arguments (§ ..). Example dependency paths are
shown in Table ..
Kernels
Suppose that the ﬁrst line of Table . is a labeled example, and the remaining lines are
instances to be classiﬁed. A feature-based approach would have to decompose the depen-
dency paths into features that capture individual edges, with or without their labels, and
then learn weights for each of these features: for example, the second line contains identi-
cal dependencies, but different arguments; the third line contains a different inﬂection of
the word travel; the fourth and ﬁfth lines each contain an additional edge on the depen-
dency path; and the sixth example uses an entirely different path. Rather than attempting
to create local features that capture all of the ways in which these dependencies paths
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
George Bush traveled to France
George Bush ←
NSUBJtraveled →
OBLFrance
Ahab traveled to Nantucket
Ahab ←
NSUBJtraveled→
OBLNantucket
George Bush will travel to France
George Bush ←
NSUBJtravel →
OBLFrance
George Bush wants to travel to France
George Bush ←
NSUBJwants →
XCOMPtravel →
OBLFrance
Ahab traveled to a city in France
Ahab ←
NSUBJtraveled →
OBLcity →
NMODFrance
We await Ahab ’s visit to France
Ahab
NMOD:POSSvisit →
NMODFrance
Table .: Candidates instances for the PHYSICAL.LOCATED relation, and their depen-
dency paths
are similar and different, we can instead deﬁne a similarity function κ, which computes a
score for any pair of instances, κ : X × X → R+. The score for any pair of instances (i, j)
is κ(x(i), x(j)) ≥ , with κ(i, j) being large when instances x(i) and x(j) are similar. If the
function κ obeys a few key properties it is a valid kernel function.
Given a valid kernel function, we can build a non-linear classiﬁer without explicitly
deﬁning a feature vector or neural network architecture. For a binary classiﬁcation prob-
lem y ∈ {−, }, we have the decision function,
ˆy =Sign(b +
i=
y(i)α(i)κ(x(i), x))
where b and {α(i)}N
i= are parameters that must be learned from the training set, under
the constraint ∀i, α(i) ≥ . Intuitively, each αi speciﬁes the importance of the instance x(i)
towards the classiﬁcation rule. Kernel-based classiﬁcation can be viewed as a weighted
form of the nearest-neighbor classiﬁer (Hastie et al., ), in which test instances are
assigned the most common label among their near neighbors in the training set. This
results in a non-linear classiﬁcation boundary. The parameters are typically learned from
a margin-based objective (see § .), leading to the kernel support vector machine. To
generalize to multi-class classiﬁcation, we can train separate binary classiﬁers for each
label (sometimes called one-versus-all), or train binary classiﬁers for each pair of possible
labels (one-versus-one).
Dependency kernels are particularly effective for relation extraction, due to their abil-
ity to capture syntactic properties of the path between the two candidate arguments. One
class of dependency tree kernels is deﬁned recursively, with the score for a pair of trees
The Gram matrix K arises from computing the kernel function between all pairs in a set of instances. For
a valid kernel, the Gram matrix must be symmetric (K = K⊤) and positive semi-deﬁnite (∀a, a⊤Ka ≥ ).
For more on kernel-based classiﬁcation, see chapter  of Murphy ().
Jacob Eisenstein. Draft of November , .

.. RELATIONS
equal to the similarity of the root nodes and the sum of similarities of matched pairs of
child subtrees (Zelenko et al., ; Culotta and Sorensen, ). Alternatively, Bunescu
and Mooney () deﬁne a kernel function over sequences of unlabeled dependency
edges, in which the score is computed as a product of scores for each pair of words in the
sequence: identical words receive a high score, words that share a synset or part-of-speech
receive a small non-zero score (e.g., travel / visit), and unrelated words receive a score of
zero.
Neural relation extraction
Convolutional neural networks (§ .) were an early neural architecture for relation ex-
traction (Zeng et al., ; dos Santos et al., ). For the sentence (w, w, . . . , wM),
obtain a matrix of word embeddings X, where xm ∈ RK is the embedding of wm. Now,
suppose the candidate arguments appear at positions a and a; then for each word in
the sentence, its position with respect to each argument is m − a and m − a. (Following
Zeng et al. (), this is a restricted version of the relation extraction task in which the
arguments are single tokens.) To capture any information conveyed by these positions,
the word embeddings are concatenated with vector encodings of the positional offsets,
x(p)
m−a and x(p)
m−a. (For more on positional encodings, see § ...) The complete base
representation of the sentence is,
X(a, a) =
xM
x(p)
−a
x(p)
−a
x(p)
M−a
x(p)
−a
x(p)
−a
x(p)
M−a
 ,
where each column is a vertical concatenation of a word embedding, represented by the
column vector xm, and two positional encodings, specifying the position with respect to
a and a. The matrix X(a, a) is then taken as input to a convolutional layer (see § .),
and max-pooling is applied to obtain a vector. The ﬁnal scoring function is then,
Ψ(r, i, j, X) = θr  MaxPool(ConvNet(X(i, j); φ)),
where φ deﬁnes the parameters of the convolutional operator, and the θr deﬁnes a set of
weights for relation r. The model can be trained using a margin objective,
ˆr = argmax
Ψ(r, i, j, X)
ℓ =( + ψ(ˆr, i, j, X) − ψ(r, i, j, X))+.
Recurrent neural networks (§ .) have also been applied to relation extraction, us-
ing a network such as a bidirectional LSTM to encode the words or dependency path
between the two arguments. Xu et al. () segment each dependency path into left and
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
right subpaths: the path George Bush ←
NSUBJwants →
XCOMPtravel →
OBLFrance is segmented into the
subpaths, George Bush ←
NSUBJwants and wants →
XCOMPtravel →
OBLFrance. In each path, a recurrent
neural network is run from the argument to the root word (in this case, wants). The ﬁ-
nal representation by max pooling (§ .) across all the recurrent states along each path.
This process can be applied across separate “channels”, in which the inputs consist of em-
beddings for the words, parts-of-speech, dependency relations, and WordNet hypernyms
(e.g., France-nation; see § .). To deﬁne the model formally, let s(m) deﬁne the successor
of word m in either the left or right subpath (in a dependency path, each word can have
a successor in at most one subpath). Let x(c)
m indicate the embedding of word (or relation)
m in channel c, and let ←−
h (c)
m and −→
h (c)
m indicate the associated recurrent states in the left
and right subtrees respectively. Then the complete model is speciﬁed as follows,
h(c)
s(m) =RNN(x(c)
s(m), h(c)
m )
z(c) =MaxPool
h (c)
i , ←−
h (c)
s(i), . . . , ←−
h (c)
root, −→
h (c)
j , −→
h (c)
s(j), . . . , −→
h (c)
root

Ψ(r, i, j) =θ
z(word); z(POS); z(dependency); z(hypernym)i
Note that z is computed by applying max-pooling to the matrix of horizontally concate-
nated vectors h, while Ψ is computed from the vector of vertically concatenated vectors
z.
Xu et al. () pass the score Ψ through a softmax layer to obtain a probability
p(r | i, j, w), and train the model by regularized cross-entropy. Miwa and Bansal ()
show that a related model can solve the more challenging “end-to-end” relation extrac-
tion task, in which the model must simultaneously detect entities and then extract their
relations.
Knowledge base population
In many applications, what matters is not what fraction of sentences are analyzed cor-
rectly, but how much accurate knowledge can be extracted. Knowledge base population
(KBP) refers to the task of ﬁlling in Wikipedia-style infoboxes, as shown in Figure .a.
Knowledge base population can be decomposed into two subtasks: entity linking (de-
scribed in § .), and slot ﬁlling (Ji and Grishman, ). Slot ﬁlling has two key dif-
ferences from the formulation of relation extraction presented above: the relations hold
between entities rather than spans of text, and the performance is evaluated at the type
level (on entity pairs), rather than on the token level (on individual sentences).
From a practical standpoint, there are three other important differences between slot
ﬁlling and per-sentence relation extraction.
KBP tasks are often formulated from the perspective of identifying attributes of a
few “query” entities. As a result, these systems often start with an information
Jacob Eisenstein. Draft of November , .

.. RELATIONS
retrieval phase, in which relevant passages of text are obtained by search.
For many entity pairs, there will be multiple passages of text that provide evidence.
Slot ﬁlling systems must aggregate this evidence to predict a single relation type (or
set of relations).
Labeled data is usually available in the form of pairs of related entities, rather than
annotated passages of text. Training from such type-level annotations is a challenge:
two entities may be linked by several relations, or they may appear together in a
passage of text that nonetheless does not describe their relation to each other.
Information retrieval is beyond the scope of this text (see Manning et al., ). The re-
mainder of this section describes approaches to information fusion and learning from
type-level annotations.
Information fusion
In knowledge base population, there will often be multiple pieces of evidence for (and
sometimes against) a single relation. For example, a search for the entity MAYNARD JACK-
SON, JR. may return several passages that reference the entity ATLANTA:
a. Elected mayor of Atlanta in , Maynard Jackson was the ﬁrst African
American to serve as mayor of a major southern city.
b. Atlanta’s airport will be renamed to honor Maynard Jackson, the city’s ﬁrst
Black mayor.
c. Born in Dallas, Texas in , Maynard Holbrook Jackson, Jr. moved to
Atlanta when he was .
d. Maynard Jackson has gone from one of the worst high schools in Atlanta to
one of the best.
The ﬁrst and second examples provide evidence for the relation MAYOR holding between
the entities ATLANTA and MAYNARD JACKSON, JR.. The third example provides evidence
for a different relation between these same entities, LIVED-IN. The fourth example poses
an entity linking problem, referring to MAYNARD JACKSON HIGH SCHOOL. Knowledge
base population requires aggregating this sort of textual evidence, and predicting the re-
lations that are most likely to hold.
One approach is to run a single-document relation extraction system (using the tech-
niques described in § ..), and then aggregate the results (Li et al., ). Relations
First
three
examples
from:
http://www.georgiaencyclopedia.org/articles/
government-politics/maynard-jackson--;
JET
magazine,
November
www.todayingeorgiahistory.org/content/maynard-jackson-elected
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
that are detected with high conﬁdence in multiple documents are more likely to be valid,
motivating the heuristic,
ψ(r, e, e) =
i=
(p(r(e, e) | w(i)))α,
where p(r(e, e) | w(i)) is the probability of relation r between entities e and e condi-
tioned on the text w(i), and α ≫  is a tunable hyperparameter. Using this heuristic, it is
possible to rank all candidate relations, and trace out a precision-recall curve as more re-
lations are extracted. Alternatively, features can be aggregated across multiple passages
of text, feeding a single type-level relation extraction system (Wolfe et al., ).
Precision can be improved by introducing constraints across multiple relations. For
example, if we are certain of the relation PARENT(e, e), then it cannot also be the case
that PARENT(e, e). Integer linear programming makes it possible to incorporate such
constraints into a global optimization (Li et al., ). Other pairs of relations have posi-
tive correlations, such MAYOR(e, e) and LIVED-IN(e, e). Compatibility across relation
types can be incorporated into probabilistic graphical models (e.g., Riedel et al., ).
Distant supervision
Relation extraction is “annotation hungry,” because each relation requires its own la-
beled data. Rather than relying on annotations of individual documents, it would be
preferable to use existing knowledge resources — such as the many facts that are al-
ready captured in knowledge bases like DBPedia. However such annotations raise the
inverse of the information fusion problem considered above: the existence of the relation
MAYOR(MAYNARD JACKSON JR., ATLANTA) provides only distant supervision for the
example texts in which this entity pair is mentioned.
One approach is to treat the entity pair as the instance, rather than the text itself (Mintz
et al., ). Features are then aggregated across all sentences in which both entities are
mentioned, and labels correspond to the relation (if any) between the entities in a knowl-
edge base, such as FreeBase. Negative instances are constructed from entity pairs that are
not related in the knowledge base. In some cases, two entities are related, but the knowl-
edge base is missing the relation; however, because the number of possible entity pairs is
huge, these missing relations are presumed to be relatively rare. This approach is shown
in Figure ..
In multiple instance learning, labels are assigned to sets of instances, of which only
an unknown subset are actually relevant (Dietterich et al., ; Maron and Lozano-P´erez,
). This formalizes the framework of distant supervision: the relation REL(A, B) acts
The precision-recall curve is similar to the ROC curve shown in Figure ., but it includes the precision
TP
FP+TN.
TP+FP rather than the false positive rate
FP
Jacob Eisenstein. Draft of November , .

.. RELATIONS
Label : MAYOR(ATLANTA, MAYNARD JACKSON)
– Elected mayor of Atlanta in , Maynard Jackson ...
– Atlanta’s airport will be renamed to honor Maynard Jackson, the city’s ﬁrst Black
mayor
– Born in Dallas, Texas in , Maynard Holbrook Jackson, Jr. moved to Atlanta
when he was .
Label : MAYOR(NEW YORK, FIORELLO LA GUARDIA)
– Fiorello La Guardia was Mayor of New York for three terms ...
– Fiorello La Guardia, then serving on the New York City Board of Aldermen...
Label : BORN-IN(DALLAS, MAYNARD JACKSON)
– Born in Dallas, Texas in , Maynard Holbrook Jackson, Jr. moved to Atlanta
when he was .
– Maynard Jackson was raised in Dallas ...
Label : NIL(NEW YORK, MAYNARD JACKSON)
– Jackson married Valerie Richardson, whom he had met in New York...
– Jackson was a member of the Georgia and New York bars ...
Figure .: Four training instances for relation classiﬁcation using distant supervi-
sion Mintz et al. (). The ﬁrst two instances are positive for the MAYOR relation, and
the third instance is positive for the BORN-IN relation. The fourth instance is a negative ex-
ample, constructed from a pair of entities (NEW YORK, MAYNARD JACKSON) that do not
appear in any Freebase relation. Each instance’s features are computed by aggregating
across all sentences in which the two entities are mentioned.
as a label for the entire set of sentences mentioning entities A and B, even when only a
subset of these sentences actually describes the relation. One approach to multi-instance
learning is to introduce a binary latent variable for each sentence, indicating whether the
sentence expresses the labeled relation (Riedel et al., ). A variety of inference tech-
niques have been employed for this probabilistic model of relation extraction: Surdeanu
et al. () use expectation maximization, Riedel et al. () use sampling, and Hoff-
mann et al. () use a custom graph-based algorithm. Expectation maximization and
sampling are surveyed in chapter , and are covered in more detail by Murphy ();
graph-based methods are surveyed by Mihalcea and Radev ().
Open information extraction
In classical relation extraction, the set of relations is deﬁned in advance, using a schema.
The relation for any pair of entities can then be predicted using multi-class classiﬁcation.
In open information extraction (OpenIE), a relation can be any triple of text. The example
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
Task
Relation ontology
Supervision
PropBank semantic role labeling
VerbNet
sentence
FrameNet semantic role labeling
FrameNet
sentence
Relation extraction
ACE, TAC, SemEval, etc
sentence
Slot ﬁlling
ACE, TAC, SemEval, etc
relation
Open Information Extraction
open
seed relations or patterns
Table .: Various relation extraction tasks and their properties. VerbNet and FrameNet
are described in chapter . ACE (Linguistic Data Consortium, ), TAC (McNamee
and Dang, ), and SemEval (Hendrickx et al., ) refer to shared tasks, each of which
involves an ontology of relation types.
sentence (.a) instantiates several “relations” of this sort, e.g.,
(mayor of, Maynard Jackson, Atlanta),
(elected, Maynard Jackson, mayor of Atlanta),
(elected in, Maynard Jackson, ).
Extracting such tuples can be viewed as a lightweight version of semantic role labeling
(chapter ), with only two argument types: ﬁrst slot and second slot. The task is gen-
erally evaluated on the relation level, rather than on the level of sentences: precision is
measured by the number of extracted relations that are accurate, and recall is measured
by the number of true relations that were successfully extracted. OpenIE systems are
trained from distant supervision or bootstrapping, rather than from labeled sentences.
An early example is the TEXTRUNNER system (Banko et al., ), which identiﬁes
relations with a set of handcrafted syntactic rules. The examples that are acquired from
the handcrafted rules are then used to train a classiﬁcation model that uses part-of-speech
patterns as features. Finally, the relations that are extracted by the classiﬁer are aggre-
gated, removing redundant relations and computing the number of times that each rela-
tion is mentioned in the corpus. TEXTRUNNER was the ﬁrst in a series of systems that
performed increasingly accurate open relation extraction by incorporating more precise
linguistic features (Etzioni et al., ), distant supervision from Wikipedia infoboxes (Wu
and Weld, ), and better learning algorithms (Zhu et al., ).
Events
Relations link pairs of entities, but many real-world situations involve more than two enti-
ties. Consider again the example sentence (.a), which describes the event of an election,
Jacob Eisenstein. Draft of November , .

.. EVENTS
with four properties: the ofﬁce (MAYOR), the district (ATLANTA), the date (), and the
person elected (MAYNARD JACKSON, JR.). In event detection, a schema is provided for
each event type (e.g., an election, a terrorist attack, or a chemical reaction), indicating all
the possible properties of the event. The system is then required to ﬁll in as many of these
properties as possible (Doddington et al., ).
Event detection systems generally involve a retrieval component (ﬁnding relevant
documents and passages of text) and an extraction component (determining the proper-
ties of the event based on the retrieved texts). Early approaches focused on ﬁnite-state pat-
terns for identify event properties (Hobbs et al., ); such patterns can be automatically
induced by searching for patterns that are especially likely to appear in documents that
match the event query (Riloff, ). Contemporary approaches employ techniques that
are similar to FrameNet semantic role labeling (§ .), such as structured prediction over
local and global features (Li et al., ) and bidirectional recurrent neural networks (Feng
et al., ). These methods detect whether an event is described in a sentence, and if so,
what are its properties.
Event coreference
Because multiple sentences may describe unique properties of a sin-
gle event, event coreference is required to link event mentions across a single passage
of text, or between passages (Humphreys et al., ). Bejan and Harabagiu () de-
ﬁne event coreference as the task of identifying event mentions that share the same event
participants (i.e., the slot-ﬁlling entities) and the same event properties (e.g., the time and
location), within or across documents. Event coreference resolution can be performed us-
ing supervised learning techniques in a similar way to entity coreference, as described
in chapter : move left-to-right through the document, and use a classiﬁer to decide
whether to link each event reference to an existing cluster of coreferent events, or to cre-
ate a new cluster (Ahn, ). Each clustering decision is based on the compatibility of
features describing the participants and properties of the event. Due to the difﬁculty of
annotating large amounts of data for entity coreference, unsupervised approaches are es-
pecially desirable (Chen and Ji, ; Bejan and Harabagiu, ).
Relations between events
Just as entities are related to other entities, events may be
related to other events: for example, the event of winning an election both precedes and
causes the event of serving as mayor; moving to Atlanta precedes and enables the event of
becoming mayor of Atlanta; moving from Dallas to Atlanta prevents the event of later be-
coming mayor of Dallas. As these examples show, events may be related both temporally
and causally. The TimeML annotation scheme speciﬁes a set of six temporal relations
between events (Pustejovsky et al., ), derived in part from interval algebra (Allen,
). The TimeBank corpus provides TimeML annotations for  documents (Puste-
jovsky et al., ). Methods for detecting these temporal relations combine supervised
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
Positive (+)
Negative (-)
Underspeciﬁed (u)
Certain (CT)
Fact: CT+
Counterfact: CT-
Certain, but unknown: CTU
Probable (PR)
Probable: PR+
Not probable: PR-
(NA)
Possible (PS)
Possible: PS+
Not possible: PS-
(NA)
Underspeciﬁed (U)
(NA)
(NA)
Unknown or uncommitted: UU
Table .: Table of factuality values from the FactBank corpus (Saur´ı and Pustejovsky,
). The entry (NA) indicates that this combination is not annotated.
machine learning with temporal constraints, such as transitivity (e.g. Mani et al., ;
Chambers and Jurafsky, ).
More recent annotation schemes and datasets combine temporal and causal relations (Mirza
et al., ; Dunietz et al., ): for example, the CaTeRS dataset includes annotations of
ﬁve-sentence short stories (Mostafazadeh et al., ). Abstracting still further, pro-
cesses are networks of causal relations between multiple events. A small dataset of bi-
ological processes is annotated in the ProcessBank dataset (Berant et al., ), with the
goal of supporting automatic question answering on scientiﬁc textbooks.
Hedges, denials, and hypotheticals
The methods described thus far apply to propositions about the way things are in the
real world. But natural language can also describe events and relations that are likely or
unlikely, possible or impossible, desired or feared. The following examples hint at the
scope of the problem (Prabhakaran et al., ):
a. GM will lay off workers.
b. A spokesman for GM said GM will lay off workers.
c. GM may lay off workers.
d. The politician claimed that GM will lay off workers.
e. Some wish GM would lay off workers.
f. Will GM lay off workers?
g. Many wonder whether GM will lay off workers.
Accurate information extraction requires handling these extra-propositional aspects
of meaning, which are sometimes summarized under the terms modality and negation.
The classiﬁcation of negation as extra-propositional is controversial: Packard et al. () argue that
negation is a “core part of compositionally constructed logical-form representations.” Negation is an element
of the semantic parsing tasks discussed in chapter  and chapter  — for example, negation markers are
Jacob Eisenstein. Draft of November , .

.. HEDGES, DENIALS, AND HYPOTHETICALS
Modality refers to expressions of the speaker’s attitude towards her own statements, in-
cluding “degree of certainty, reliability, subjectivity, sources of information, and perspec-
tive” (Morante and Sporleder, ). Various systematizations of modality have been
proposed (e.g., Palmer, ), including categories such as future, interrogative, imper-
ative, conditional, and subjective. Information extraction is particularly concerned with
negation and certainty. For example, Saur´ı and Pustejovsky () link negation with
a modal calculus of certainty, likelihood, and possibility, creating the two-dimensional
schema shown in Table .. This is the basis for the FactBank corpus, with annotations
of the factuality of all sentences in  documents of news text.
A related concept is hedging, in which speakers limit their commitment to a proposi-
tion (Lakoff, ):
a. These results suggest that expression of c-jun, jun B and jun D genes might be
involved in terminal granulocyte differentiation... (Morante and Daelemans,
b. A whale is technically a mammal (Lakoff, )
In the ﬁrst example, the hedges suggest and might communicate uncertainty; in the second
example, there is no uncertainty, but the hedge technically indicates that the evidence for
the proposition will not fully meet the reader’s expectations. Hedging has been studied
extensively in scientiﬁc texts (Medlock and Briscoe, ; Morante and Daelemans, ),
where the goal of large-scale extraction of scientiﬁc facts is obstructed by hedges and spec-
ulation. Still another related aspect of modality is evidentiality, in which speakers mark
the source of their information. In many languages, it is obligatory to mark evidentiality
through afﬁxes or particles (Aikhenvald, ); while evidentiality is not grammaticalized
in English, authors are expected to express this information in contexts such as journal-
ism (Kovach and Rosenstiel, ) and Wikipedia.
Methods for handling negation and modality generally include two phases:
. detecting negated or uncertain events;
. identifying scope of the negation or modal operator.
A considerable body of work on negation has employed rule-based techniques such
as regular expressions (Chapman et al., ) to detect negated events. Such techniques
treated as adjuncts in PropBank semantic role labeling. However, many of the relation extraction methods
mentioned in this chapter do not handle negation directly. A further consideration is that negation inter-
acts closely with aspects of modality that are generally not considered in propositional semantics, such as
certainty and subjectivity.
https://en.wikipedia.org/wiki/Wikipedia:Veriﬁability
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
match lexical cues (e.g., Norwood was not elected Mayor), while avoiding “double nega-
tives” (e.g., surely all this is not without meaning). Supervised techniques involve classi-
ﬁers over lexical and syntactic features (Uzuner et al., ) and sequence labeling (Prab-
hakaran et al., ).
The scope refers to the elements of the text whose propositional meaning is negated or
modulated (Huddleston and Pullum, ), as elucidated in the following example from
Morante and Sporleder ():
[ After his habit he said ] nothing, and after mine I asked no questions.
After his habit he said nothing, and [ after mine I asked ] no [ questions ].
In this sentence, there are two negation cues (nothing and no). Each negates an event, in-
dicated by the underlined verbs said and asked, and each occurs within a scope: after his
habit he said and after mine I asked
questions. Scope identiﬁcation is typically formal-
ized as sequence labeling problems, with each word token labeled as beginning, inside,
or outside of a cue, focus, or scope span (see § .). Conventional sequence labeling ap-
proaches can then be applied, using surface features as well as syntax (Velldal et al., )
and semantic analysis (Packard et al., ). Labeled datasets include the BioScope corpus
of biomedical texts (Vincze et al., ) and a shared task dataset of detective stories by
Arthur Conan Doyle (Morante and Blanco, ).
Question answering and machine reading
The victory of the Watson question-answering system against three top human players on
the game show Jeopardy! was a landmark moment for natural language processing (Fer-
rucci et al., ). Game show questions are usually answered by factoids: entity names
and short phrases. The task of factoid question answering is therefore closely related to
information extraction, with the additional problem of accurately parsing the question.
Formal semantics
Semantic parsing is an effective method for question-answering in restricted domains
such as questions about geography and airline reservations (Zettlemoyer and Collins,
), and has also been applied in “open-domain” settings such as question answering
on Freebase (Berant et al., ) and biomedical research abstracts (Poon and Domingos,
). One approach is to convert the question into a lambda calculus expression that
returns a boolean value: for example, the question who is the mayor of the capital of Georgia?
The broader landscape of question answering includes “why” questions (Why did Ahab continue to pursue
the white whale?), “how questions” (How did Queequeg die?), and requests for summaries (What was Ishmael’s
attitude towards organized religion?). For more, see Hirschman and Gaizauskas ().
Jacob Eisenstein. Draft of November , .

.. QUESTION ANSWERING AND MACHINE READING
would be converted to,
λx.∃y CAPITAL(GEORGIA, y) ∧ MAYOR(y, x).
This lambda expression can then be used to query an existing knowledge base, returning
“true” for all entities that satisfy it.
Machine reading
Recent work has focused on answering questions about speciﬁc textual passages, similar
to the reading comprehension examinations for young students (Hirschman et al., ).
This task has come to be known as machine reading.
Datasets
The machine reading problem can be formulated in a number of different ways. The most
important distinction is what form the answer should take.
Multiple-choice question answering, as in the MCTest dataset of stories (Richard-
son et al., ) and the New York Regents Science Exams (Clark, ). In MCTest,
the answer is deducible from the text alone, while in the science exams, the system
must make inferences using an existing model of the underlying scientiﬁc phenom-
ena. Here is an example from MCTest:
James the turtle was always getting into trouble. Sometimes he’d reach into
the freezer and empty out all the food ...
Q: What is the name of the trouble making turtle?
(a) Fries
(b) Pudding
(c) James
(d) Jane
Cloze-style “ﬁll in the blank” questions, as in the CNN/Daily Mail comprehension
task (Hermann et al., ), the Children’s Book Test (Hill et al., ), and the Who-
did-What dataset (Onishi et al., ). In these tasks, the system must guess which
word or entity completes a sentence, based on reading a passage of text. Here is an
example from Who-did-What:
Q: Tottenham manager Juande Ramos has hinted he will allow
to leave
if the Bulgaria striker makes it clear he is unhappy. (Onishi et al., )
The query sentence may be selected either from the story itself, or from an external
summary. In either case, datasets can be created automatically by processing large
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
quantities existing documents. An additional constraint is that that missing element
from the cloze must appear in the main passage of text: for example, in Who-did-
What, the candidates include all entities mentioned in the main passage. In the
CNN/Daily Mail dataset, each entity name is replaced by a unique identiﬁer, e.g.,
ENTITY. This ensures that correct answers can only be obtained by accurately
reading the text, and not from external knowledge about the entities.
Extractive question answering, in which the answer is drawn from the original text.
In WikiQA, answers are sentences (Yang et al., ). In the Stanford Question An-
swering Dataset (SQuAD), answers are words or short phrases (Rajpurkar et al.,
In metereology, precipitation is any product of the condensation of atmo-
spheric water vapor that falls under gravity.
Q: What causes precipitation to fall?
A: gravity
In both WikiQA and SQuAD, the original texts are Wikipedia articles, and the ques-
tions are generated by crowdworkers.
Methods
A baseline method is to search the text for sentences or short passages that overlap with
both the query and the candidate answer (Richardson et al., ). In example (.), this
baseline would select the correct answer, since James appears in a sentence that includes
the query terms trouble and turtle.
This baseline can be implemented as a neural architecture, using an attention mech-
anism (see § ..), which scores the similarity of the query to each part of the source
text (Chen et al., ). The ﬁrst step is to encode the passage w(p) and the query w(q),
using two bidirectional LSTMs (§ .).
h(q) =BiLSTM(w(q); Θ(q))
h(p) =BiLSTM(w(p); Θ(p)).
The query is represented by vertically concatenating the ﬁnal states of the left-to-right
and right-to-left passes:
u =[
h(q)Mq;
h(q)].
Jacob Eisenstein. Draft of November , .

.. QUESTION ANSWERING AND MACHINE READING
The attention vector is computed as a softmax over a vector of bilinear products, and
the expected representation is computed by summing over attention values,
˜αm =(u(q))⊤Wah(p)
α =SoftMax( ˜α)
o =
m=
αmh(p)
m .
Each candidate answer c is represented by a vector xc. Assuming the candidate answers
are spans from the original text, these vectors can be set equal to the corresponding ele-
ment in h(p). The score for each candidate answer a is computed by the inner product,
ˆc = argmax
o  xc.
This architecture can be trained end-to-end from a loss based on the log-likelihood of the
correct answer. A number of related architectures have been proposed (e.g., Hermann
et al., ; Kadlec et al., ; Dhingra et al., ; Cui et al., ), and these methods are
surveyed by Wang et al. ().
Additional resources
The ﬁeld of information extraction is surveyed in course notes by Grishman (), and
more recently in a short survey paper (Grishman, ). Shen et al. () survey the task
of entity linking, and Ji and Grishman () survey work on knowledge base popula-
tion. This chapter’s discussion of non-propositional meaning was strongly inﬂuenced by
Morante and Sporleder (), who introduced a special issue of the journal Computational
Linguistics dedicated to recent work on modality and negation.
Exercises
. Go to the Wikipedia page for your favorite movie. For each record in the info box
(e.g., Screenplay by: Stanley Kubrick), report whether there is a sentence in the ar-
ticle containing both the ﬁeld and value (e.g., The screenplay was written by Stanley
Kubrick). If not, is there is a sentence in the article containing just the value? (For
records with more than one value, just use the ﬁrst value.)
. Building on your answer in the previous question, report the dependency path be-
tween the head words of the ﬁeld and value for at least three records.
. Consider the following heuristic for entity linking:
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
Among all entities that have the same type as the mention (e.g., LOC, PER),
choose the one whose name has the lowest edit distance from the mention.
If more than one entity has the right type and the lowest edit distance from the
mention, choose the most popular one.
If no candidate entity has the right type, choose NIL.
Now suppose you have the following feature function:
f(y, x) = [edit-dist(name(y), x), same-type(y, x), popularity(y), δ (y = NIL)]
Design a set of ranking weights θ that match the heuristic. You may assume that
edit distance and popularity are always in the range [, ], and that the NIL entity
has values of zero for all features except δ (y = NIL).
. Now consider another heuristic:
Among all candidate entities that have edit distance zero from the mention,
and are the right type, choose the most popular one.
If no entity has edit distance zero from the mention, choose the one with the
right type that is most popular, regardless of edit distance.
If no entity has the right type, choose NIL.
Using the same features and assumptions from the previous problem, prove that
there is no set of weights that could implement this heuristic. Then show that the
heuristic can be implemented by adding a single feature. Your new feature should
consider only the edit distance.
. Download the Reuters corpus in NLTK, and iterate over the tokens in the corpus:
import nltk
nltk.corpus.download(’reuters’)
from nltk.corpus import reuters
for word in reuters.words():
#your code here
a) Apply the pattern
, such as
to obtain candidates for the IS-A relation,
e.g. IS-A(ROMANIA, COUNTRY). What are three pairs that this method identi-
ﬁes correctly? What are three different pairs that it gets wrong?
b) Design a pattern for the PRESIDENT relation, e.g. PRESIDENT(PHILIPPINES, CORAZON AQUINO
In this case, you may want to augment your pattern matcher with the ability
to match multiple token wildcards, perhaps using case information to detect
proper names. Again, list three correct
Jacob Eisenstein. Draft of November , .

.. QUESTION ANSWERING AND MACHINE READING
c) Preprocess the Reuters data by running a named entity recognizer, replacing
tokens with named entity spans when applicable — e.g., your pattern can now
match on the United States if the NER system tags it. Apply your PRESIDENT
matcher to this preprocessed data. Does the accuracy improve? Compare
randomly-selected pairs from this pattern and the one you designed in the pre-
vious part.
. Using the same NLTK Reuters corpus, apply distant supervision to build a training
set for detecting the relation between nations and their capitals. Start with the fol-
lowing known relations: (JAPAN, TOKYO), (FRANCE, PARIS), (ITALY, ROME). How
many positive and negative examples are you able to extract?
. Represent the dependency path x(i) as a sequence of words and dependency arcs
of length Mi, ignoring the endpoints of the path. In example  of Table ., the
dependency path is,
x() = ( ←
NSUBJ, traveled, →
OBL)
If x(i)
m is a word, then let pos(x(i)
m ) be its part-of-speech, using the tagset deﬁned in
chapter .
We can deﬁne the following kernel function over pairs of dependency paths (Bunescu
and Mooney, ):
κ(x(i), x(j)) =
Mi ̸= Mj
QMi
m= c(x(i)
m , x(j)
m ),
Mi = Mj
c(x(i)
m , x(j)
m ) =

x(i)
m = x(j)
x(i)
m ̸= x(j)
m and pos(x(i)
m ) = pos(x(j)
m )
otherwise.

Using this kernel function, compute the kernel similarities of example  from Ta-
ble . with the other ﬁve examples.
. Continuing from the previous problem, suppose that the instances have the follow-
ing labels:
y = , y = −, y = −, y = , y =
Equation . deﬁnes a kernel-based classiﬁcation in terms of parameters α and
b. Using the above labels for y, . . . , y, identify the values of α and b under which
ˆy = . Remember the constraint that αi ≥  for all i.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . INFORMATION EXTRACTION
. Consider the neural QA system described in § .., but restrict the set of candidate
answers to words in the passage, and set each candidate answer embedding x equal
to the vector h(p)
m , representing token m in the passage, so that ˆm = argmaxm oh(p)
m .
Suppose the system selects answer ˆm, but the correct answer is m∗. Consider the
gradient of the margin loss with respect to the attention:
a) Prove that
∂ℓ
∂αm∗.
∂α ˆ
m ≥
∂ℓ
b) Assuming that ||h ˆm|| = ||hm∗||, prove that
∂ℓ
∂α ˆ
m ≥  and
∂ℓ
∂αm∗ ≤ . Explain in
words what this means about how the attention is expected to change after a
gradient-based update.
Jacob Eisenstein. Draft of November , .

Chapter
Machine translation
Machine translation (MT) is one of the “holy grail” problems in artiﬁcial intelligence,
with the potential to transform society by facilitating communication between people
anywhere in the world. As a result, MT has received signiﬁcant attention and funding
since the early s. However, it has proved remarkably challenging, and while there
has been substantial progress towards usable MT systems — especially for high-resource
language pairs like English-French — we are still far from translation systems that match
the nuance and depth of human translations.
Machine translation as a task
Machine translation can be formulated as an optimization problem:
ˆw(t) = argmax
w(t)
Ψ(w(s), w(t)),
where w(s) is a sentence in a source language, w(t) is a sentence in the target language,
and Ψ is a scoring function. As usual, this formalism requires two components: a decod-
ing algorithm for computing ˆw(t), and a learning algorithm for estimating the parameters
of the scoring function Ψ.
Decoding is difﬁcult for machine translation because of the huge space of possible
translations. We have faced large label spaces before: for example, in sequence labeling,
the set of possible label sequences is exponential in the length of the input. In these cases,
it was possible to search the space quickly by introducing locality assumptions: for ex-
ample, that each tag depends only on its predecessor, or that each production depends
only on its parent. In machine translation, no such locality assumptions seem possible:
human translators reword, reorder, and rearrange words; they replace single words with
multi-word phrases, and vice versa. This ﬂexibility means that in even relatively simple
CHAPTER . MACHINE TRANSLATION
interlingua
semantics
syntax
text
source
target
Figure .: The Vauquois Pyramid
translation models, decoding is NP-hard (Knight, ). Approaches for dealing with this
complexity are described in § ..
Estimating translation models is difﬁcult as well. Labeled translation data usually
comes in the form parallel sentences, e.g.,
w(s) =A Vinay le gusta las manzanas.
w(t) =Vinay likes apples.
A useful feature function would note the translation pairs (gusta, likes), (manzanas, apples),
and even (Vinay, Vinay). But this word-to-word alignment is not given in the data. One
solution is to treat this alignment as a latent variable; this is the approach taken by clas-
sical statistical machine translation (SMT) systems, described in § .. Another solution
is to model the relationship between w(t) and w(s) through a more complex and expres-
sive function; this is the approach taken by neural machine translation (NMT) systems,
described in § ..
The Vauquois Pyramid is a theory of how translation should be done. At the lowest
level, the translation system operates on individual words, but the horizontal distance
at this level is large, because languages express ideas differently. If we can move up the
triangle to syntactic structure, the distance for translation is reduced; we then need only
produce target-language text from the syntactic representation, which can be as simple
as reading off a tree. Further up the triangle lies semantics; translating between semantic
representations should be easier still, but mapping between semantics and surface text is a
difﬁcult, unsolved problem. At the top of the triangle is interlingua, a semantic represen-
tation that is so generic that it is identical across all human languages. Philosophers de-
bate whether such a thing as interlingua is really possible (e.g., Derrida, ). While the
ﬁrst-order logic representations discussed in chapter  might be thought to be language
independent, they are built on an inventory of predicates that are suspiciously similar to
English words (Nirenburg and Wilks, ). Nonetheless, the idea of linking translation
Jacob Eisenstein. Draft of November , .

.. MACHINE TRANSLATION AS A TASK
Adequate?
Fluent?
To Vinay it like Python
yes
no
Vinay debugs memory leaks
no
yes
Vinay likes Python
yes
yes
Table .: Adequacy and ﬂuency for translations of the Spanish sentence A Vinay le gusta
Python.
and semantic understanding may still be a promising path, if the resulting translations
better preserve the meaning of the original text.
Evaluating translations
There are two main criteria for a translation, summarized in Table ..
Adequacy: The translation w(t) should adequately reﬂect the linguistic content of
w(s). For example, if w(s) = A Vinay le gusta Python, the reference translation is
w(t) = Vinay likes Python. However, the gloss, or word-for-word translation w(t) =
To Vinay it like Python is also considered adequate because it contains all the relevant
content. The output w(t) = Vinay debugs memory leaks is not adequate.
Fluency: The translation w(t) should read like ﬂuent text in the target language. By
this criterion, the gloss w(t) = To Vinay it like Python will score poorly, and w(t) =
Vinay debugs memory leaks will be preferred.
Automated evaluations of machine translations typically merge both of these criteria,
by comparing the system translation with one or more reference translations, produced
by professional human translators. The most popular quantitative metric is BLEU (bilin-
gual evaluation understudy; Papineni et al., ), which is based on n-gram precision:
what fraction of n-grams in the system translation appear in the reference? Speciﬁcally,
for each n-gram length, the precision is deﬁned as,
pn = number of n-grams appearing in both reference and hypothesis translations
number of n-grams appearing in the hypothesis translation
The n-gram precisions for three hypothesis translations are shown in Figure ..
The BLEU score is then based on the average, exp
PN
n= log pn. Two modiﬁcations
of Equation . are necessary: () to avoid computing log , all precisions are smoothed
to ensure that they are positive; () each n-gram in the reference can be used at most
once, so that to to to to to to does not achieve p =  against the reference to be or not to
be. Furthermore, precision-based metrics are biased in favor of short translations, which
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
Translation
BP
BLEU
Reference
Vinay likes programming in Python
Sys
To Vinay it like to program Python
Sys
Vinay likes Python
Sys
Vinay likes programming in his pajamas
Figure .: A reference translation and three system outputs. For each output, pn indi-
cates the precision at each n-gram, and BP indicates the brevity penalty.
can achieve high scores by minimizing the denominator in [.]. To avoid this issue, a
brevity penalty is applied to translations that are shorter than the reference. This penalty
is indicated as “BP” in Figure ..
Automated metrics like BLEU have been validated by correlation with human judg-
ments of translation quality. Nonetheless, it is not difﬁcult to construct examples in which
the BLEU score is high, yet the translation is disﬂuent or carries a completely different
meaning from the original. To give just one example, consider the problem of translating
pronouns. Because pronouns refer to speciﬁc entities, a single incorrect pronoun can oblit-
erate the semantics of the original sentence. Existing state-of-the-art systems generally
do not attempt the reasoning necessary to correctly resolve pronominal anaphora (Hard-
meier, ). Despite the importance of pronouns for semantics, they have a marginal
impact on BLEU, which may help to explain why existing systems do not make a greater
effort to translate them correctly.
Fairness and bias
The problem of pronoun translation intersects with issues of fairness
and bias. In many languages, such as Turkish, the third person singular pronoun is gender
neutral. Today’s state-of-the-art systems produce the following Turkish-English transla-
tions (Caliskan et al., ):
He
bir
is a
doktor.
doctor.
She
bir
is a
hem¸sire.
nurse.
The same problem arises for other professions that have stereotypical genders, such as
engineers, soldiers, and teachers, and for other languages that have gender-neutral pro-
nouns. This bias was not directly programmed into the translation model; it arises from
statistical tendencies in existing datasets. This highlights a general problem with data-
driven approaches, which can perpetuate biases that negatively impact disadvantaged
Jacob Eisenstein. Draft of November , .

.. MACHINE TRANSLATION AS A TASK
groups. Worse, machine learning can amplify biases in data (Bolukbasi et al., ): if a
dataset has even a slight tendency towards men as doctors, the resulting translation model
may produce translations in which doctors are always he, and nurses are always she.
Other metrics
A range of other automated metrics have been proposed for machine
translation. One potential weakness of BLEU is that it only measures precision; METEOR
is a weighted F -MEASURE, which is a combination of recall and precision (see § ..).
Translation Error Rate (TER) computes the string edit distance (see § ..) between the
reference and the hypothesis (Snover et al., ). For language pairs like English and
Japanese, there are substantial differences in word order, and word order errors are not
sufﬁciently captured by n-gram based metrics. The RIBES metric applies rank correla-
tion to measure the similarity in word order between the system and reference transla-
tions (Isozaki et al., ).
Data
Data-driven approaches to machine translation rely primarily on parallel corpora, which
are translations at the sentence level. Early work focused on government records, in which
ﬁne-grained ofﬁcial translations are often required. For example, the IBM translation sys-
tems were based on the proceedings of the Canadian Parliament, called Hansards, which
are recorded in English and French (Brown et al., ). The growth of the European
Union led to the development of the EuroParl corpus, which spans  European lan-
guages (Koehn, ). While these datasets helped to launch the ﬁeld of machine transla-
tion, they are restricted to narrow domains and a formal speaking style, limiting their ap-
plicability to other types of text. As more resources are committed to machine translation,
new translation datasets have been commissioned. This has broadened the scope of avail-
able data to news, movie subtitles, social media (Ling et al., ), dialogues (Fordyce,
), TED talks (Paul et al., ), and scientiﬁc research articles (Nakazawa et al., ).
Despite this growing set of resources, the main bottleneck in machine translation data
is the need for parallel corpora that are aligned at the sentence level. Many languages have
sizable parallel corpora with some high-resource language, but not with each other. The
high-resource language can then be used as a “pivot” or “bridge” (Boitet, ; Utiyama
and Isahara, ): for example, De Gispert and Marino () use Spanish as a bridge for
translation between Catalan and English. For most of the  languages spoken today,
the only source of translation data remains the Judeo-Christian Bible (Resnik et al., ).
While relatively small, at less than a million tokens, the Bible has been translated into
more than  languages, far outpacing any other corpus. Some research has explored
https://catalog.ldc.upenn.edu/LDCT,
http://www.statmt.org/wmt/
translation-task.html
http://opus.nlpl.eu/
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
the possibility of automatically identifying parallel sentence pairs from unaligned parallel
texts, such as web pages and Wikipedia articles (Kilgarriff and Grefenstette, ; Resnik
and Smith, ; Adafre and De Rijke, ). Another approach is to create large parallel
corpora through crowdsourcing (Zaidan and Callison-Burch, ).
Statistical machine translation
The previous section introduced adequacy and ﬂuency as the two main criteria for ma-
chine translation. A natural modeling approach is to represent them with separate scores,
Ψ(w(s), w(t)) = ΨA(w(s), w(t)) + ΨF (w(t)).
The ﬂuency score ΨF need not even consider the source sentence; it only judges w(t) on
whether it is ﬂuent in the target language. This decomposition is advantageous because
it makes it possible to estimate the two scoring functions on separate data. While the
adequacy model must be estimated from aligned sentences — which are relatively expen-
sive and rare — the ﬂuency model can be estimated from monolingual text in the target
language. Large monolingual corpora are now available in many languages, thanks to
resources such as Wikipedia.
An elegant justiﬁcation of the decomposition in Equation . is provided by the noisy
channel model, in which each scoring function is a log probability:
ΨA(w(s), w(t)) ≜ log pS|T (w(s) | w(t))
ΨF (w(t)) ≜ log pT (w(t))
Ψ(w(s), w(t)) = log pS|T (w(s) | w(t)) + log pT (w(t)) = log pS,T (w(s), w(t)).
By setting the scoring functions equal to the logarithms of the prior and likelihood, their
sum is equal to log pS,T , which is the logarithm of the joint probability of the source and
target. The sentence ˆw(t) that maximizes this joint probability is also the maximizer of the
conditional probability pT|S, making it the most likely target language sentence, condi-
tioned on the source.
The noisy channel model can be justiﬁed by a generative story. The target text is orig-
inally generated from a probability model pT . It is then encoded in a “noisy channel”
pS|T , which converts it to a string in the source language. In decoding, we apply Bayes’
rule to recover the string w(t) that is maximally likely under the conditional probability
pT|S. Under this interpretation, the target probability pT is just a language model, and
can be estimated using any of the techniques from chapter . The only remaining learning
problem is to estimate the translation model pS|T .
Jacob Eisenstein. Draft of November , .

.. STATISTICAL MACHINE TRANSLATION
le
gusta
Vinay
python
Vinay
likes
python
Figure .: An example word-to-word alignment
Statistical translation modeling
The simplest decomposition of the translation model is word-to-word: each word in the
source should be aligned to a word in the translation. This approach presupposes an
alignment A(w(s), w(t)), which contains a list of pairs of source and target tokens. For
example, given w(s) = A Vinay le gusta Python and w(t) = Vinay likes Python, one possible
word-to-word alignment is,
A(w(s), w(t)) = {(A, ∅), (Vinay, Vinay), (le, likes), (gusta, likes), (Python,Python)}.
This alignment is shown in Figure .. Another, less promising, alignment is:
A(w(s), w(t)) = {(A, Vinay), (Vinay, likes), (le, Python), (gusta, ∅), (Python, ∅)}.
Each alignment contains exactly one tuple for each word in the source, which serves to
explain how the source word could be translated from the target, as required by the trans-
lation probability pS|T . If no appropriate word in the target can be identiﬁed for a source
word, it is aligned to ∅ — as is the case for the Spanish function word a in the example,
which glosses to the English word to. Words in the target can align with multiple words
in the source, so that the target word likes can align to both le and gusta in the source.
The joint probability of the alignment and the translation can be deﬁned conveniently
as,
p(w(s), A | w(t)) =
m=
p(w(s)
m , am | w(t)
am, m, M(s), M(t))
M(s)
m=
p(am | m, M(s), M(t)) × p(w(s)
m | w(t)
am).
M(s)
This probability model makes two key assumptions:
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
The alignment probability factors across tokens,
p(A | w(s), w(t)) =
m=
p(am | m, M(s), M(t)).
M(s)
This means that each alignment decision is independent of the others, and depends
only on the index m, and the sentence lengths M(s) and M(t).
The translation probability also factors across tokens,
p(w(s) | w(t), A) =
m=
p(w(s)
m | w(t)
am),
M(s)
so that each word in w(s) depends only on its aligned word in w(t). This means that
translation is word-to-word, ignoring context. The hope is that the target language
model p(w(t)) will correct any disﬂuencies that arise from word-to-word translation.
To translate with such a model, we could sum or max over all possible alignments,
p(w(s), w(t), A)
p(w(s), w(t)) =
p(A) × p(w(s) | w(t), A)
=p(w(t))
≥p(w(t)) max
A p(A) × p(w(s) | w(t), A).
The term p(A) deﬁnes the prior probability over alignments. A series of alignment
models with increasingly relaxed independence assumptions was developed by researchers
at IBM in the s and s, known as IBM Models - (Och and Ney, ). IBM
Model  makes the strongest independence assumption:
M(t) .
p(am | m, M(s), M(t)) =
In this model, every alignment is equally likely. This is almost surely wrong, but it re-
sults in a convex learning objective, yielding a good initialization for the more complex
alignment models (Brown et al., ; Koehn, ).
Estimation
Let us deﬁne the parameter θu→v as the probability of translating target word u to source
word v. If word-to-word alignments were annotated, these probabilities could be com-
puted from relative frequencies,
ˆθu→v = count(u, v)
count(u) ,
Jacob Eisenstein. Draft of November , .

.. STATISTICAL MACHINE TRANSLATION
where count(u, v) is the count of instances in which word v was aligned to word u in
the training set, and count(u) is the total count of the target word u. The smoothing
techniques mentioned in chapter  can help to reduce the variance of these probability
estimates.
Conversely, if we had an accurate translation model, we could estimate the likelihood
of each alignment decision,
qm(am | w(s), w(t)) ∝ p(am | m, M(s), M(t)) × p(w(s)
m | w(t)
am),
where qm(am | w(s), w(t)) is a measure of our conﬁdence in aligning source word w(s)
to target word w(t)
am. The relative frequencies could then be computed from the expected
counts,
ˆθu→v =Eq [count(u, v)]
count(u)
qm(am | w(s), w(t)) × δ(w(s)
m = v) × δ(w(t)
am = u).
Eq [count(u, v)] =
The expectation-maximization (EM) algorithm proceeds by iteratively updating qm
and ˆΘ. The algorithm is described in general form in chapter . For statistical machine
translation, the steps of the algorithm are:
. E-step: Update beliefs about word alignment using Equation ..
. M-step: Update the translation model using Equations . and ..
As discussed in chapter , the expectation maximization algorithm is guaranteed to con-
verge, but not to a global optimum. However, for IBM Model , it can be shown that EM
optimizes a convex objective, and global optimality is guaranteed. For this reason, IBM
Model  is often used as an initialization for more complex alignment models. For more
detail, see Koehn ().
Phrase-based translation
Real translations are not word-to-word substitutions. One reason is that many multiword
expressions are not translated literally, as shown in this example from French:
Nous
We
allons
will
prendre
take
un
verre
glass
We’ll have a drink
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
une
verre
Nous
allons
prendre
We’ll
have
drink
Figure .: A phrase-based alignment between French and English, corresponding to
example (.)
The line we will take a glass is the word-for-word gloss of the French sentence; the transla-
tion we’ll have a drink is shown on the third line. Such examples are difﬁcult for word-to-
word translation models, since they require translating prendre to have and verre to drink.
These translations are only correct in the context of these speciﬁc phrases.
Phrase-based translation generalizes on word-based models by building translation
tables and alignments between multiword spans. (These “phrases” are not necessarily
syntactic constituents like the noun phrases and verb phrases described in chapters  and
.) The generalization from word-based translation is surprisingly straightforward: the
translation tables can now condition on multi-word units, and can assign probabilities to
multi-word units; alignments are mappings from spans to spans, ((i, j), (k, ℓ)), so that
((i,j),(k,ℓ))∈A
pw(s)|w(t)({w(s)
i+, w(s)
i+, . . . , w(s)
j } | {w(t)
k+, w(t)
k+, . . . , w(t)
ℓ }).
p(w(s) | w(t), A) =
The phrase alignment ((i, j), (k, ℓ)) indicates that the span w(s)
i+:j is the translation of the
span w(t)
k+:ℓ. An example phrasal alignment is shown in Figure .. Note that the align-
ment set A is required to cover all of the tokens in the source, just as in word-based trans-
lation. The probability model pw(s)|w(t) must now include translations for all phrase pairs,
which can be learned from expectation-maximization just as in word-based statistical ma-
chine translation.
Jacob Eisenstein. Draft of November , .

.. STATISTICAL MACHINE TRANSLATION
*Syntax-based translation
The Vauquois Pyramid (Figure .) suggests that translation might be easier if we take a
higher-level view. One possibility is to incorporate the syntactic structure of the source,
the target, or both. This is particularly promising for language pairs that consistent syn-
tactic differences. For example, English adjectives almost always precede the nouns that
they modify, while in Romance languages such as French and Spanish, the adjective often
follows the noun: thus, angry ﬁsh would translate to pez (ﬁsh) enojado (angry) in Spanish.
In word-to-word translation, these reorderings cause the alignment model to be overly
permissive. It is not that the order of any pair of English words can be reversed when
translating into Spanish, but only adjectives and nouns within a noun phrase. Similar
issues arise when translating between verb-ﬁnal languages such as Japanese (in which
verbs usually follow the subject and object), verb-initial languages like Tagalog and clas-
sical Arabic, and verb-medial languages such as English.
An elegant solution is to link parsing and translation in a synchronous context-free
grammar (SCFG; Chiang, ). An SCFG is a set of productions of the form X → (α, β, ∼),
where X is a non-terminal, α and β are sequences of terminals or non-terminals, and ∼
is a one-to-one alignment of items in α with items in β. English-Spanish adjective-noun
ordering can be handled by a set of synchronous productions, e.g.,
NP → (DET NN JJ,
DET JJ NN),
with subscripts indicating the alignment between the Spanish (left) and English (right)
parts of the right-hand side. Terminal productions yield translation pairs,
JJ → (enojado,
angry).
A synchronous derivation begins with the start symbol S, and derives a pair of sequences
of terminal symbols.
Given an SCFG in which each production yields at most two symbols in each lan-
guage (Chomsky Normal Form; see § ..), a sentence can be parsed using only the CKY
algorithm (chapter ). The resulting derivation also includes productions in the other
language, all the way down to the surface form. Therefore, SCFGs make translation very
similar to parsing. In a weighted SCFG, the log probability log pS|T can be computed from
the sum of the log-probabilities of the productions. However, combining SCFGs with a
target language model is computationally expensive, necessitating approximate search
algorithms (Huang and Chiang, ).
Synchronous context-free grammars are an example of tree-to-tree translation, be-
cause they model the syntactic structure of both the target and source language. In string-
to-tree translation, string elements are translated into constituent tree fragments, which
Earlier approaches to syntactic machine translation includes syntax-driven transduction (Lewis II and
Stearns, ) and stochastic inversion transduction grammars (Wu, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
are then assembled into a translation (Yamada and Knight, ; Galley et al., ); in
tree-to-string translation, the source side is parsed, and then transformed into a string on
the target side (Liu et al., ). A key question for syntax-based translation is the extent
to which we phrasal constituents align across translations (Fox, ), because this gov-
erns the extent to which we can rely on monolingual parsers and treebanks. For more on
syntax-based machine translation, see the monograph by Williams et al. ().
Neural machine translation
Neural network models for machine translation are based on the encoder-decoder archi-
tecture (Cho et al., ). The encoder network converts the source language sentence into
a vector or matrix representation; the decoder network then converts the encoding into a
sentence in the target language.
z =ENCODE(w(s))
w(t) | w(s) ∼DECODE(z),
where the second line means that the function DECODE(z) deﬁnes the conditional proba-
bility p(w(t) | w(s)).
The decoder is typically a recurrent neural network, which generates the target lan-
guage sentence one word at a time, while recurrently updating a hidden state. The en-
coder and decoder networks are trained end-to-end from parallel sentences. If the output
layer of the decoder is a logistic function, then the entire architecture can be trained to
maximize the conditional log-likelihood,
log p(w(t) | w(s)) =
m=
p(w(t)
m | w(t)
:m−, z)
M(t)
p(w(t)
m | w(t)
:m−, w(s)) ∝ exp

βw(t)
m  h(t)
m−
where the hidden state h(t)
m− is a recurrent function of the previously generated text
w(t)
:m− and the encoding z. The second line is equivalent to writing,
w(t)
m | w(t)
:m−, w(s) ∼ SoftMax

β  h(t)
m−
where β ∈ R(V (t)×K) is the matrix of output word vectors for the V (t) words in the target
language vocabulary.
The simplest encoder-decoder architecture is the sequence-to-sequence model (Sutskever
et al., ). In this model, the encoder is set to the ﬁnal hidden state of a long short-term
Jacob Eisenstein. Draft of November , .

.. NEURAL MACHINE TRANSLATION
h(s,D)
m−
h(s,D)
h(s,D)
m+
. . .
. . .
. . .
h(s,)
m−
h(s,)
h(s,)
m+
h(s,)
m−
h(s,)
h(s,)
m+
x(s)
m−
x(s)
x(s)
m+
Figure .: A deep bidirectional LSTM encoder
memory (LSTM) (see § ..) on the source sentence:
h(s)
m =LSTM(x(s)
m , h(s)
m−)
z ≜h(s)
M(s),
where x(s)
m is the embedding of source language word w(s)
m . The encoding then provides
the initial hidden state for the decoder LSTM:
h(t)
=z
h(t)
m =LSTM(x(t)
m , h(t)
m−),
where x(t)
m is the embedding of the target language word w(t)
m .
Sequence-to-sequence translation is nothing more than wiring together two LSTMs:
one to read the source, and another to generate the target. To make the model work well,
some additional tweaks are needed:
Most notably, the model works much better if the source sentence is reversed, read-
ing from the end of the sentence back to the beginning. In this way, the words at the
beginning of the source have the greatest impact on the encoding z, and therefore
impact the words at the beginning of the target sentence. Later work on more ad-
vanced encoding models, such as neural attention (see § ..), has eliminated the
need for reversing the source sentence.
The encoder and decoder can be implemented as deep LSTMs, with multiple layers
of hidden states. As shown in Figure ., each hidden state h(s,i)
at layer i is treated
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
as the input to an LSTM at layer i + :
h(s,)
=LSTM(x(s)
m , h(s)
m−)
h(s,i+)
=LSTM(h(s,i)
, h(s,i+)
m−
∀i ≥ .
The original work on sequence-to-sequence translation used four layers; in ,
Google’s commercial machine translation system used eight layers (Wu et al., ).
Signiﬁcant improvements can be obtained by creating an ensemble of translation
models, each trained from a different random initialization. For an ensemble of size
N, the per-token decoding probability is set equal to,
p(w(t) | z, w(t)
:m−) =
i=
pi(w(t) | z, w(t)
:m−),
where pi is the decoding probability for model i. Each translation model in the
ensemble includes its own encoder and decoder networks.
The original sequence-to-sequence model used a fairly standard training setup: stochas-
tic gradient descent with an exponentially decreasing learning rate after the ﬁrst ﬁve
epochs; mini-batches of  sentences, chosen to have similar length so that each
sentence on the batch will take roughly the same amount of time to process; gradi-
ent clipping (see § ..) to ensure that the norm of the gradient never exceeds some
predeﬁned value.
Neural attention
The sequence-to-sequence model discussed in the previous section was a radical depar-
ture from statistical machine translation, in which each word or phrase in the target lan-
guage is conditioned on a single word or phrase in the source language. Both approaches
have advantages. Statistical translation leverages the idea of compositionality — transla-
tions of large units should be based on the translations of their component parts — and
this seems crucial if we are to scale translation to longer units of text. But the translation
of each word or phrase often depends on the larger context, and encoder-decoder models
capture this context at the sentence level.
Is it possible for translation to be both contextualized and compositional? One ap-
proach is to augment neural translation with an attention mechanism. The idea of neural
attention was described in § ., but its application to translation bears further discus-
sion. In general, attention can be thought of as using a query to select from a memory
of key-value pairs. However, the query, keys, and values are all vectors, and the entire
Google reports that this system took six days to train for English-French translation, using  NVIDIA
K GPUs, which would have cost roughly half a million dollars at the time.
Jacob Eisenstein. Draft of November , .

.. NEURAL MACHINE TRANSLATION
Output
activation
Query
ψα
Key
Value
Figure .: A general view of neural attention. The dotted box indicates that each αm→n
can be viewed as a gate on value n.
operation is differentiable. For each key n in the memory, we compute a score ψα(m, n)
with respect to the query m. That score is a function of the compatibility of the key and
the query, and can be computed using a small feedforward neural network. The vector
of scores is passed through an activation function, such as softmax. The output of this
activation function is a vector of non-negative numbers [αm→, αm→, . . . , αm→N]⊤, with
length N equal to the size of the memory. Each value in the memory vn is multiplied by
the attention αm→n; the sum of these scaled values is the output. This process is shown in
Figure .. In the extreme case that αm→n =  and αm→n′ =  for all other n′, then the
attention mechanism simply selects the value vn from the memory.
Neural attention makes it possible to integrate alignment into the encoder-decoder ar-
chitecture. Rather than encoding the entire source sentence into a ﬁxed length vector z,
it can be encoded into a matrix Z ∈ RK×M(S), where K is the dimension of the hidden
state, and M(S) is the number of tokens in the source input. Each column of Z represents
the state of a recurrent neural network over the source sentence. These vectors are con-
structed from a bidirectional LSTM (see § .), which can be a deep network as shown in
Figure .. These columns are both the keys and the values in the attention mechanism.
At each step m in decoding, the attentional state is computed by executing a query,
which is equal to the state of the decoder, h(t)
m . The resulting compatibility scores are,
ψα(m, n) =vα  tanh(Θα[h(t)
m ; h(s)
n ]).
The function ψ is thus a two layer feedforward neural network, with weights vα on the
output layer, and weights Θα on the input layer.
To convert these scores into atten-
tion weights, we apply an activation function, which can be vector-wise softmax or an
element-wise sigmoid:
Softmax attention
αm→n =
exp ψα(m, n)
PM(s)
n′= exp ψα(m, n′)
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
Sigmoid attention
αm→n = σ (ψα(m, n))
The attention α is then used to compute a context vector cm by taking a weighted
average over the columns of Z,
cm =
n=
αm→nzn,
M(s)
where αm→n ∈ [, ] is the amount of attention from word m of the target to word n of the
source. The context vector can be incorporated into the decoder’s word output probability
model, by adding another layer to the decoder (Luong et al., ):
˜h(t)
m = tanh

Θc[h(t)
m ; cm]

p(w(t)
m+ | w(t)
:m, w(s)) ∝ exp

βw(t)
m+  ˜h(t)
Here the decoder state h(t)
m is concatenated with the context vector, forming the input
to compute a ﬁnal output vector ˜h(t)
m . The context vector can be incorporated into the
decoder recurrence in a similar manner (Bahdanau et al., ).
*Neural machine translation without recurrence
In the encoder-decoder model, attention’s “keys and values” are the hidden state repre-
sentations in the encoder network, z, and the “queries” are state representations in the
decoder network h(t). It is also possible to completely eliminate recurrence from neural
translation, by applying self-attention (Lin et al., ; Kim et al., ) within the en-
coder and decoder, as in the transformer architecture (Vaswani et al., ). For level i,
the basic equations of the encoder side of the transformer are:
z(i)
m =
n=
α(i)
m→n(Θvh(i−)
M(s)
h(i)
m =Θ ReLU

Θz(i)
m + b
+ b.
For each token m at level i, we compute self-attention over the entire source sentence.
The keys, values, and queries are all projections of the vector h(i−): for example, in Equa-
tion ., the value vn is the projection Θvh(i−)
. The attention scores α(i)
m→n are com-
puted using a scaled form of softmax attention,
αm→n ∝ exp(ψα(m, n)/M),
Jacob Eisenstein. Draft of November , .

.. NEURAL MACHINE TRANSLATION
z(i)
α(i)
m→
ψ(i)
α (m, )
h(i−)
m −
m +
Figure .: The transformer encoder’s computation of z(i)
m from h(i−). The key, value,
and query are shown for token m − . For example, ψ(i)
α (m, m − ) is computed from
the key Θkh(i−)
m− and the query Θqh(i−)
, and the gate α(i)
m→m− operates on the value
Θvh(i−)
m− . The ﬁgure shows a minimal version of the architecture, with a single atten-
tion head. With multiple heads, it is possible to attend to different properties of multiple
words.
where M is the length of the input. This encourages the attention to be more evenly
dispersed across the input. Self-attention is applied across multiple “heads”, each using
different projections of h(i−) to form the keys, values, and queries. This architecture is
shown in Figure .. The output of the self-attentional layer is the representation z(i)
m ,
which is then passed through a two-layer feed-forward network, yielding the input to the
next layer, h(i). This self-attentional architecture can be applied in the decoder as well,
but this requires that there is zero attention to future words: αm→n =  for all n > m.
To ensure that information about word order in the source is integrated into the model,
the encoder augments the base layer of the network with positional encodings of the
indices of each word in the source. These encodings are vectors for each position m ∈
{, , . . . , M}. The transformer sets these encodings equal to a set of sinusoidal functions
of m,
ei−(m) = sin(m/(
Ke ))
ei(m) = cos(m/(
Ke )),
∀i ∈ {, , . . . , Ke/}
where ei(m) is the value at element i of the encoding for index m. As we progress
through the encoding, the sinusoidal functions have progressively narrower bandwidths.
This enables the model to learn to attend by relative positions of words. The positional
encodings are concatenated with the word embeddings xm at the base layer of the model.
The transformer architecture relies on several additional tricks, including layer normalization (see
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
Source:
The
ecotax
portico
in
Pont-de-buis was taken
down
on Thursday morning
Reference:
Le
portique ´ecotaxe
de
Pont-de-buis
´et´e
d´emont´e
jeudi
matin
System:
Le
unk
de
unk
`a unk
´et´e
pris
le
jeudi
matin
Figure .: Translation with unknown words. The system outputs unk to indicate words
that are outside its vocabulary. Figure adapted from Luong et al. ().
Convolutional neural networks (see § .) have also been applied as encoders in neu-
ral machine translation (Gehring et al., ). For each word w(s)
m , a convolutional network
computes a representation h(s)
m from the embeddings of the word and its neighbors. This
procedure is applied several times, creating a deep convolutional network. The recurrent
decoder then computes a set of attention weights over these convolutional representa-
tions, using the decoder’s hidden state h(t) as the queries. This attention vector is used
to compute a weighted average over the outputs of another convolutional neural network
of the source, yielding an averaged representation cm, which is then fed into the decoder.
As with the transformer, speed is the main advantage over recurrent encoding models;
another similarity is that word order information is approximated through the use of po-
sitional encodings.
Out-of-vocabulary words
Thus far, we have treated translation as a problem at the level of words or phrases. For
words that do not appear in the training data, all such models will struggle. There are
two main reasons for the presence of out-of-vocabulary (OOV) words:
New proper nouns, such as family names or organizations, are constantly arising —
particularly in the news domain. The same is true, to a lesser extent, for technical
terminology. This issue is shown in Figure ..
In many languages, words have complex internal structure, known as morphology.
An example is German, which uses compounding to form nouns like Abwasserbe-
handlungsanlage (sewage water treatment plant; example from Sennrich et al. ()).
§ ..), residual connections around the nonlinear activations (see § ..), and a non-monotonic learning
rate schedule.
A recent evaluation found that best performance was obtained by using a recurrent network for the
decoder, and a transformer for the encoder (Chen et al., ). The transformer was also found to signiﬁcantly
outperform a convolutional neural network.
Jacob Eisenstein. Draft of November , .

.. DECODING
While compounds could in principle be addressed by better tokenization (see § .),
other morphological processes involve more complex transformations of subword
units.
Names and technical terms can be handled in a postprocessing step: after ﬁrst identi-
fying alignments between unknown words in the source and target, we can look up each
aligned source word in a dictionary, and choose a replacement (Luong et al., ). If the
word does not appear in the dictionary, it is likely to be a proper noun, and can be copied
directly from the source to the target. This approach can also be integrated directly into
the translation model, rather than applying it as a postprocessing step (Jean et al., ).
Words with complex internal structure can be handled by translating subword units
rather than entire words. A popular technique for identifying subword units is byte-pair
encoding (BPE; Gage, ; Sennrich et al., ). The initial vocabulary is deﬁned as the
set of characters used in the text. The most common character bigram is then merged into
a new symbol, the vocabulary is updated, and the merging operation is applied again. For
example, given the dictionary {ﬁsh, ﬁshed, want, wanted, bike, biked}, we would ﬁrst form
the subword unit ed, since this character bigram appears in three of the six words. Next,
there are several bigrams that each appear in a pair of words: ﬁ, is, sh, wa, an, etc. These can
be merged in any order. By iterating this process, we eventually reach the segmentation,
{ﬁsh, ﬁsh+ed, want, want+ed, bik+e, bik+ed}. At this point, there are no bigrams that appear
more than once. In real data, merging is performed until the number of subword units
reaches some predeﬁned threshold, such as .
Each subword unit is treated as a token for translation, in both the encoder (source
side) and decoder (target side). BPE can be applied jointly to the union of the source and
target vocabularies, identifying subword units that appear in both languages. For lan-
guages that have different scripts, such as English and Russian, transliteration between
the scripts should be applied ﬁrst.
Decoding
Given a trained translation model, the decoding task is:
ˆw(t) = argmax
w∈V∗ Ψ(w, w(s)),
where w(t) is a sequence of tokens from the target vocabulary V. It is not possible to
efﬁciently obtain exact solutions to the decoding problem, for even minimally effective
Transliteration is crucial for converting names and other foreign words between languages that do not
share a single script, such as English and Japanese. It is typically approached using the ﬁnite-state methods
discussed in chapter  (Knight and Graehl, ).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
models in either statistical or neural machine translation. Today’s state-of-the-art transla-
tion systems use beam search (see § ..), which is an incremental decoding algorithm
that maintains a small constant number of competitive hypotheses. Such greedy approxi-
mations are reasonably effective in practice, and this may be in part because the decoding
objective is only loosely correlated with measures of translation quality, so that exact op-
timization of [.] may not greatly improve the resulting translations.
Decoding in neural machine translation is simpler than in phrase-based statistical ma-
chine translation. The scoring function Ψ is deﬁned,
Ψ(w(t), w(s)) =
m=
ψ(w(t)
m ; w(t)
:m−, z)
M(t)
w∈V
exp

βw  h(t)

ψ(w(t); w(t)
:m−, z) =βw(t)
m  h(t)
m − log
where z is the encoding of the source sentence w(s), and h(t)
m is a function of the encoding
z and the decoding history w(t)
:m−. This formulation subsumes the attentional translation
model, where z is a matrix encoding of the source.
Now consider the incremental decoding algorithm,
ˆw(t)
m = argmax
w∈V
ψ(w; ˆw(t)
:m−, z),
m = , , . . .
This algorithm selects the best target language word at position m, assuming that it has
already generated the sequence ˆw(t)
:m−. (Termination can be handled by augmenting
the vocabulary V with a special end-of-sequence token, ■.) The incremental algorithm
is likely to produce a suboptimal solution to the optimization problem deﬁned in Equa-
tion ., because selecting the highest-scoring word at position m can set the decoder
on a “garden path,” in which there are no good choices at some later position n > m. We
might hope for some dynamic programming solution, as in sequence labeling (§ .). But
the Viterbi algorithm and its relatives rely on a Markov decomposition of the objective
function into a sum of local scores: for example, scores can consider locally adjacent tags
(ym, ym−), but not the entire tagging history y:m. This decomposition is not applicable
to recurrent neural networks, because the hidden state h(t)
m is impacted by the entire his-
tory w(t)
:m; this sensitivity to long-range context is precisely what makes recurrent neural
networks so effective. In fact, it can be shown that decoding from any recurrent neural
network is NP-complete (Siegelmann and Sontag, ; Chen et al., ).
For more on decoding in phrase-based statistical models, see Koehn ().
Note that this problem does not impact RNN-based sequence labeling models (see § .). This is because
the tags produced by these models do not affect the recurrent state.
Jacob Eisenstein. Draft of November , .

.. TRAINING TOWARDS THE EVALUATION METRIC
Beam search
Beam search is a general technique for avoiding search errors when ex-
haustive search is impossible; it was ﬁrst discussed in § ... Beam search can be seen
as a variant of the incremental decoding algorithm sketched in Equation ., but at
each step m, a set of K different hypotheses are kept on the beam. For each hypothesis
k ∈ {, , . . . , K}, we compute both the current score PM(t)
m= ψ(w(t)
k,m; w(t)
k,:m−, z) as well as
the current hidden state h(t)
k . At each step in the beam search, the K top-scoring children
of each hypothesis currently on the beam are “expanded”, and the beam is updated. For
a detailed description of beam search for RNN decoding, see Graves ().
Learning and search
Conventionally, the learning algorithm is trained to predict the
right token in the translation, conditioned on the translation history being correct. But
if decoding must be approximate, then we might do better by modifying the learning
algorithm to be robust to errors in the translation history. Scheduled sampling does this
by training on histories that sometimes come from the ground truth, and sometimes come
from the model’s own output (Bengio et al., ). As training proceeds, the training
wheels come off: we increase the fraction of tokens that come from the model rather than
the ground truth. Another approach is to train on an objective that relates directly to beam
search performance (Wiseman et al., ). Reinforcement learning has also been applied
to decoding of RNN-based translation models, making it possible to directly optimize
translation metrics such as BLEU (Ranzato et al., ).
Training towards the evaluation metric
In likelihood-based training, the objective is the maximize the probability of a parallel
corpus. However, translations are not evaluated in terms of likelihood: metrics like BLEU
consider only the correctness of a single output translation, and not the range of prob-
abilities that the model assigns. It might therefore be better to train translation models
to achieve the highest BLEU score possible — to the extent that we believe BLEU mea-
sures translation quality. Unfortunately, BLEU and related metrics are not friendly for
optimization: they are discontinuous, non-differentiable functions of the parameters of
the translation model.
Consider an error function ∆( ˆw(t), w(t)), which measures the discrepancy between the
system translation ˆw(t) and the reference translation w(t); this function could be based on
BLEU or any other metric on translation quality. One possible criterion would be to select
Scheduled sampling builds on earlier work on learning to search (Daum´e III et al., ; Ross et al.,
), which are also described in § ...
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
the parameters θ that minimize the error of the system’s preferred translation,
ˆw(t) = argmax
w(t)
Ψ(w(t), w(s); θ)
ˆθ = argmin
∆( ˆw(t), w(s))
However, identifying the top-scoring translation ˆw(t) is usually intractable, as described
in the previous section. In minimum error-rate training (MERT), ˆw(t) is selected from a
set of candidate translations Y(w(s)); this is typically a strict subset of all possible transla-
tions, so that it is only possible to optimize an approximation to the true error rate (Och
and Ney, ).
A further issue is that the objective function in Equation . is discontinuous and
non-differentiable, due to the argmax over translations: an inﬁnitesimal change in the
parameters θ could cause another translation to be selected, with a completely different
error. To address this issue, we can instead minimize the risk, which is deﬁned as the
expected error rate,
R(θ) =E ˆ
w(t)|w(s);θ[∆( ˆw(t), w(t))]
w(t)∈Y(w(s))
p( ˆw(t) | w(s)) × ∆( ˆw(t), w(t)).
Minimum risk training minimizes the sum of R(θ) across all instances in the training set.
The risk can be generalized by exponentiating the translation probabilities,
˜p(w(t); θ, α) ∝

p(w(t) | w(s); θ)
˜R(θ) =
w(t)∈Y(w(s))
˜p( ˆw(t) | w(s); α, θ) × ∆( ˆw(t), w(t))
where Y(w(s)) is now the set of all possible translations for w(s). Exponentiating the prob-
abilities in this way is known as annealing (Smith and Eisner, ). When α = , then
˜R(θ) = R(θ); when α = ∞, then ˜R(θ) is equivalent to the sum of the errors of the maxi-
mum probability translations for each sentence in the dataset.
Clearly the set of candidate translations Y(w(s)) is too large to explicitly sum over.
Because the error function ∆ generally does not decompose into smaller parts, there is
no efﬁcient dynamic programming solution to sum over this set. We can approximate
the sum P
w(t)∈Y(w(s)) with a sum over a ﬁnite number of samples, {w(t)
, w(t)
, . . . , w(t)
K }.
If these samples were drawn uniformly at random, then the (annealed) risk would be
Jacob Eisenstein. Draft of November , .

.. TRAINING TOWARDS THE EVALUATION METRIC
approximated as (Shen et al., ),
˜R(θ) ≈
k=
˜p(w(t)
| w(s); θ, α) × ∆(w(t)
k , w(t))
Z =
k=
˜p(w(t)
| w(s); θ, α).
Shen et al. () report that performance plateaus at K =  for minimum risk training
of neural machine translation.
Uniform sampling over the set of all possible translations is undesirable, because most
translations have very low probability. A solution from Monte Carlo estimation is impor-
tance sampling, in which we draw samples from a proposal distribution q(w(s)). This
distribution can be set equal to the current translation model p(w(t) | w(s); θ). Each sam-
ple is then weighted by an importance score, ωk = ˜p(w(t)
k |w(s))
q(w(t)
k ;w(s)). The effect of this weighting
is to correct for any mismatch between the proposal distribution q and the true distribu-
tion ˜p. The risk can then be approximated as,
w(t)
∼q(w(s))
ωk = ˜p(w(t)
| w(s))
q(w(t)
k ; w(s))
k=
ωk × ∆(w(t)
k , w(t)).
˜R(θ) ≈
PK
k= ωk
Importance sampling will generally give a more accurate approximation than uniform
sampling. The only formal requirement is that the proposal assigns non-zero probability
to every w(t) ∈ Y(w(s)). For more on importance sampling and related methods, see
Robert and Casella ().
Additional resources
A complete textbook on machine translation is available from Koehn (). While this
book precedes recent work on neural translation, a more recent draft chapter on neural
translation models is also available (Koehn, ). Neubig () provides a compre-
hensive tutorial on neural machine translation, starting from ﬁrst principles. The course
notes from Cho () are also useful. Several neural machine translation libraries are
available: LAMTRAM is an implementation of neural machine translation in DYNET (Neu-
big et al., ); OPENNMT (Klein et al., ) and FAIRSEQ are available in PYTORCH;
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
TENSORTENSOR is an implementation of several of the Google translation models in TEN-
SORFLOW (Abadi et al., ).
Literary translation is especially challenging, even for expert human translators. Mes-
sud () describes some of these issues in her review of an English translation of L’´etranger,
the  French novel by Albert Camus. She compares the new translation by Sandra
Smith against earlier translations by Stuart Gilbert and Matthew Ward, focusing on the
difﬁculties presented by a single word in the ﬁrst sentence:
Then, too, Smith has reconsidered the book’s famous opening. Camus’s
original is deceptively simple: “Aujourd’hui, maman est morte.” Gilbert inﬂu-
enced generations by offering us “Mother died today”—inscribing in Meur-
sault [the narrator] from the outset a formality that could be construed as
heartlessness. But maman, after all, is intimate and affectionate, a child’s name
for his mother. Matthew Ward concluded that it was essentially untranslatable
(“mom” or “mummy” being not quite apt), and left it in the original French:
“Maman died today.” There is a clear logic in this choice; but as Smith has
explained, in an interview in The Guardian, maman “didn’t really tell the reader
anything about the connotation.” She, instead, has translated the sentence as
“My mother died today.”
I chose “My mother” because I thought about how someone would
tell another person that his mother had died. Meursault is speaking
to the reader directly. “My mother died today” seemed to me the
way it would work, and also implied the closeness of “maman” you
get in the French.
Elsewhere in the book, she has translated maman as “mama” — again, striving
to come as close as possible to an actual, colloquial word that will carry the
same connotations as maman does in French.
The passage is a reminder that while the quality of machine translation has improved
dramatically in recent years, expert human translations draw on considerations that are
beyond the ken of any contemporary computational approach.
Exercises
. Using Google translate or another online service, translate the following example
into two different languages of your choice:
The book review is currently available online at http://www.nybooks.com/articles///
/camus-new-letranger/.
Jacob Eisenstein. Draft of November , .

.. TRAINING TOWARDS THE EVALUATION METRIC
It is not down on any map; true places never are.
Then translate each result back into English. Which is closer to the original? Can
you explain the differences?
. Compute the unsmoothed n-gram precisions p . . . p for the two back-translations
in the previous problem, using the original source as the reference. Your n-grams
should include punctuation, and you should segment conjunctions like it’s into two
tokens.
. You are given the following dataset of translations from “simple” to “difﬁcult” En-
glish:
a. Kids
Children
like
adore
cats.
felines.
b. Cats
Felines
hats.
fedoras.
Estimate a word-to-word statistical translation model from simple English (source)
to difﬁcult English (target), using the expectation-maximization as described in § ...
Compute two iterations of the algorithm by hand, starting from a uniform transla-
tion model, and using the simple alignment model p(am | m, M(s), M(t)) =
M(t) .
Hint: in the ﬁnal M-step, you will want to switch from fractions to decimals.
. Building on the previous problem, what will be the converged translation proba-
bility table? Can you state a general condition about the data, under which this
translation model will fail in the way that it fails here?
. Propose a simple alignment model that would make it possible to recover the correct
translation probabilities from the toy dataset in the previous two problems.
. Let ℓ(t)
m+ represent the loss at word m+ of the target, and let h(s)
n represent the hid-
den state at word n of the source. Write the expression for the derivative
∂ℓ(t)
m+
∂h(s)
in the
sequence-to-sequence translation model expressed in Equations [.-.]. You
may assume that both the encoder and decoder are one-layer LSTMs. In general,
how many terms are on the shortest backpropagation path from ℓ(t)
m+ to h(s)
n ?
. Now consider the neural attentional model from § .., with sigmoid attention.
The derivative
∂ℓ(t)
m+
∂zn
is the sum of many paths through the computation graph;
identify the shortest such path. You may assume that the initial state of the decoder
recurrence h(t)
is not tied to the ﬁnal state of the encoder recurrence h(s)
M(s).
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . MACHINE TRANSLATION
. Apply byte-pair encoding for the vocabulary it, unit, unite, until no bigram appears
more than once.
. This problem relates to the complexity of machine translation. Suppose you have
an oracle that returns the list of words to include in the translation, so that your
only task is to order the words. Furthermore, suppose that the scoring function
over orderings is a sum over bigrams, PM
m= ψ(w(t)
m , w(t)
m−). Show that the problem
of ﬁnding the optimal translation is NP-complete, by reduction from a well-known
problem.
. Hand-design an attentional recurrent translation model that simply copies the input
from the source to the target. You may assume an arbitrarily large hidden state, and
you may assume that there is a ﬁnite maximum input length M. Specify all the
weights such that the maximum probability translation of any source is the source
itself. Hint: it is simplest to use the Elman recurrence hm = f(Θhm− + xm) rather
than an LSTM.
. Give a synchronized derivation (§ ..) for the Spanish-English translation,
El
The
pez
ﬁsh
enojado
angry
atacado.
attacked.
The angry ﬁsh attacked.
As above, the second line shows a word-for-word gloss, and the third line shows
the desired translation. Use the synchronized production rule in [.], and design
the other production rules necessary to derive this sentence pair. You may derive
(atacado, attacked) directly from VP.
Jacob Eisenstein. Draft of November , .

Chapter
Text generation
In many of the most interesting problems in natural language processing, language is
the output. The previous chapter described the speciﬁc case of machine translation, but
there are many other applications, from summarization of research articles, to automated
journalism, to dialogue systems. This chapter emphasizes three main scenarios: data-to-
text, in which text is generated to explain or describe a structured record or unstructured
perceptual input; text-to-text, which typically involves fusing information from multiple
linguistic sources into a single coherent summary; and dialogue, in which text is generated
as part of an interactive conversation with one or more human participants.
Data-to-text generation
In data-to-text generation, the input ranges from structured records, such as the descrip-
tion of an weather forecast (as shown in Figure .), to unstructured perceptual data,
such as a raw image or video; the output may be a single sentence, such as an image cap-
tion, or a multi-paragraph argument. Despite this diversity of conditions, all data-to-text
systems share some of the same challenges (Reiter and Dale, ):
determining what parts of the data to describe;
planning a presentation of this information;
lexicalizing the data into words and phrases;
organizing words and phrases into well-formed sentences and paragraphs.
The earlier stages of this process are sometimes called content selection and text plan-
ning; the later stages are often called surface realization.
Early systems for data-to-text generation were modular, with separate software com-
ponents for each task. Artiﬁcial intelligence planning algorithms can be applied to both
CHAPTER . TEXT GENERATION
Temperature
time
min
mean
max
Cloud sky cover
time
percent (%)
Wind speed
time
min
mean
max
Wind direction
time
mode
Cloudy, with temperatures between  and  degrees. South wind around  mph.
Figure .: An example input-output pair for the task of generating text descriptions of
weather forecasts (adapted from Konstas and Lapata, ).
the high-level information structure and the organization of individual sentences, ensur-
ing that communicative goals are met (McKeown, ; Moore and Paris, ). Surface
realization can be performed by grammars or templates, which link speciﬁc types of data
to candidate words and phrases. A simple example template is offered by Wiseman et al.
(), for generating descriptions of basketball games:
The <team> (<wins>-losses) defeated the <team> (<wins>-<losses>),
<pts>-<pts>.
The New York Knicks (-) defeated the Boston Celtics (-), -.
For more complex cases, it may be necessary to apply morphological inﬂections such as
pluralization and tense marking — even in the simple example above, languages such
as Russian would require case marking sufﬁxes for the team names. Such inﬂections can
be applied as a postprocessing step. Another difﬁcult challenge for surface realization is
the generation of varied referring expressions (e.g., The Knicks, New York, they), which is
critical to avoid repetition. As discussed in § .., the form of referring expressions is
constrained by the discourse and information structure.
An example at the intersection of rule-based and statistical techniques is the NITRO-
GEN system (Langkilde and Knight, ). The input to NITROGEN is an abstract meaning
representation (AMR; see § .) of semantic content to be expressed in a single sentence.
In data-to-text scenarios, the abstract meaning representation is the output of a higher-
level text planning stage. A set of rules then converts the abstract meaning representation
into various sentence plans, which may differ in both the high-level structure (e.g., active
versus passive voice) as well as the low-level details (e.g., word and phrase choice). Some
examples are shown in Figure .. To control the combinatorial explosion in the number
of possible realizations for any given meaning, the sentence plans are uniﬁed into a single
ﬁnite-state acceptor, in which word tokens are represented by arcs (see § ..). A bigram
Jacob Eisenstein. Draft of November , .

.. DATA-TO-TEXT GENERATION
Visitors who came to Japan admire Mount
Fuji.
Visitors who came in Japan admire Mount
Fuji.
(a / admire-
:ARG (v / visitor
:ARG-of (c / arrive-
:ARG (j / Japan)))
:ARG (m / "Mount Fuji"))
Mount Fuji is admired by the visitor who
came in Japan.
Figure .: Abstract meaning representation and candidate surface realizations from the
NITROGEN system. Example adapted from Langkilde and Knight ().
language model is then used to compute weights on the arcs, so that the shortest path is
also the surface realization with the highest bigram language model probability.
More recent systems are uniﬁed models that are trained end-to-end using backpropa-
gation. Data-to-text generation shares many properties with machine translation, includ-
ing a problem of alignment: labeled examples provide the data and the text, but they do
not specify which parts of the text correspond to which parts of the data. For example, to
learn from Figure ., the system must align the word cloudy to records in CLOUD SKY
COVER, the phrases  and  degrees to the MIN and MAX ﬁelds in TEMPERATURE, and
so on. As in machine translation, both latent variables and neural attention have been
proposed as solutions.
Latent data-to-text alignment
Given a dataset of texts and associated records {(w(i), y(i))}N
i=, our goal is to learn a
model Ψ, so that
ˆw = argmax
w∈V∗ Ψ(w, y; θ),
where V∗ is the set of strings over a discrete vocabulary, and θ is a vector of parameters.
The relationship between w and y is complex: the data y may contain dozens of records,
and w may extend to several sentences. To facilitate learning and inference, it would be
helpful to decompose the scoring function Ψ into subcomponents. This would be possi-
ble if given an alignment, specifying which element of y is expressed in each part of w.
Speciﬁcally, let zm indicates the record aligned to word m. For example, in Figure ., z
might specify that the word cloudy is aligned to the record cloud-sky-cover:percent.
The score for this alignment would then be given by the weight on features such as
(cloudy, cloud-sky-cover:percent).
In general, given an observed set of alignments, the score for a generation can be
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . TEXT GENERATION
written as sum of local scores (Angeli et al., ):
Ψ(w, y; θ) =
m=
ψw,y(wm, yzm) + ψw(wm, wm−) + ψz(zm, zm−),
where ψw can represent a bigram language model, and ψz can be tuned to reward coher-
ence, such as the use of related records in nearby words.  The parameters of this model
could be learned from labeled data {(w(i), y(i), z(i))}N
i=. However, while several datasets
include structured records and natural language text (Barzilay and McKeown, ; Chen
and Mooney, ; Liang and Klein, ), the alignments between text and records are
usually not available. One solution is to model the problem probabilistically, treating the
alignment as a latent variable (Liang et al., ; Konstas and Lapata, ). The model
can then be estimated using expectation maximization or sampling (see chapter ).
Neural data-to-text generation
The encoder-decoder model and neural attention were introduced in § . as methods
for neural machine translation. They can also be applied to data-to-text generation, with
the data acting as the source language (Mei et al., ). In neural machine translation,
the attention mechanism linked words in the source to words in the target; in data-to-
text generation, the attention mechanism can link each part of the generated text back
to a record in the data. The biggest departure from translation is in the encoder, which
depends on the form of the data.
Data encoders
In some types of structured records, all values are drawn from discrete sets. For example,
the birthplace of an individual is drawn from a discrete set of possible locations; the diag-
nosis and treatment of a patient are drawn from an exhaustive list of clinical codes (John-
son et al., ). In such cases, vector embeddings can be estimated for each ﬁeld and
possible value: for example, a vector embedding for the ﬁeld BIRTHPLACE, and another
embedding for the value BERKELEY CALIFORNIA (Bordes et al., ). The table of such
embeddings serves as the encoding of a structured record (He et al., ). It is also possi-
ble to compress the entire table into a single vector representation, by pooling across the
embeddings of each ﬁeld and value (Lebret et al., ).
More expressive decompositions of Ψ are possible. For example, Wong and Mooney () use a syn-
chronous context-free grammar (see § ..) to “translate” between a meaning representation and natural
language text.
An exception is a dataset of records and summaries from American football games, containing annota-
tions of alignments between sentences and records (Snyder and Barzilay, ).
Jacob Eisenstein. Draft of November , .

.. DATA-TO-TEXT GENERATION
Figure .: Examples of the image captioning task, with attention masks shown for each
of the underlined words (Xu et al., ).
Sequences
Some types of structured records have a natural ordering, such as events in
a game (Chen and Mooney, ) and steps in a recipe (Tutin and Kittredge, ). For
example, the following records describe a sequence of events in a robot soccer match (Mei
et al., ):
PASS(arg = PURPLE, arg = PURPLE)
KICK(arg = PURPLE)
BADPASS(arg = PURPLE, arg = PINK).
Each event is a single record, and can be encoded by a concatenation of vector represen-
tations for the event type (e.g., PASS), the ﬁeld (e.g., arg), and the values (e.g., PURPLE),
e.g.,
X =
uPASS, uarg, uPURPLE, uarg, uPURPLE
This encoding can then act as the input layer for a recurrent neural network, yielding a
sequence of vector representations {zr}R
r=, where r indexes over records. Interestingly,
this sequence-based approach can work even in cases where there is no natural ordering
over the records, such as the weather data in Figure . (Mei et al., ).
Images
Another ﬂavor of data-to-text generation is the generation of text captions for
images. Examples from this task are shown in Figure .. Images are naturally repre-
sented as tensors: a color image of  ×  pixels would be stored as a tensor with
×  ×  intensity values. The dominant approach to image classiﬁcation is to en-
code images as vectors using a combination of convolution and pooling (Krizhevsky et al.,
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . TEXT GENERATION
id-: temperature(min=,max=,mean=)
id-: windSpeed(min=,mean=,max=)
id-: skyCover(mode=-)
id-: precipChance(min=,mean=,max=)
id-: thunderChance(mode=SChc)
of
and
with
high
near
after
noon
cloudy
mostly
chance
showers
thunderstorms
Figure .: Neural attention in text generation. Figure adapted from Mei et al. ().
). Chapter  explains how to use convolutional networks for text; for images, convo-
lution is applied across the vertical, horizontal, and color dimensions. By pooling the re-
sults of successive convolutions, the image is converted to a vector representation, which
can then be fed directly into the decoder as the initial state (Vinyals et al., ), just as
in the sequence-to-sequence translation model (see § .). Alternatively, one can apply
a set of convolutional networks, yielding vector representations for different parts of the
image, which can then be combined using neural attention (Xu et al., ).
Attention
Given a set of embeddings of the data {zr}R
r= and a decoder state hm, an attention vector
over the data can be computed using the same techniques as in machine translation (see
§ ..). When generating word m of the output, attention is computed over the records,
ψα(m, r) =βα  f(Θα[hm; zr])
αm =g ([ψα(m, ), ψα(m, ), . . . , ψα(m, R)])
cm =
r=
αm→rzr,
where f is an elementwise nonlinearity such as tanh or ReLU, and g is a either softmax or
elementwise sigmoid. The weighted sum cm can then be included in the recurrent update
to the decoder state, or in the emission probabilities, as described in § ... Figure .
shows the attention to components of a weather record, while generating the text shown
on the x-axis.
Adapting this architecture to image captioning is straightforward. A convolutional
neural networks is applied to a set of image locations, and the output at each location ℓ is
represented with a vector zℓ. Attention can then be computed over the image locations,
as shown in the right panels of each pair of images in Figure ..
Jacob Eisenstein. Draft of November , .

.. DATA-TO-TEXT GENERATION
Various modiﬁcations to this basic mechanism have been proposed. In coarse-to-ﬁne
attention (Mei et al., ), each record receives a global attention ar ∈ [, ], which is
independent of the decoder state. This global attention, which represents the overall
importance of the record, is multiplied with the decoder-based attention scores, before
computing the ﬁnal normalized attentions. In structured attention, the attention vector
αm→ can include structural biases, which can favor assigning higher attention values to
contiguous segments or to dependency subtrees (Kim et al., ). Structured attention
vectors can be computed by running the forward-backward algorithm to obtain marginal
attention probabilities (see § ..). Because each step in the forward-backward algorithm
is differentiable, it can be encoded in a computation graph, and end-to-end learning can
be performed by backpropagation.
Decoder
Given the encoding, the decoder can function just as in neural machine translation (see
§ ..), using the attention-weighted encoder representation in the decoder recurrence
and/or output computation. As in machine translation, beam search can help to avoid
search errors (Lebret et al., ).
Many applications require generating words that do not appear in the training vocab-
ulary. For example, a weather record may contain a previously unseen city name; a sports
record may contain a previously unseen player name. Such tokens can be generated in the
text by copying them over from the input (e.g., Gulcehre et al., ). First introduce an
additional variable sm ∈ {gen, copy}, indicating whether token w(t)
m should be generated
or copied. The decoder probability is then,
p(w(t) | w(t)
:m−, Z, sm) =
SoftMax(βw(t)  h(t)
m−),
sm = gen
PR
r= δ

w(s)
= w(t)
× αm→r,
sm = copy,
where δ(w(s)
= w(t)) is an indicator function, taking the value  iff the text of the record
w(s)
is identical to the target word w(t). The probability of copying record r from the source
is δ (sm = copy) × αm→r, the product of the copy probability by the local attention. Note
that in this model, the attention weights αm are computed from the previous decoder state
hm−. The computation graph therefore remains a feedforward network, with recurrent
paths such as h(t)
m− → αm → w(t)
m → h(t)
m .
To facilitate end-to-end training, the switching variable sm can be represented by a
gate πm, which is computed from a two-layer feedforward network, whose input consists
of the concatenation of the decoder state h(t)
m− and the attention-weighted representation
A number of variants of this strategy have been proposed (e.g., Gu et al., ; Merity et al., ). See
Wiseman et al. () for an overview.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . TEXT GENERATION
of the data, cm = PR
r= αm→rzr,
πm = σ(Θ()f(Θ()[h(t)
m−; cm])).
The full generative probability at token m is then,
+( − πm) ×
r=
δ(w(s)
= w(t)) × αm→r
{z
copy
p(w(t) | w(t)
:m, Z) =πm ×
exp βw(t)  h(t)
m−
PV
j= exp βj  h(t)
m−
{z
generate
Text-to-text generation
Text-to-text generation includes problems of summarization and simpliﬁcation:
reading a novel and outputting a paragraph-long summary of the plot;
reading a set of blog posts about politics, and outputting a bullet list of the various
issues and perspectives;
reading a technical research article about the long-term health consequences of drink-
ing kombucha, and outputting a summary of the article in language that non-experts
can understand.
These problems can be approached in two ways: through the encoder-decoder architec-
ture discussed in the previous section, or by operating directly on the input text.
Neural abstractive summarization
Sentence summarization is the task of shortening a sentence while preserving its mean-
ing, as in the following examples (Knight and Marcu, ; Rush et al., ):
a. The documentation is typical of Epson quality: excellent.
Documentation is excellent.
b. Russian defense minister Ivanov called sunday for the creation of a joint front
for combating global terrorism.
Russia calls for joint front against terrorism.
In § .., we encountered a special case of single-document summarization, which involved extract-
ing the most important sentences or discourse units. We now consider the more challenging problem of
abstractive summarization, in which the summary can include words that do not appear in the original text.
Jacob Eisenstein. Draft of November , .

.. TEXT-TO-TEXT GENERATION
Sentence summarization is closely related to sentence compression, in which the sum-
mary is produced by deleting words or phrases from the original (Clarke and Lapata,
). But as shown in (.b), a sentence summary can also introduce new words, such
as against, which replaces the phrase for combatting.
Sentence summarization can be treated as a machine translation problem, using the at-
tentional encoder-decoder translation model discussed in § .. (Rush et al., ). The
longer sentence is encoded into a sequence of vectors, one for each token. The decoder
then computes attention over these vectors when updating its own recurrent state. As
with data-to-text generation, it can be useful to augment the encoder-decoder model with
the ability to copy words directly from the source. Rush et al. () train this model by
building four million sentence pairs from news articles. In each pair, the longer sentence is
the ﬁrst sentence of the article, and the summary is the article headline. Sentence summa-
rization can also be trained in a semi-supervised fashion, using a probabilistic formulation
of the encoder-decoder model called a variational autoencoder (Miao and Blunsom, ,
also see § ..).
When summarizing longer documents, an additional concern is that the summary not
be repetitive: each part of the summary should cover new ground. This can be addressed
by maintaining a vector of the sum total of all attention values thus far, tm = Pm
n= αn.
This total can be used as an additional input to the computation of the attention weights,
αm→n ∝ exp

vα  tanh(Θα[h(t)
m ; h(s)
n ; tm])

which enables the model to learn to prefer parts of the source which have not been at-
tended to yet (Tu et al., ). To further encourage diversity in the generated summary,
See et al. () introduce a coverage loss to the objective function,
ℓm =
n=
min(αm→n, tm→n).
M(s)
This loss will be low if αmassigns little attention to words that already have large values in
tm.Coverage loss is similar to the concept of marginal relevance, in which the reward for
adding new content is proportional to the extent to which it increases the overall amount
of information conveyed by the summary (Carbonell and Goldstein, ).
Sentence fusion for multi-document summarization
In multi-document summarization, the goal is to produce a summary that covers the
content of several documents (McKeown et al., ). One approach to this challenging
problem is to identify sentences across multiple documents that relate to a single theme,
and then to fuse them into a single sentence (Barzilay and McKeown, ). As an exam-
ple, consider the following two sentences (McKeown et al., ):
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . TEXT GENERATION
a. Palin actually turned against the bridge project only after it became a national
symbol of wasteful spending.
b. Ms.
Palin supported the bridge project while running for governor, and
abandoned it after it became a national scandal.
An intersection preserves only the content that is present in both sentences:
Palin turned against the bridge project after it became a national scandal.
A union includes information from both sentences:
Ms. Palin supported the bridge project while running for governor, but turned
against it when it became a national scandal and a symbol of wasteful spending.
Dependency parsing is often used as a technique for sentence fusion. After parsing
each sentence, the resulting dependency trees can be aggregated into a lattice (Barzilay
and McKeown, ) or a graph structure (Filippova and Strube, ), in which identical
or closely related words (e.g., Palin, bridge, national) are fused into a single node. The
resulting graph can then be pruned back to a tree by solving an integer linear program
(see § ..),
max
i,j,r
ψ(i r−→ j, w; θ) × yi,j,r
s.t.
y ∈ C,
where the variable yi,j,r ∈ {, } indicates whether there is an edge from i to j of type r,
the score of this edge is ψ(i r−→ j, w; θ), and C is a set of constraints, which ensures that y
forms a valid dependency graph. As usual, w is the list of words in the graph, and θ is a
vector of parameters. The score ψ(i
r−→ j, w; θ) reﬂects the “importance” of the modiﬁer
j to the overall meaning: in intersective fusion, this score indicates the extent to which
the content in this edge is expressed in all sentences; in union fusion, the score indicates
whether the content in the edge is expressed in any sentence. The constraint set C can
impose additional linguistic constraints: for example, ensuring that coordinated nouns
are sufﬁciently similar. The resulting tree must then be linearized into a sentence. Lin-
earization is like the inverse of dependency parsing: instead of parsing from a sequence
of tokens into a tree, we must convert the tree back into a sequence of tokens. This is
typically done by generating a set of candidate linearizations, and choosing the one with
the highest score under a language model (Langkilde and Knight, ; Song et al., ).
Dialogue
Dialogue systems are capable of conversing with a human interlocutor, often to per-
form some task (Grosz, ), but sometimes just to chat (Weizenbaum, ). While re-
Jacob Eisenstein. Draft of November , .

.. DIALOGUE
start
What toppings?
Topping
No
What address?
Address
Conﬁrm?
Yes
A: I want to order a pizza.
B: What toppings?
A: Anchovies.
B: Ok, what address?
A: The College of Computing
building.
B: Please conﬁrm:
one pizza
with artichokes, to be delivered
to the College of Computing
building.
A: No.
B: What toppings?
. . .
Figure .: An example dialogue and the associated ﬁnite-state model. In the ﬁnite-state
model, SMALL CAPS indicates that the user must provide information of this type in their
answer.
search on dialogue systems goes back several decades (Carbonell, ; Winograd, ),
commercial systems such as Alexa and Siri have recently brought this technology into
widespread use. Nonetheless, there is a signiﬁcant gap between research and practice:
many practical dialogue systems remain scripted and inﬂexible, while research systems
emphasize abstractive text generation, “on-the-ﬂy” decision making, and probabilistic
reasoning about the user’s intentions.
Finite-state and agenda-based dialogue systems
Finite-state automata were introduced in chapter  as a formal model of computation,
in which string inputs and outputs are linked to transitions between a ﬁnite number of
discrete states. This model naturally ﬁts simple task-oriented dialogues, such as the one
shown in the left panel of Figure .. This (somewhat frustrating) dialogue can be repre-
sented with a ﬁnite-state transducer, as shown in the right panel of the ﬁgure. The accept-
ing state is reached only when the two needed pieces of information are provided, and the
human user conﬁrms that the order is correct. In this simple scenario, the TOPPING and
ADDRESS are the two slots associated with the activity of ordering a pizza, which is called
a frame. Frame representations can be hierarchical: for example, an ADDRESS could have
slots of its own, such as STREET and CITY.
In the example dialogue in Figure ., the user provides the precise inputs that are
needed in each turn (e.g., anchovies; the College of Computing building). Some users may
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . TEXT GENERATION
prefer to communicate more naturally, with phrases like I’d, uh, like some anchovies please.
One approach to handling such utterances is to design a custom grammar, with non-
terminals for slots such as TOPPING and LOCATION. However, context-free parsing of
unconstrained speech input is challenging. A more lightweight alternative is BIO-style
sequence labeling (see § .), e.g.:
I’d
like
anchovies
B-TOPPING
and
please
bring
it
to
the
B-ADDR
College
I-ADDR
of
I-ADDR
Computing
I-ADDR
Building
I-ADDR
The tagger can be driven by a bi-directional recurrent neural network, similar to recurrent
approaches to semantic role labeling described in § ...
The input in (.) could not be handled by the ﬁnite-state system from Figure .,
which forces the user to provide the topping ﬁrst, and then the location. In this sense, the
“initiative” is driven completely by the system. Agenda-based dialogue systems extend
ﬁnite-state architectures by attempting to recognize all slots that are ﬁlled by the user’s re-
ply, thereby handling these more complex examples. Agenda-based systems dynamically
pose additional questions until the frame is complete (Bobrow et al., ; Allen et al.,
; Rudnicky and Xu, ). Such systems are said to be mixed-initiative, because both
the user and the system can drive the direction of the dialogue.
Markov decision processes
The task of dynamically selecting the next move in a conversation is known as dialogue
management. This problem can be framed as a Markov decision process, which is a
theoretical model that includes a discrete set of states, a discrete set of actions, a function
that computes the probability of transitions between states, and a function that computes
the cost or reward of action-state pairs. Let’s see how each of these elements pertains to
the pizza ordering dialogue system.
Each state is a tuple of information about whether the topping and address are
known, and whether the order has been conﬁrmed. For example,
(KNOWN TOPPING, UNKNOWN ADDRESS, NOT CONFIRMED)
is a possible state. Any state in which the pizza order is conﬁrmed is a terminal
state, and the Markov decision process stops after entering such a state.
The set of actions includes querying for the topping, querying for the address, and
requesting conﬁrmation. Each action induces a probability distribution over states,
p(st | at, st−). For example, requesting conﬁrmation of the order is not likely to
Jacob Eisenstein. Draft of November , .

.. DIALOGUE
result in a transition to the terminal state if the topping is not yet known. This
probability distribution over state transitions may be learned from data, or it may
be speciﬁed in advance.
Each state-action-state tuple earns a reward, ra(st, st+). In the context of the pizza
ordering system, a simple reward function would be,
ra(st, st−) =

a = CONFIRM, st = (*, *, CONFIRMED)
a = CONFIRM, st = (*, *, NOT CONFIRMED)
a ̸= CONFIRM

This function assigns zero reward for successful transitions to the terminal state, a
large negative reward to a rejected request for conﬁrmation, and a small negative re-
ward for every other type of action. The system is therefore rewarded for reaching
the terminal state in few steps, and penalized for prematurely requesting conﬁrma-
tion.
In a Markov decision process, a policy is a function π : S → A that maps from states
to actions (see § ..). The value of a policy is the expected sum of discounted rewards,
Eπ[PT
t= γtrat(st, st+)], where γ is the discount factor, γ ∈ [, ). Discounting has the
effect of emphasizing rewards that can be obtained immediately over less certain rewards
in the distant future.
An optimal policy can be obtained by dynamic programming, by iteratively updating
the value function V (s), which is the expectation of the cumulative reward from s under
the optimal action a,
V (s) ← max
a∈A
s′∈S
p(s′ | s, a)[ra(s, s′) + γV (s′)].
The value function V (s) is computed in terms of V (s′) for all states s′ ∈ S. A series
of iterative updates to the value function will eventually converge to a stationary point.
This algorithm is known as value iteration. Given the converged value function V (s), the
optimal action at each state is the argmax,
π(s) = argmax
a∈A
s′∈S
p(s′ | s, a)[ra(s, s′) + γV (s′)].
Value iteration and related algorithms are described in detail by Sutton and Barto ().
For applications to dialogue systems, see Levin et al. () and Walker ().
The Markov decision process framework assumes that the current state of the dialogue
is known. In reality, the system may misinterpret the user’s statements — for example,
believing that a speciﬁcation of the delivery location (PEACHTREE) is in fact a speciﬁcation
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . TEXT GENERATION
of the topping (PEACHES). In a partially observable Markov decision process (POMDP),
the system receives an observation o, which is probabilistically conditioned on the state,
p(o | s). It must therefore maintain a distribution of beliefs about which state it is in, with
qt(s) indicating the degree of belief that the dialogue is in state s at time t. The POMDP
formulation can help to make dialogue systems more robust to errors, particularly in the
context of spoken language dialogues, where the speech itself may be misrecognized (Roy
et al., ; Williams and Young, ). However, ﬁnding the optimal policy in a POMDP
is computationally intractable, requiring additional approximations.
Neural chatbots
It’s easier to talk when you don’t need to get anything done. Chatbots are systems that
parry the user’s input with a response that keeps the conversation going. They can be
built from the encoder-decoder architecture discussed in § . and § ..: the encoder
converts the user’s input into a vector, and the decoder produces a sequence of words as a
response. For example, Shang et al. () apply the attentional encoder-decoder transla-
tion model, training on a dataset of posts and responses from the Chinese microblogging
platform Sina Weibo. This approach is capable of generating replies that relate themati-
cally to the input, as shown in the following examples (translated from Chinese by Shang
et al., ).
a. A: High fever attacks me every New Year’s day.
B: Get well soon and stay healthy!
b. A: I gain one more year. Grateful to my group, so happy.
B: Getting old now. Time has no mercy.
While encoder-decoder models can generate responses that make sense in the con-
text of the immediately preceding turn, they struggle to maintain coherence over longer
conversations. One solution is to model the dialogue context recurrently. This creates
a hierarchical recurrent network, including both word-level and turn-level recurrences.
The turn-level hidden state is then used as additional context in the decoder (Serban et al.,
An open question is how to integrate the encoder-decoder architecture into task-oriented
dialogue systems. Neural chatbots can be trained end-to-end: the user’s turn is analyzed
by the encoder, and the system output is generated by the decoder. This architecture
can be trained by log-likelihood using backpropagation (e.g., Sordoni et al., ; Serban
et al., ), or by more elaborate objectives, using reinforcement learning (Li et al., ).
In contrast, the task-oriented dialogue systems described in § .. typically involve a
Twitter is also frequently used for construction of dialogue datasets (Ritter et al., ; Sordoni et al.,
). Another source is technical support chat logs from the Ubuntu linux distribution (Uthus and Aha,
; Lowe et al., ).
Jacob Eisenstein. Draft of November , .

.. DIALOGUE
set of specialized modules: one for recognizing the user input, another for deciding what
action to take, and a third for arranging the text of the system output.
Recurrent neural network decoders can be integrated into Markov Decision Process
dialogue systems, by conditioning the decoder on a representation of the information
that is to be expressed in each turn (Wen et al., ). Speciﬁcally, the long short-term
memory (LSTM; § .) architecture is augmented so that the memory cell at turn m takes
an additional input dm, which is a representation of the slots and values to be expressed
in the next turn. However, this approach still relies on additional modules to recognize
the user’s utterance and to plan the overall arc of the dialogue.
Another promising direction is to create embeddings for the elements in the domain:
for example, the slots in a record and the entities that can ﬁll them. The encoder then
encodes not only the words of the user’s input, but the embeddings of the elements that
the user mentions. Similarly, the decoder is endowed with the ability to refer to speciﬁc
elements in the knowledge base. He et al. () show that such a method can learn to
play a collaborative dialogue game, in which both players are given a list of entities and
their properties, and the goal is to ﬁnd an entity that is on both players’ lists.
Additional resources
Gatt and Krahmer () provide a comprehensive recent survey on text generation. For
a book-length treatment of earlier work, see Reiter and Dale (). For a survey on image
captioning, see Bernardi et al. (); for a survey of pre-neural approaches to dialogue
systems, see Rieser and Lemon (). Dialogue acts were introduced in § . as a label-
ing scheme for human-human dialogues; they also play a critical in task-based dialogue
systems (e.g., Allen et al., ). The incorporation of theoretical models of dialogue into
computational systems is reviewed by Jurafsky and Martin (, chapter ).
While this chapter has focused on the informative dimension of text generation, an-
other line of research aims to generate text with conﬁgurable stylistic properties (Walker
et al., ; Mairesse and Walker, ; Ficler and Goldberg, ; Hu et al., ). This
chapter also does not address the generation of creative text such as narratives (Riedl and
Young, ), jokes (Ritchie, ), poems (Colton et al., ), and song lyrics (Gonc¸alo Oliveira
et al., ).
Exercises
. Find an article about a professional basketball game, with an associated “box score”
of statistics. Which are the ﬁrst three elements in the box score that are expressed
in the article? Can you identify template-based patterns that express these elements
of the record? Now ﬁnd a second article about a different basketball game. Does it
Under contract with MIT Press, shared under CC-BY-NC-ND license.

CHAPTER . TEXT GENERATION
mention the same ﬁrst three elements of the box score? Do your templates capture
how these elements are expressed in the text?
. This exercise is to be done by a pair of students. One student should choose an article
from the news or from Wikipedia, and manually perform semantic role labeling
(SRL) on three short sentences or clauses. (See chapter  for a review of SRL.)
Identify the main the semantic relation and its arguments and adjuncts. Pass this
structured record — but not the original sentence — to the other student, whose
job is to generate a sentence expressing the semantics. Then reverse roles, and try
to regenerate three sentences from another article, based on the predicate-argument
semantics.
. Compute the BLEU scores (see § ..) for the generated sentences in the previous
problem, using the original article text as the reference.
. Align each token in the text of Figure . to a speciﬁc single record in the database,
or to the null record ∅. For example, the tokens south wind would align to the record
wind direction:
mode=S. How often is each token aligned
to the same record as the previous token? How many transitions are there? How
might a system learn to output  degrees for the record min=?
. In sentence compression and fusion, we may wish to preserve contiguous sequences
of tokens (n-grams) and/or dependency edges. Find ﬁve short news articles with
headlines. For each headline, compute the fraction of bigrams that appear in the
main text of the article. Then do a manual depenency parse of the headline. For
each dependency edge, count how often it appears as a dependency edge in the
main text. You may use an automatic dependency parser to assist with this exercise,
but check the output, and focus on UD . dependency grammar, as described in
chapter .
. § .. presents the idea of generating text from dependency trees, which requires
linearization. Sometimes there are multiple ways that a dependency tree can be
linearized. For example:
a. The sick kids stayed at home in bed.
b. The sick kids stayed in bed at home.
Both sentences have an identical dependency parse: both home and bed are (oblique)
dependents of stayed.
Identify two more English dependency trees that can each be linearized in more than
one way, and try to use a different pattern of variation in each tree. As usual, specify
your trees in the Universal Dependencies  style, which is described in chapter .
Jacob Eisenstein. Draft of November , .

.. DIALOGUE
. In § .., we considered a pizza delivery service. Let’s simplify the problem to
take-out, where it is only necessary to determine the topping and conﬁrm the order.
The state is a tuple in which the ﬁrst element is T if the topping is speciﬁed and ?
otherwise, and the second element is either YES or NO, depending on whether the
order has been conﬁrmed. The actions are TOPPING? (request information about
the topping) and CONFIRM? (request conﬁrmation). The state transition function is:
p(st | st− = (?, NO), a = TOPPING?) =
st = (T, NO)
st = (?, NO).
p(st | st− = (?, NO), a = CONFIRM?) =
st = (?, NO).
p(st | st− = (T, NO), a = TOPPING?) =
st = (T, NO).
p(st | st− = (T, NO), a = CONFIRM?) =
st = (T, YES)
st = (T, NO).
Using the reward function deﬁned in Equation ., the discount γ = ., and the
initialization V (s) = , execute three iterations of Equation .. After these three
iterations, compute the optimal action in each state. You can assume that for the
terminal states, V (*, YES) = , so you only need to compute the values for non-
terminal states, V (?, NO) and V (T, NO).
. There are several toolkits that allow you to train encoder-decoder translation models
“out of the box”, such as FAIRSEQ (Gehring et al., ), XNMT (Neubig et al., ),
TENSORTENSOR (Vaswani et al., ), and OPENNMT (Klein et al., ). Use one
of these toolkits to train a chatbot dialogue system, using either the NPS dialogue
corpus that comes with NLTK (Forsyth and Martell, ), or, if you are feeling more
ambitious, the Ubuntu dialogue corpus (Lowe et al., ).
https://github.com/facebookresearch/fairseq;
https://github.com/neulab/xnmt;
https://github.com/tensorflow/tensortensor; http://opennmt.net/
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Appendix A
Probability
Probability theory provides a way to reason about random events. The sorts of random
events that are typically used to explain probability theory include coin ﬂips, card draws,
and the weather. It may seem odd to think about the choice of a word as akin to the ﬂip of
a coin, particularly if you are the type of person to choose words carefully. But random or
not, language has proven to be extremely difﬁcult to model deterministically. Probability
offers a powerful tool for modeling and manipulating linguistic data.
Probability can be thought of in terms of random outcomes: for example, a single coin
ﬂip has two possible outcomes, heads or tails. The set of possible outcomes is the sample
space, and a subset of the sample space is an event. For a sequence of two coin ﬂips,
there are four possible outcomes, {HH, HT, TH, TT}, representing the ordered sequences
heads-head, heads-tails, tails-heads, and tails-tails. The event of getting exactly one head
includes two outcomes: {HT, TH}.
Formally, a probability is a function from events to the interval between zero and one:
Pr : F → [, ], where F is the set of possible events. An event that is certain has proba-
bility one; an event that is impossible has probability zero. For example, the probability
of getting fewer than three heads on two coin ﬂips is one. Each outcome is also an event
(a set with exactly one element), and for two ﬂips of a fair coin, the probability of each
outcome is,
[A.]
Pr({HH}) = Pr({HT}) = Pr({TH}) = Pr({TT}) =
A.
Probabilities of event combinations
Because events are sets of outcomes, we can use set-theoretic operations such as comple-
ment, intersection, and union to reason about the probabilities of events and their combi-
nations.
APPENDIX A. PROBABILITY
For any event A, there is a complement ¬A, such that:
The probability of the union A ∪ ¬A is Pr(A ∪ ¬A) = ;
The intersection A ∩ ¬A = ∅ is the empty set, and Pr(A ∩ ¬A) = .
In the coin ﬂip example, the event of obtaining a single head on two ﬂips corresponds to
the set of outcomes {HT, TH}; the complement event includes the other two outcomes,
{TT, HH}.
A..
Probabilities of disjoint events
When two events have an empty intersection, A ∩ B = ∅, they are disjoint. The probabil-
ity of the union of two disjoint events is equal to the sum of their probabilities,
A ∩ B = ∅
Pr(A ∪ B) = Pr(A) + Pr(B).
[A.]
This is the third axiom of probability, and it can be generalized to any countable sequence
of disjoint events.
In the coin ﬂip example, this axiom can derive the probability of the event of getting a
single head on two ﬂips. This event is the set of outcomes {HT, TH}, which is the union
of two simpler events, {HT, TH} = {HT} ∪ {TH}. The events {HT} and {TH} are
disjoint. Therefore,
Pr({HT, TH}) = Pr({HT} ∪ {TH}) = Pr({HT}) + Pr({TH})
[A.]
[A.]
In the general, the probability of the union of two events is,
Pr(A ∪ B) = Pr(A) + Pr(B) − Pr(A ∩ B).
[A.]
This can be seen visually in Figure A., and it can be derived from the third axiom of
probability. Consider an event that includes all outcomes in B that are not in A, denoted
as B − (A ∩ B). By construction, this event is disjoint from A. We can therefore apply the
additive rule,
Pr(A ∪ B) = Pr(A) + Pr(B − (A ∩ B)).
[A.]
Furthermore, the event B is the union of two disjoint events: A ∩ B and B − (A ∩ B).
Pr(B) = Pr(B − (A ∩ B)) + Pr(A ∩ B).
[A.]
Reorganizing and subtituting into Equation A. gives the desired result:
Pr(B − (A ∩ B)) = Pr(B) − Pr(A ∩ B)
[A.]
Pr(A ∪ B) = Pr(A) + Pr(B) − Pr(A ∩ B).
[A.]
Jacob Eisenstein. Draft of November , .

A.. CONDITIONAL PROBABILITY AND BAYES’ RULE
A ∩ B
Figure A.: A visualization of the probability of non-disjoint events A and B.
A..
Law of total probability
A set of events B = {B, B, . . . , BN} is a partition of the sample space iff each pair of
events is disjoint (Bi ∩ Bj = ∅), and the union of the events is the entire sample space.
The law of total probability states that we can marginalize over these events as follows,
Bn∈B
Pr(A ∩ Bn).
[A.]
Pr(A) =
For any event B, the union B ∪ ¬B is a partition of the sample space. Therefore, a special
case of the law of total probability is,
Pr(A) = Pr(A ∩ B) + Pr(A ∩ ¬B).
[A.]
A.
Conditional probability and Bayes’ rule
A conditional probability is an expression like Pr(A | B), which is the probability of
the event A, assuming that event B happens too. For example, we may be interested
in the probability of a randomly selected person answering the phone by saying hello,
conditioned on that person being a speaker of English. Conditional probability is deﬁned
as the ratio,
Pr(B)
[A.]
Pr(A | B) = Pr(A ∩ B)
The chain rule of probability states that Pr(A ∩ B) = Pr(A | B) × Pr(B), which is just
Under contract with MIT Press, shared under CC-BY-NC-ND license.

APPENDIX A. PROBABILITY
a rearrangement of terms from Equation A.. The chain rule can be applied repeatedly:
Pr(A ∩ B ∩ C) = Pr(A | B ∩ C) × Pr(B ∩ C)
= Pr(A | B ∩ C) × Pr(B | C) × Pr(C).
Bayes’ rule (sometimes called Bayes’ law or Bayes’ theorem) gives us a way to convert
between Pr(A | B) and Pr(B | A). It follows from the deﬁnition of conditional probability
and the chain rule:
Pr(B)
= Pr(B | A) × Pr(A)
Pr(B)
[A.]
Pr(A | B) = Pr(A ∩ B)
Each term in Bayes rule has a name, which we will occasionally use:
Pr(A) is the prior, since it is the probability of event A without knowledge about
whether B happens or not.
Pr(B | A) is the likelihood, the probability of event B given that event A has oc-
curred.
Pr(A | B) is the posterior, the probability of event A with knowledge that B has
occurred.
Example
The classic examples for Bayes’ rule involve tests for rare diseases, but Man-
ning and Sch¨utze () reframe this example in a linguistic setting. Suppose that you are
is interested in a rare syntactic construction, such as parasitic gaps, which occur on average
once in , sentences. Here is an example of a parasitic gap:
(A.)
Which class did you attend
without registering for
Lana Linguist has developed a complicated pattern matcher that attempts to identify
sentences with parasitic gaps. It’s pretty good, but it’s not perfect:
If a sentence has a parasitic gap, the pattern matcher will ﬁnd it with probability
.. (This is the recall, which is one minus the false negative rate.)
If the sentence doesn’t have a parasitic gap, the pattern matcher will wrongly say it
does with probability .. (This is the false positive rate, which is one minus the
precision.)
Suppose that Lana’s pattern matcher says that a sentence contains a parasitic gap. What
is the probability that this is true?
Jacob Eisenstein. Draft of November , .

A.. INDEPENDENCE
Let G be the event of a sentence having a parasitic gap, and T be the event of the test
being positive. We are interested in the probability of a sentence having a parasitic gap
given that the test is positive. This is the conditional probability Pr(G | T), and it can be
computed by Bayes’ rule:
Pr(T)
[A.]
Pr(G | T) =Pr(T | G) × Pr(G)
We already know both terms in the numerator: Pr(T | G) is the recall, which is .; Pr(G)
is the prior, which is −.
We are not given the denominator, but it can be computed using tools developed ear-
lier in this section. First apply the law of total probability, using the partition {G, ¬G}:
Pr(T) = Pr(T ∩ G) + Pr(T ∩ ¬G).
[A.]
This says that the probability of the test being positive is the sum of the probability of a
true positive (T ∩ G) and the probability of a false positive (T ∩ ¬G). The probability of
each of these events can be computed using the chain rule:
Pr(T ∩ G) = Pr(T | G) × Pr(G) = . × −
[A.]
Pr(T ∩ ¬G) = Pr(T | ¬G) × Pr(¬G) = . × ( − −) ≈ .
[A.]
Pr(T) = Pr(T ∩ G) + Pr(T ∩ ¬G)
[A.]
=. × − + ..
[A.]
Plugging these terms into Bayes’ rule gives the desired posterior probability,
Pr(T)
[A.]
Pr(G | T) =Pr(T | G) Pr(G)
. × −
. × − + . × ( − −)
[A.]
[A.]
Lana’s pattern matcher seems accurate, with false positive and false negative rates
below %. Yet the extreme rarity of the phenomenon means that a positive result from the
detector is most likely to be wrong.
A.
Independence
Two events are independent if the probability of their intersection is equal to the product
of their probabilities: Pr(A ∩ B) = Pr(A) × Pr(B). For example, for two ﬂips of a fair
Under contract with MIT Press, shared under CC-BY-NC-ND license.

APPENDIX A. PROBABILITY
coin, the probability of getting heads on the ﬁrst ﬂip is independent of the probability of
getting heads on the second ﬂip:
[A.]
Pr({HT, HH}) = Pr(HT) + Pr(HH) =
[A.]
Pr({HH, TH}) = Pr(HH) + Pr(TH) =
[A.]
Pr({HT, HH}) × Pr({HH, TH}) =
[A.]
Pr({HT, HH} ∩ {HH, TH}) = Pr(HH) =
= Pr({HT, HH}) × Pr({HH, TH}).
[A.]
If Pr(A ∩ B | C) = Pr(A | C) × Pr(B | C), then the events A and B are conditionally
independent, written A ⊥ B | C. Conditional independence plays a important role in
probabilistic models such as Na¨ıve Bayes chapter .
A.
Random variables
Random variables are functions from events to Rn, where R is the set of real numbers.
This subsumes several useful special cases:
An indicator random variable is a function from events to the set {, }. In the coin
ﬂip example, we can deﬁne Y as an indicator random variable, taking the value
when the coin has come up heads on at least one ﬂip. This would include the
outcomes {HH, HT, TH}. The probability Pr(Y = ) is the sum of the probabilities
of these outcomes, Pr(Y = ) =
A discrete random variable is a function from events to a discrete subset of R. Con-
sider the coin ﬂip example: the number of heads on two ﬂips, X, can be viewed as a
discrete random variable, X ∈ , , . The event probability Pr(X = ) can again be
computed as the sum of the probabilities of the events in which there is one head,
{HT, TH}, giving Pr(X = ) =
Each possible value of a random variable is associated with a subset of the sample
space. In the coin ﬂip example, X =  is associated with the event {TT}, X =  is
associated with the event {HT, TH}, and X =  is associated with the event {HH}.
Assuming a fair coin, the probabilities of these events are, respectively, /, /, and /.
This list of numbers represents the probability distribution over X, written pX, which
maps from the possible values of X to the non-negative reals. For a speciﬁc value x, we
write pX(x), which is equal to the event probability Pr(X = x). The function pX is called
In general, capital letters (e.g., X) refer to random variables, and lower-case letters (e.g., x) refer to
speciﬁc values. When the distribution is clear from context, I will simply write p(x).
Jacob Eisenstein. Draft of November , .

A.. EXPECTATIONS
pX(x)dx =
[A.]
a probability mass function (pmf) if X is discrete; it is called a probability density function
(pdf) if X is continuous. In either case, the function must sum to one, and all values must
be non-negative:
∀x, pX(x) ≥.
[A.]
Probabilities over multiple random variables can written as joint probabilities, e.g.,
pA,B(a, b) = Pr(A = a ∩ B = b). Several properties of event probabilities carry over to
probability distributions over random variables:
The marginal probability distribution is pA(a) = P
b pA,B(a, b).
pB(b) .
The conditional probability distribution is pA|B(a | b) =
pA,B(a,b)
Random variables A and B are independent iff pA,B(a, b) = pA(a) × pB(b).
A.
Expectations
Sometimes we want the expectation of a function, such as E[g(x)] = P
x∈X g(x)p(x).
Expectations are easiest to think about in terms of probability distributions over discrete
events:
If it is sunny, Lucia will eat three ice creams.
If it is rainy, she will eat only one ice cream.
There’s a % chance it will be sunny.
The expected number of ice creams she will eat is . ×  + . ×  = ..
If the random variable X is continuous, the expectation is an integral:
E[g(x)] =
g(x)p(x)dx
[A.]
For example, a fast food restaurant in Quebec has a special offer for cold days: they give
a % discount on poutine for every degree below zero. Assuming a thermometer with
inﬁnite precision, the expected price would be an integral over all possible temperatures,
E[price(x)] =
min(,  + x) × original-price × p(x)dx.
[A.]
Under contract with MIT Press, shared under CC-BY-NC-ND license.

APPENDIX A. PROBABILITY
A.
Modeling and estimation
Probabilistic models provide a principled way to reason about random events and ran-
dom variables. Let’s consider the coin toss example. Each toss can be modeled as a ran-
dom event, with probability θ of the event H, and probability  − θ of the complementary
event T. If we write a random variable X as the total number of heads on three coin
ﬂips, then the distribution of X depends on θ. In this case, X is distributed as a binomial
random variable, meaning that it is drawn from a binomial distribution, with parameters
(θ, N = ). This is written,
X ∼ Binomial(θ, N = ).
[A.]
The properties of the binomial distribution enable us to make statements about the X,
such as its expected value and the likelihood that its value will fall within some interval.
Now suppose that θ is unknown, but we have run an experiment, in which we exe-
cuted N trials, and obtained x heads. We can estimate θ by the principle of maximum
likelihood:
ˆθ = argmax
pX(x; θ, N).
[A.]
This says that the estimate ˆθ should be the value that maximizes the likelihood of the
data. The semicolon indicates that θ and N are parameters of the probability function.
The likelihood pX(x; θ, N) can be computed from the binomial distribution,
pX(x; θ, N) =
N!
x!(N − x)!θx( − θ)N−x.
[A.]
This likelihood is proportional to the product of the probability of individual out-
comes: for example, the sequence T, H, H, T, H would have probability θ( − θ). The
term
N!
x!(N−x)! arises from the many possible orderings by which we could obtain x heads
on N trials. This term does not depend on θ, so it can be ignored during estimation.
In practice, we maximize the log-likelihood, which is a monotonic function of the like-
lihood. Under the binomial distribution, the log-likelihood is a convex function of θ (see
Jacob Eisenstein. Draft of November , .

A.. MODELING AND ESTIMATION
§ .), so it can be maximized by taking the derivative and setting it equal to zero.
ℓ(θ) =x log θ + (N − x) log( − θ)
[A.]
∂ℓ(θ)
∂θ
=x
θ − N − x
− θ
[A.]
[A.]
N − x
− θ =x
N − x
= − θ
[A.]
x −  =
θ −
[A.]
ˆθ = x
N .
[A.]
In this case, the maximum likelihood estimate is equal to x
N , the fraction of trials that
came up heads. This intuitive solution is also known as the relative frequency estimate,
since it is equal to the relative frequency of the outcome.
Is maximum likelihood estimation always the right choice? Suppose you conduct one
trial, and get heads. Would you conclude that θ = , meaning that the coin is guaran-
teed to come up heads? If not, then you must have some prior expectation about θ. To
incorporate this prior information, we can treat θ as a random variable, and use Bayes’
rule:
p(θ | x; N) =p(x | θ) × p(θ)
p(x)
[A.]
∝p(x | θ) × p(θ)
[A.]
ˆθ = argmax
p(x | θ) × p(θ).
[A.]
This it the maximum a posteriori (MAP) estimate. Given a form for p(θ), you can de-
rive the MAP estimate using the same approach that was used to derive the maximum
likelihood estimate.
Additional resources
A good introduction to probability theory is offered by Manning and Sch¨utze (),
which helped to motivate this section. For more detail, Sharon Goldwater provides an-
other useful reference, http://homepages.inf.ed.ac.uk/sgwater/teaching/general/
probability.pdf. A historical and philosophical perspective on probability is offered
by Diaconis and Skyrms ().
Under contract with MIT Press, shared under CC-BY-NC-ND license.

Appendix B
Numerical optimization
Unconstrained numerical optimization involves solving problems of the form,
min
x∈RD f(x),
[B.]
where x ∈ RD is a vector of D real numbers.
Differentiation is fundamental to numerical optimization. Suppose that at some x∗,
every partial derivative of f is equal to : formally,
∂f
∂xi

x∗ = . Then x∗ is said to be a
critical point of f. If f is a convex function (deﬁned in § .), then the value of f(x∗) is
equal to the global minimum of f iff x∗ is a critical point of f.
As an example, consider the convex function f(x) = (x−)+, shown in Figure B.a.
The derivative is ∂f
∂x = x−. A unique minimum can be obtained by setting the derivative
equal to zero and solving for x, obtaining x∗ = . Now consider the multivariate convex
function f(x) =
||x − [, ]⊤||, where ||x|| is the squared Euclidean norm. The partial
(x
) +
|x|
cos(x)
(a) The function f(x) = (x − ) +
(b) The function f(x) = |x| −  cos(x)
Figure B.: Two functions with unique global minima
APPENDIX B. NUMERICAL OPTIMIZATION
derivatives are,
∂d
∂x
= x −
[B.]
∂d
∂x
= x −
[B.]
The unique minimum is x∗ = [, ]⊤.
For non-convex functions, critical points are not necessarily global minima. A local
minimum x∗ is a point at which the function takes a smaller value than at all nearby
neighbors: formally, x∗ is a local minimum if there is some positive ϵ such that f(x∗) ≤
f(x) for all x within distance ϵ of x∗. Figure B.b shows the function f(x) = |x|− cos(x),
which has many local minima, as well as a unique global minimum at x = . A critical
point may also be the local or global maximum of the function; it may be a saddle point,
which is a minimum with respect to at least one coordinate, and a maximum with respect
at least one other coordinate; it may be an inﬂection point, which is neither or a minimum
nor maximum. When available, the second derivative of f can help to distinguish these
cases.
B.
Gradient descent
For many convex functions, it is not possible to solve for x∗ in closed form. In gradient
descent, we compute a series of solutions, x(), x(), . . . by taking steps along the local
gradient ∇x(t)f, which is the vector of partial derivatives of the function f, evaluated at
the point x(t). Each solution x(t+) is computed,
x(t+) ←x(t) − η(t)∇x(t)f.
[B.]
where η(t) >  is a step size. If the step size is chosen appropriately, this procedure will
ﬁnd the global minimum of a differentiable convex function. For non-convex functions,
gradient descent will ﬁnd a local minimum. The extension to non-differentiable convex
functions is discussed in § ..
B.
Constrained optimization
Optimization must often be performed under constraints: for example, when optimizing
the parameters of a probability distribution, the probabilities of all events must sum to
one. Constrained optimization problems can be written,
min
f(x)
[B.]
s.t. gc(x) ≤ ,
∀c = , , . . . , C
[B.]
Jacob Eisenstein. Draft of November , .

B.. EXAMPLE: PASSIVE-AGGRESSIVE ONLINE LEARNING
where each gc(x) is a scalar function of x. For example, suppose that x must be non-
negative, and that its sum cannot exceed a budget b. Then there are D +  inequality
constraints,
gi(x) = − xi,
∀i = , , . . . , D
[B.]
gD+(x) = − b +
i=
xi.
[B.]
Inequality constraints can be combined with the original objective function f by form-
ing a Lagrangian,
L(x, λ) = f(x) +
c=
λcgc(x),
[B.]
where λc is a Lagrange multiplier. For any Lagrangian, there is a corresponding dual
form, which is a function of λ:
D(λ) = min
x L(x, λ).
[B.]
The Lagrangian L can be referred to as the primal form.
B.
Example: Passive-aggressive online learning
Sometimes it is possible to solve a constrained optimization problem by manipulating the
Lagrangian. One example is maximum-likelihood estimation of a Na¨ıve Bayes probability
model, as described in § ... In that case, it is unnecessary to explicitly compute the
Lagrange multiplier. Another example is illustrated by the passive-aggressive algorithm
for online learning (Crammer et al., ). This algorithm is similar to the perceptron, but
the goal at each step is to make the most conservative update that gives zero margin loss
on the current example. Each update can be formulated as a constrained optimization
over the weights θ:
min
||θ − θ(i−)||
[B.]
s.t. ℓ(i)(θ) =
[B.]
where θ(i−) is the previous set of weights, and ℓ(i)(θ) is the margin loss on instance i. As
in § .., this loss is deﬁned as,
ℓ(i)(θ) =  − θ  f(x(i), y(i)) + max
y̸=y(i) θ  f(x(i), y).
[B.]
This is the basis for the name of the algorithm: it is passive when the loss is zero, but it aggressively
moves to make the loss zero when necessary.
Under contract with MIT Press, shared under CC-BY-NC-ND license.

APPENDIX B. NUMERICAL OPTIMIZATION
When the margin loss is zero for θ(i−), the optimal solution is θ∗ = θ(i−), so we will
focus on the case where ℓ(i)(θ(i−)) > . The Lagrangian for this problem is,
L(θ, λ) =
||θ − θ(i−)|| + λℓ(i)(θ),
[B.]
Holding λ constant, we can solve for θ by differentiating,
∂θℓ(i)(θ)
[B.]
∇θL =θ − θ(i−) + λ ∂
θ∗ =θ(i−) + λδ,
[B.]
where δ = f(x(i), y(i)) − f(x(i), ˆy) and ˆy = argmaxy̸=y(i) θ  f(x(i), y).
The Lagrange multiplier λ acts as the learning rate in a perceptron-style update to θ.
We can solve for λ by plugging θ∗ back into the Lagrangian, obtaining the dual function,
D(λ) =
||θ(i−) + λδ − θ(i−)|| + λ( − (θ(i−) + λδ)  δ)
[B.]
=λ
||δ|| − λ||δ|| + λ( − θ(i−)  δ)
[B.]
= − λ
||δ|| + λℓ(i)(θ(i−)).
[B.]
Differentiating and solving for λ,
∂D
∂λ = − λ||δ|| + ℓ(i)(θ(i−))
[B.]
λ∗ =ℓ(i)(θ(i−))
||δ||
[B.]
The complete update equation is therefore:
θ∗ = θ(i−) +
ℓ(i)(θ(i−))
||f(x(i), y(i)) − f(x(i), ˆy)|| (f(x(i), y(i)) − f(x(i), ˆy)).
[B.]
This learning rate makes intuitive sense. The numerator grows with the loss; the denom-
inator grows with the norm of the difference between the feature vectors associated with
the correct and predicted label. If this norm is large, then the step with respect to each
feature should be small, and vice versa.
Jacob Eisenstein. Draft of November , .